ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART_1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	UART_1_initVar
  18              		.bss
  19              		.type	UART_1_initVar, %object
  20              		.size	UART_1_initVar, 1
  21              	UART_1_initVar:
  22 0000 00       		.space	1
  23              		.section	.text.UART_1_Start,"ax",%progbits
  24              		.align	2
  25              		.global	UART_1_Start
  26              		.code	16
  27              		.thumb_func
  28              		.type	UART_1_Start, %function
  29              	UART_1_Start:
  30              	.LFB0:
  31              		.file 1 ".\\Generated_Source\\PSoC4\\UART_1.c"
   1:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/UART_1.c **** * File Name: UART_1.c
   3:.\Generated_Source\PSoC4/UART_1.c **** * Version 2.40
   4:.\Generated_Source\PSoC4/UART_1.c **** *
   5:.\Generated_Source\PSoC4/UART_1.c **** * Description:
   6:.\Generated_Source\PSoC4/UART_1.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC4/UART_1.c **** *
   8:.\Generated_Source\PSoC4/UART_1.c **** * Note:
   9:.\Generated_Source\PSoC4/UART_1.c **** *
  10:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  11:.\Generated_Source\PSoC4/UART_1.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC4/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC4/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC4/UART_1.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC4/UART_1.c **** 
  17:.\Generated_Source\PSoC4/UART_1.c **** #include "UART_1.h"
  18:.\Generated_Source\PSoC4/UART_1.c **** #if (UART_1_INTERNAL_CLOCK_USED)
  19:.\Generated_Source\PSoC4/UART_1.c ****     #include "UART_1_IntClock.h"
  20:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  21:.\Generated_Source\PSoC4/UART_1.c **** 
  22:.\Generated_Source\PSoC4/UART_1.c **** 
  23:.\Generated_Source\PSoC4/UART_1.c **** /***************************************
  24:.\Generated_Source\PSoC4/UART_1.c **** * Global data allocation
  25:.\Generated_Source\PSoC4/UART_1.c **** ***************************************/
  26:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 2


  27:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_initVar = 0u;
  28:.\Generated_Source\PSoC4/UART_1.c **** 
  29:.\Generated_Source\PSoC4/UART_1.c **** #if (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED)
  30:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TX_BUFFER_SIZE];
  31:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC4/UART_1.c **** #endif /* (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED) */
  34:.\Generated_Source\PSoC4/UART_1.c **** 
  35:.\Generated_Source\PSoC4/UART_1.c **** #if (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED))
  36:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_errorStatus = 0u;
  37:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RX_BUFFER_SIZE];
  38:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferRead  = 0u;
  39:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  40:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  41:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow   = 0u;
  42:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  43:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RX_ADDRESS_MODE;
  44:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  45:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
  46:.\Generated_Source\PSoC4/UART_1.c **** #endif /* (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED)) */
  47:.\Generated_Source\PSoC4/UART_1.c **** 
  48:.\Generated_Source\PSoC4/UART_1.c **** 
  49:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  50:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Start
  51:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  52:.\Generated_Source\PSoC4/UART_1.c **** *
  53:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  54:.\Generated_Source\PSoC4/UART_1.c **** *  This is the preferred method to begin component operation.
  55:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Start() sets the initVar variable, calls the
  56:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Init() function, and then calls the
  57:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Enable() function.
  58:.\Generated_Source\PSoC4/UART_1.c **** *
  59:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
  60:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  61:.\Generated_Source\PSoC4/UART_1.c **** *
  62:.\Generated_Source\PSoC4/UART_1.c **** * Return:
  63:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  64:.\Generated_Source\PSoC4/UART_1.c **** *
  65:.\Generated_Source\PSoC4/UART_1.c **** * Global variables:
  66:.\Generated_Source\PSoC4/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  67:.\Generated_Source\PSoC4/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  68:.\Generated_Source\PSoC4/UART_1.c **** *  and set to one (1u) the first time UART_1_Start() is called. This
  69:.\Generated_Source\PSoC4/UART_1.c **** *  allows for component initialization without re-initialization in all
  70:.\Generated_Source\PSoC4/UART_1.c **** *  subsequent calls to the UART_1_Start() routine.
  71:.\Generated_Source\PSoC4/UART_1.c **** *
  72:.\Generated_Source\PSoC4/UART_1.c **** * Reentrant:
  73:.\Generated_Source\PSoC4/UART_1.c **** *  No.
  74:.\Generated_Source\PSoC4/UART_1.c **** *
  75:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  76:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Start(void) 
  77:.\Generated_Source\PSoC4/UART_1.c **** {
  32              		.loc 1 77 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 3


  38 0002 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  78:.\Generated_Source\PSoC4/UART_1.c ****     /* If not initialized then initialize all required hardware and software */
  79:.\Generated_Source\PSoC4/UART_1.c ****     if(UART_1_initVar == 0u)
  40              		.loc 1 79 0
  41 0004 064B     		ldr	r3, .L3
  42 0006 1B78     		ldrb	r3, [r3]
  43 0008 002B     		cmp	r3, #0
  44 000a 04D1     		bne	.L2
  80:.\Generated_Source\PSoC4/UART_1.c ****     {
  81:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_Init();
  45              		.loc 1 81 0
  46 000c FFF7FEFF 		bl	UART_1_Init
  82:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_initVar = 1u;
  47              		.loc 1 82 0
  48 0010 034B     		ldr	r3, .L3
  49 0012 0122     		mov	r2, #1
  50 0014 1A70     		strb	r2, [r3]
  51              	.L2:
  83:.\Generated_Source\PSoC4/UART_1.c ****     }
  84:.\Generated_Source\PSoC4/UART_1.c **** 
  85:.\Generated_Source\PSoC4/UART_1.c ****     UART_1_Enable();
  52              		.loc 1 85 0
  53 0016 FFF7FEFF 		bl	UART_1_Enable
  86:.\Generated_Source\PSoC4/UART_1.c **** }
  54              		.loc 1 86 0
  55 001a BD46     		mov	sp, r7
  56              		@ sp needed
  57 001c 80BD     		pop	{r7, pc}
  58              	.L4:
  59 001e C046     		.align	2
  60              	.L3:
  61 0020 00000000 		.word	UART_1_initVar
  62              		.cfi_endproc
  63              	.LFE0:
  64              		.size	UART_1_Start, .-UART_1_Start
  65              		.section	.text.UART_1_Init,"ax",%progbits
  66              		.align	2
  67              		.global	UART_1_Init
  68              		.code	16
  69              		.thumb_func
  70              		.type	UART_1_Init, %function
  71              	UART_1_Init:
  72              	.LFB1:
  87:.\Generated_Source\PSoC4/UART_1.c **** 
  88:.\Generated_Source\PSoC4/UART_1.c **** 
  89:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  90:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Init
  91:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  92:.\Generated_Source\PSoC4/UART_1.c **** *
  93:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  94:.\Generated_Source\PSoC4/UART_1.c **** *  Initializes or restores the component according to the customizer Configure
  95:.\Generated_Source\PSoC4/UART_1.c **** *  dialog settings. It is not necessary to call UART_1_Init() because
  96:.\Generated_Source\PSoC4/UART_1.c **** *  the UART_1_Start() API calls this function and is the preferred
  97:.\Generated_Source\PSoC4/UART_1.c **** *  method to begin component operation.
  98:.\Generated_Source\PSoC4/UART_1.c **** *
  99:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 4


 100:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 101:.\Generated_Source\PSoC4/UART_1.c **** *
 102:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 103:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 104:.\Generated_Source\PSoC4/UART_1.c **** *
 105:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 106:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Init(void) 
 107:.\Generated_Source\PSoC4/UART_1.c **** {
  73              		.loc 1 107 0
  74              		.cfi_startproc
  75 0000 80B5     		push	{r7, lr}
  76              		.cfi_def_cfa_offset 8
  77              		.cfi_offset 7, -8
  78              		.cfi_offset 14, -4
  79 0002 00AF     		add	r7, sp, #0
  80              		.cfi_def_cfa_register 7
 108:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 109:.\Generated_Source\PSoC4/UART_1.c **** 
 110:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 111:.\Generated_Source\PSoC4/UART_1.c ****             /* Set RX interrupt vector and priority */
 112:.\Generated_Source\PSoC4/UART_1.c ****             (void) CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 113:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 114:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_errorStatus = 0u;
 115:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 116:.\Generated_Source\PSoC4/UART_1.c **** 
 117:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 118:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RX_ADDRESS_MODE);
 119:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RX_HW_ADDRESS1);
 120:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RX_HW_ADDRESS2);
 121:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 122:.\Generated_Source\PSoC4/UART_1.c **** 
 123:.\Generated_Source\PSoC4/UART_1.c ****         /* Init Count7 period */
 124:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
  81              		.loc 1 124 0
  82 0004 084B     		ldr	r3, .L6
  83 0006 7222     		mov	r2, #114
  84 0008 1A70     		strb	r2, [r3]
 125:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 126:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
  85              		.loc 1 126 0
  86 000a 084B     		ldr	r3, .L6+4
  87 000c 2022     		mov	r2, #32
  88 000e 1A70     		strb	r2, [r3]
 127:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 128:.\Generated_Source\PSoC4/UART_1.c **** 
 129:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 130:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 131:.\Generated_Source\PSoC4/UART_1.c ****             /* Set TX interrupt vector and priority */
 132:.\Generated_Source\PSoC4/UART_1.c ****             (void) CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 133:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 134:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 135:.\Generated_Source\PSoC4/UART_1.c **** 
 136:.\Generated_Source\PSoC4/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 137:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TXCLKGEN_DP)
 138:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
  89              		.loc 1 138 0
  90 0010 074B     		ldr	r3, .L6+8
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 5


  91 0012 0622     		mov	r2, #6
  92 0014 1A70     		strb	r2, [r3]
 139:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = ((UART_1_NUMBER_OF_DATA_BITS +
  93              		.loc 1 139 0
  94 0016 074B     		ldr	r3, .L6+12
  95 0018 4722     		mov	r2, #71
  96 001a 1A70     		strb	r2, [r3]
 140:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT) - 1u;
 141:.\Generated_Source\PSoC4/UART_1.c ****         #else
 142:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 143:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 144:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 145:.\Generated_Source\PSoC4/UART_1.c **** 
 146:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial TX interrupt mask */
 147:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 148:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 149:.\Generated_Source\PSoC4/UART_1.c ****         #else
 150:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
  97              		.loc 1 150 0
  98 001c 064B     		ldr	r3, .L6+16
  99 001e 0022     		mov	r2, #0
 100 0020 1A70     		strb	r2, [r3]
 151:.\Generated_Source\PSoC4/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 152:.\Generated_Source\PSoC4/UART_1.c **** 
 153:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 154:.\Generated_Source\PSoC4/UART_1.c **** 
 155:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 156:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_WriteControlRegister( \
 157:.\Generated_Source\PSoC4/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 158:.\Generated_Source\PSoC4/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 159:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 160:.\Generated_Source\PSoC4/UART_1.c **** }
 101              		.loc 1 160 0
 102 0022 BD46     		mov	sp, r7
 103              		@ sp needed
 104 0024 80BD     		pop	{r7, pc}
 105              	.L7:
 106 0026 C046     		.align	2
 107              	.L6:
 108 0028 82000F40 		.word	1074724994
 109 002c 83000F40 		.word	1074724995
 110 0030 21000F40 		.word	1074724897
 111 0034 31000F40 		.word	1074724913
 112 0038 80000F40 		.word	1074724992
 113              		.cfi_endproc
 114              	.LFE1:
 115              		.size	UART_1_Init, .-UART_1_Init
 116              		.section	.text.UART_1_Enable,"ax",%progbits
 117              		.align	2
 118              		.global	UART_1_Enable
 119              		.code	16
 120              		.thumb_func
 121              		.type	UART_1_Enable, %function
 122              	UART_1_Enable:
 123              	.LFB2:
 161:.\Generated_Source\PSoC4/UART_1.c **** 
 162:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 6


 163:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 164:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Enable
 165:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 166:.\Generated_Source\PSoC4/UART_1.c **** *
 167:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 168:.\Generated_Source\PSoC4/UART_1.c **** *  Activates the hardware and begins component operation. It is not necessary
 169:.\Generated_Source\PSoC4/UART_1.c **** *  to call UART_1_Enable() because the UART_1_Start() API
 170:.\Generated_Source\PSoC4/UART_1.c **** *  calls this function, which is the preferred method to begin component
 171:.\Generated_Source\PSoC4/UART_1.c **** *  operation.
 172:.\Generated_Source\PSoC4/UART_1.c **** 
 173:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 174:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 175:.\Generated_Source\PSoC4/UART_1.c **** *
 176:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 177:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 178:.\Generated_Source\PSoC4/UART_1.c **** *
 179:.\Generated_Source\PSoC4/UART_1.c **** * Global Variables:
 180:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 181:.\Generated_Source\PSoC4/UART_1.c **** *
 182:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 183:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Enable(void) 
 184:.\Generated_Source\PSoC4/UART_1.c **** {
 124              		.loc 1 184 0
 125              		.cfi_startproc
 126 0000 90B5     		push	{r4, r7, lr}
 127              		.cfi_def_cfa_offset 12
 128              		.cfi_offset 4, -12
 129              		.cfi_offset 7, -8
 130              		.cfi_offset 14, -4
 131 0002 83B0     		sub	sp, sp, #12
 132              		.cfi_def_cfa_offset 24
 133 0004 00AF     		add	r7, sp, #0
 134              		.cfi_def_cfa_register 7
 185:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 186:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 135              		.loc 1 186 0
 136 0006 FC1D     		add	r4, r7, #7
 137 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 138 000c 031C     		mov	r3, r0
 139 000e 2370     		strb	r3, [r4]
 187:.\Generated_Source\PSoC4/UART_1.c **** 
 188:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 189:.\Generated_Source\PSoC4/UART_1.c ****         /* RX Counter (Count7) Enable */
 190:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 140              		.loc 1 190 0
 141 0010 104B     		ldr	r3, .L9
 142 0012 104A     		ldr	r2, .L9
 143 0014 1278     		ldrb	r2, [r2]
 144 0016 D2B2     		uxtb	r2, r2
 145 0018 2021     		mov	r1, #32
 146 001a 0A43     		orr	r2, r1
 147 001c D2B2     		uxtb	r2, r2
 148 001e 1A70     		strb	r2, [r3]
 191:.\Generated_Source\PSoC4/UART_1.c **** 
 192:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the RX Interrupt */
 193:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 149              		.loc 1 193 0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 7


 150 0020 0D4B     		ldr	r3, .L9+4
 151 0022 0D4A     		ldr	r2, .L9+4
 152 0024 1278     		ldrb	r2, [r2]
 153 0026 D2B2     		uxtb	r2, r2
 154 0028 1021     		mov	r1, #16
 155 002a 0A43     		orr	r2, r1
 156 002c D2B2     		uxtb	r2, r2
 157 002e 1A70     		strb	r2, [r3]
 194:.\Generated_Source\PSoC4/UART_1.c **** 
 195:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 196:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableRxInt();
 197:.\Generated_Source\PSoC4/UART_1.c **** 
 198:.\Generated_Source\PSoC4/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
 199:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 200:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
 201:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 202:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 203:.\Generated_Source\PSoC4/UART_1.c **** 
 204:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 205:.\Generated_Source\PSoC4/UART_1.c ****         /* TX Counter (DP/Count7) Enable */
 206:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 207:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 208:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 209:.\Generated_Source\PSoC4/UART_1.c **** 
 210:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the TX Interrupt */
 211:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 158              		.loc 1 211 0
 159 0030 0A4B     		ldr	r3, .L9+8
 160 0032 0A4A     		ldr	r2, .L9+8
 161 0034 1278     		ldrb	r2, [r2]
 162 0036 D2B2     		uxtb	r2, r2
 163 0038 1021     		mov	r1, #16
 164 003a 0A43     		orr	r2, r1
 165 003c D2B2     		uxtb	r2, r2
 166 003e 1A70     		strb	r2, [r3]
 212:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 213:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
 215:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 216:.\Generated_Source\PSoC4/UART_1.c ****      #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 217:.\Generated_Source\PSoC4/UART_1.c **** 
 218:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 219:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Start();  /* Enable the clock */
 167              		.loc 1 219 0
 168 0040 FFF7FEFF 		bl	UART_1_IntClock_Start
 220:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 221:.\Generated_Source\PSoC4/UART_1.c **** 
 222:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 169              		.loc 1 222 0
 170 0044 FB1D     		add	r3, r7, #7
 171 0046 1B78     		ldrb	r3, [r3]
 172 0048 181C     		mov	r0, r3
 173 004a FFF7FEFF 		bl	CyExitCriticalSection
 223:.\Generated_Source\PSoC4/UART_1.c **** }
 174              		.loc 1 223 0
 175 004e BD46     		mov	sp, r7
 176 0050 03B0     		add	sp, sp, #12
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 8


 177              		@ sp needed
 178 0052 90BD     		pop	{r4, r7, pc}
 179              	.L10:
 180              		.align	2
 181              	.L9:
 182 0054 92000F40 		.word	1074725010
 183 0058 93000F40 		.word	1074725011
 184 005c 90000F40 		.word	1074725008
 185              		.cfi_endproc
 186              	.LFE2:
 187              		.size	UART_1_Enable, .-UART_1_Enable
 188              		.section	.text.UART_1_Stop,"ax",%progbits
 189              		.align	2
 190              		.global	UART_1_Stop
 191              		.code	16
 192              		.thumb_func
 193              		.type	UART_1_Stop, %function
 194              	UART_1_Stop:
 195              	.LFB3:
 224:.\Generated_Source\PSoC4/UART_1.c **** 
 225:.\Generated_Source\PSoC4/UART_1.c **** 
 226:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 227:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Stop
 228:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 229:.\Generated_Source\PSoC4/UART_1.c **** *
 230:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 231:.\Generated_Source\PSoC4/UART_1.c **** *  Disables the UART operation.
 232:.\Generated_Source\PSoC4/UART_1.c **** *
 233:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 234:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 235:.\Generated_Source\PSoC4/UART_1.c **** *
 236:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 237:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 238:.\Generated_Source\PSoC4/UART_1.c **** *
 239:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 240:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Stop(void) 
 241:.\Generated_Source\PSoC4/UART_1.c **** {
 196              		.loc 1 241 0
 197              		.cfi_startproc
 198 0000 90B5     		push	{r4, r7, lr}
 199              		.cfi_def_cfa_offset 12
 200              		.cfi_offset 4, -12
 201              		.cfi_offset 7, -8
 202              		.cfi_offset 14, -4
 203 0002 83B0     		sub	sp, sp, #12
 204              		.cfi_def_cfa_offset 24
 205 0004 00AF     		add	r7, sp, #0
 206              		.cfi_def_cfa_register 7
 242:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 243:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 207              		.loc 1 243 0
 208 0006 FC1D     		add	r4, r7, #7
 209 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 210 000c 031C     		mov	r3, r0
 211 000e 2370     		strb	r3, [r4]
 244:.\Generated_Source\PSoC4/UART_1.c **** 
 245:.\Generated_Source\PSoC4/UART_1.c ****     /* Write Bit Counter Disable */
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 9


 246:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 247:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 212              		.loc 1 247 0
 213 0010 104B     		ldr	r3, .L12
 214 0012 104A     		ldr	r2, .L12
 215 0014 1278     		ldrb	r2, [r2]
 216 0016 D2B2     		uxtb	r2, r2
 217 0018 2021     		mov	r1, #32
 218 001a 8A43     		bic	r2, r1
 219 001c D2B2     		uxtb	r2, r2
 220 001e 1A70     		strb	r2, [r3]
 248:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 249:.\Generated_Source\PSoC4/UART_1.c **** 
 250:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_ENABLED)
 251:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 252:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 253:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (!UART_1_TXCLKGEN_DP) */
 254:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 255:.\Generated_Source\PSoC4/UART_1.c **** 
 256:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 257:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Stop();   /* Disable the clock */
 221              		.loc 1 257 0
 222 0020 FFF7FEFF 		bl	UART_1_IntClock_Stop
 258:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 259:.\Generated_Source\PSoC4/UART_1.c **** 
 260:.\Generated_Source\PSoC4/UART_1.c ****     /* Disable internal interrupt component */
 261:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 262:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8) ~UART_1_INT_ENABLE;
 223              		.loc 1 262 0
 224 0024 0C4B     		ldr	r3, .L12+4
 225 0026 0C4A     		ldr	r2, .L12+4
 226 0028 1278     		ldrb	r2, [r2]
 227 002a D2B2     		uxtb	r2, r2
 228 002c 1021     		mov	r1, #16
 229 002e 8A43     		bic	r2, r1
 230 0030 D2B2     		uxtb	r2, r2
 231 0032 1A70     		strb	r2, [r3]
 263:.\Generated_Source\PSoC4/UART_1.c **** 
 264:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 265:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableRxInt();
 266:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 267:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 268:.\Generated_Source\PSoC4/UART_1.c **** 
 269:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_ENABLED)
 270:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8) ~UART_1_INT_ENABLE;
 232              		.loc 1 270 0
 233 0034 094B     		ldr	r3, .L12+8
 234 0036 094A     		ldr	r2, .L12+8
 235 0038 1278     		ldrb	r2, [r2]
 236 003a D2B2     		uxtb	r2, r2
 237 003c 1021     		mov	r1, #16
 238 003e 8A43     		bic	r2, r1
 239 0040 D2B2     		uxtb	r2, r2
 240 0042 1A70     		strb	r2, [r3]
 271:.\Generated_Source\PSoC4/UART_1.c **** 
 272:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 273:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 10


 274:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 275:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 276:.\Generated_Source\PSoC4/UART_1.c **** 
 277:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 241              		.loc 1 277 0
 242 0044 FB1D     		add	r3, r7, #7
 243 0046 1B78     		ldrb	r3, [r3]
 244 0048 181C     		mov	r0, r3
 245 004a FFF7FEFF 		bl	CyExitCriticalSection
 278:.\Generated_Source\PSoC4/UART_1.c **** }
 246              		.loc 1 278 0
 247 004e BD46     		mov	sp, r7
 248 0050 03B0     		add	sp, sp, #12
 249              		@ sp needed
 250 0052 90BD     		pop	{r4, r7, pc}
 251              	.L13:
 252              		.align	2
 253              	.L12:
 254 0054 92000F40 		.word	1074725010
 255 0058 93000F40 		.word	1074725011
 256 005c 90000F40 		.word	1074725008
 257              		.cfi_endproc
 258              	.LFE3:
 259              		.size	UART_1_Stop, .-UART_1_Stop
 260              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 261              		.align	2
 262              		.global	UART_1_ReadControlRegister
 263              		.code	16
 264              		.thumb_func
 265              		.type	UART_1_ReadControlRegister, %function
 266              	UART_1_ReadControlRegister:
 267              	.LFB4:
 279:.\Generated_Source\PSoC4/UART_1.c **** 
 280:.\Generated_Source\PSoC4/UART_1.c **** 
 281:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 282:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 283:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 284:.\Generated_Source\PSoC4/UART_1.c **** *
 285:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 286:.\Generated_Source\PSoC4/UART_1.c **** *  Returns the current value of the control register.
 287:.\Generated_Source\PSoC4/UART_1.c **** *
 288:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 289:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 290:.\Generated_Source\PSoC4/UART_1.c **** *
 291:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 292:.\Generated_Source\PSoC4/UART_1.c **** *  Contents of the control register.
 293:.\Generated_Source\PSoC4/UART_1.c **** *
 294:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 295:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 296:.\Generated_Source\PSoC4/UART_1.c **** {
 268              		.loc 1 296 0
 269              		.cfi_startproc
 270 0000 80B5     		push	{r7, lr}
 271              		.cfi_def_cfa_offset 8
 272              		.cfi_offset 7, -8
 273              		.cfi_offset 14, -4
 274 0002 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 11


 275              		.cfi_def_cfa_register 7
 297:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 298:.\Generated_Source\PSoC4/UART_1.c ****         return(0u);
 276              		.loc 1 298 0
 277 0004 0023     		mov	r3, #0
 299:.\Generated_Source\PSoC4/UART_1.c ****     #else
 300:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_CONTROL_REG);
 301:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 302:.\Generated_Source\PSoC4/UART_1.c **** }
 278              		.loc 1 302 0
 279 0006 181C     		mov	r0, r3
 280 0008 BD46     		mov	sp, r7
 281              		@ sp needed
 282 000a 80BD     		pop	{r7, pc}
 283              		.cfi_endproc
 284              	.LFE4:
 285              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 286              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
 287              		.align	2
 288              		.global	UART_1_WriteControlRegister
 289              		.code	16
 290              		.thumb_func
 291              		.type	UART_1_WriteControlRegister, %function
 292              	UART_1_WriteControlRegister:
 293              	.LFB5:
 303:.\Generated_Source\PSoC4/UART_1.c **** 
 304:.\Generated_Source\PSoC4/UART_1.c **** 
 305:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 306:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 307:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 308:.\Generated_Source\PSoC4/UART_1.c **** *
 309:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 310:.\Generated_Source\PSoC4/UART_1.c **** *  Writes an 8-bit value into the control register
 311:.\Generated_Source\PSoC4/UART_1.c **** *
 312:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 313:.\Generated_Source\PSoC4/UART_1.c **** *  control:  control register value
 314:.\Generated_Source\PSoC4/UART_1.c **** *
 315:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 316:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 317:.\Generated_Source\PSoC4/UART_1.c **** *
 318:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 319:.\Generated_Source\PSoC4/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 320:.\Generated_Source\PSoC4/UART_1.c **** {
 294              		.loc 1 320 0
 295              		.cfi_startproc
 296 0000 80B5     		push	{r7, lr}
 297              		.cfi_def_cfa_offset 8
 298              		.cfi_offset 7, -8
 299              		.cfi_offset 14, -4
 300 0002 82B0     		sub	sp, sp, #8
 301              		.cfi_def_cfa_offset 16
 302 0004 00AF     		add	r7, sp, #0
 303              		.cfi_def_cfa_register 7
 304 0006 021C     		mov	r2, r0
 305 0008 FB1D     		add	r3, r7, #7
 306 000a 1A70     		strb	r2, [r3]
 321:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 12


 322:.\Generated_Source\PSoC4/UART_1.c ****         if(0u != control)
 323:.\Generated_Source\PSoC4/UART_1.c ****         {
 324:.\Generated_Source\PSoC4/UART_1.c ****             /* Suppress compiler warning */
 325:.\Generated_Source\PSoC4/UART_1.c ****         }
 326:.\Generated_Source\PSoC4/UART_1.c ****     #else
 327:.\Generated_Source\PSoC4/UART_1.c ****        UART_1_CONTROL_REG = control;
 328:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 329:.\Generated_Source\PSoC4/UART_1.c **** }
 307              		.loc 1 329 0
 308 000c BD46     		mov	sp, r7
 309 000e 02B0     		add	sp, sp, #8
 310              		@ sp needed
 311 0010 80BD     		pop	{r7, pc}
 312              		.cfi_endproc
 313              	.LFE5:
 314              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 315 0012 C046     		.section	.text.UART_1_SetRxInterruptMode,"ax",%progbits
 316              		.align	2
 317              		.global	UART_1_SetRxInterruptMode
 318              		.code	16
 319              		.thumb_func
 320              		.type	UART_1_SetRxInterruptMode, %function
 321              	UART_1_SetRxInterruptMode:
 322              	.LFB6:
 330:.\Generated_Source\PSoC4/UART_1.c **** 
 331:.\Generated_Source\PSoC4/UART_1.c **** 
 332:.\Generated_Source\PSoC4/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 333:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 334:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 335:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 336:.\Generated_Source\PSoC4/UART_1.c ****     *
 337:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 338:.\Generated_Source\PSoC4/UART_1.c ****     *  Configures the RX interrupt sources enabled.
 339:.\Generated_Source\PSoC4/UART_1.c ****     *
 340:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 341:.\Generated_Source\PSoC4/UART_1.c ****     *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342:.\Generated_Source\PSoC4/UART_1.c ****     *  bit-field arrangement of the status register. This value must be a 
 343:.\Generated_Source\PSoC4/UART_1.c ****     *  combination of status register bit-masks shown below:
 344:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_PAR_ERROR        Interrupt on parity error.
 346:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_STOP_ERROR       Interrupt on stop error.
 347:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_BREAK            Interrupt on break.
 348:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_OVERRUN          Interrupt on overrun error.
 349:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_ADDR_MATCH       Interrupt on address match.
 350:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_MRKSPC           Interrupt on address detect.
 351:.\Generated_Source\PSoC4/UART_1.c ****     *
 352:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 353:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 354:.\Generated_Source\PSoC4/UART_1.c ****     *
 355:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 356:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 357:.\Generated_Source\PSoC4/UART_1.c ****     *
 358:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 359:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 360:.\Generated_Source\PSoC4/UART_1.c ****     {
 323              		.loc 1 360 0
 324              		.cfi_startproc
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 13


 325 0000 80B5     		push	{r7, lr}
 326              		.cfi_def_cfa_offset 8
 327              		.cfi_offset 7, -8
 328              		.cfi_offset 14, -4
 329 0002 82B0     		sub	sp, sp, #8
 330              		.cfi_def_cfa_offset 16
 331 0004 00AF     		add	r7, sp, #0
 332              		.cfi_def_cfa_register 7
 333 0006 021C     		mov	r2, r0
 334 0008 FB1D     		add	r3, r7, #7
 335 000a 1A70     		strb	r2, [r3]
 361:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 336              		.loc 1 361 0
 337 000c 034B     		ldr	r3, .L18
 338 000e FA1D     		add	r2, r7, #7
 339 0010 1278     		ldrb	r2, [r2]
 340 0012 1A70     		strb	r2, [r3]
 362:.\Generated_Source\PSoC4/UART_1.c ****     }
 341              		.loc 1 362 0
 342 0014 BD46     		mov	sp, r7
 343 0016 02B0     		add	sp, sp, #8
 344              		@ sp needed
 345 0018 80BD     		pop	{r7, pc}
 346              	.L19:
 347 001a C046     		.align	2
 348              	.L18:
 349 001c 83000F40 		.word	1074724995
 350              		.cfi_endproc
 351              	.LFE6:
 352              		.size	UART_1_SetRxInterruptMode, .-UART_1_SetRxInterruptMode
 353              		.section	.text.UART_1_ReadRxData,"ax",%progbits
 354              		.align	2
 355              		.global	UART_1_ReadRxData
 356              		.code	16
 357              		.thumb_func
 358              		.type	UART_1_ReadRxData, %function
 359              	UART_1_ReadRxData:
 360              	.LFB7:
 363:.\Generated_Source\PSoC4/UART_1.c **** 
 364:.\Generated_Source\PSoC4/UART_1.c **** 
 365:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 366:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxData
 367:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 368:.\Generated_Source\PSoC4/UART_1.c ****     *
 369:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 370:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the next byte of received data. This function returns data without
 371:.\Generated_Source\PSoC4/UART_1.c ****     *  checking the status. You must check the status separately.
 372:.\Generated_Source\PSoC4/UART_1.c ****     *
 373:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 374:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 375:.\Generated_Source\PSoC4/UART_1.c ****     *
 376:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 377:.\Generated_Source\PSoC4/UART_1.c ****     *  Received data from RX register
 378:.\Generated_Source\PSoC4/UART_1.c ****     *
 379:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 380:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 381:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 14


 382:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 383:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 384:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 385:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 386:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 387:.\Generated_Source\PSoC4/UART_1.c ****     *
 388:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 389:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 390:.\Generated_Source\PSoC4/UART_1.c ****     *
 391:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 392:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 393:.\Generated_Source\PSoC4/UART_1.c ****     {
 361              		.loc 1 393 0
 362              		.cfi_startproc
 363 0000 80B5     		push	{r7, lr}
 364              		.cfi_def_cfa_offset 8
 365              		.cfi_offset 7, -8
 366              		.cfi_offset 14, -4
 367 0002 82B0     		sub	sp, sp, #8
 368              		.cfi_def_cfa_offset 16
 369 0004 00AF     		add	r7, sp, #0
 370              		.cfi_def_cfa_register 7
 394:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData;
 395:.\Generated_Source\PSoC4/UART_1.c **** 
 396:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 397:.\Generated_Source\PSoC4/UART_1.c **** 
 398:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferRead;
 399:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferWrite;
 400:.\Generated_Source\PSoC4/UART_1.c **** 
 401:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 402:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 403:.\Generated_Source\PSoC4/UART_1.c **** 
 404:.\Generated_Source\PSoC4/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 405:.\Generated_Source\PSoC4/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 406:.\Generated_Source\PSoC4/UART_1.c **** 
 407:.\Generated_Source\PSoC4/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 408:.\Generated_Source\PSoC4/UART_1.c ****         {
 409:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 410:.\Generated_Source\PSoC4/UART_1.c ****             locRxBufferRead++;
 411:.\Generated_Source\PSoC4/UART_1.c **** 
 412:.\Generated_Source\PSoC4/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 413:.\Generated_Source\PSoC4/UART_1.c ****             {
 414:.\Generated_Source\PSoC4/UART_1.c ****                 locRxBufferRead = 0u;
 415:.\Generated_Source\PSoC4/UART_1.c ****             }
 416:.\Generated_Source\PSoC4/UART_1.c ****             /* Update the real pointer */
 417:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 418:.\Generated_Source\PSoC4/UART_1.c **** 
 419:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 420:.\Generated_Source\PSoC4/UART_1.c ****             {
 421:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 422:.\Generated_Source\PSoC4/UART_1.c ****                 #if ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u))
 423:.\Generated_Source\PSoC4/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 424:.\Generated_Source\PSoC4/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 425:.\Generated_Source\PSoC4/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 426:.\Generated_Source\PSoC4/UART_1.c ****                         {   /* In Half duplex mode return RX mask only in RX
 427:.\Generated_Source\PSoC4/UART_1.c ****                             *  configuration set, otherwise
 428:.\Generated_Source\PSoC4/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 15


 429:.\Generated_Source\PSoC4/UART_1.c ****                             */
 430:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 431:.\Generated_Source\PSoC4/UART_1.c ****                         }
 432:.\Generated_Source\PSoC4/UART_1.c ****                     #else
 433:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 434:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 435:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u)) */
 436:.\Generated_Source\PSoC4/UART_1.c ****             }
 437:.\Generated_Source\PSoC4/UART_1.c ****         }
 438:.\Generated_Source\PSoC4/UART_1.c ****         else
 439:.\Generated_Source\PSoC4/UART_1.c ****         {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 441:.\Generated_Source\PSoC4/UART_1.c ****         }
 442:.\Generated_Source\PSoC4/UART_1.c **** 
 443:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 444:.\Generated_Source\PSoC4/UART_1.c **** 
 445:.\Generated_Source\PSoC4/UART_1.c ****     #else
 446:.\Generated_Source\PSoC4/UART_1.c **** 
 447:.\Generated_Source\PSoC4/UART_1.c ****         /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448:.\Generated_Source\PSoC4/UART_1.c ****         rxData = UART_1_RXDATA_REG;
 371              		.loc 1 448 0
 372 0006 054A     		ldr	r2, .L22
 373 0008 FB1D     		add	r3, r7, #7
 374 000a 1278     		ldrb	r2, [r2]
 375 000c 1A70     		strb	r2, [r3]
 449:.\Generated_Source\PSoC4/UART_1.c **** 
 450:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 451:.\Generated_Source\PSoC4/UART_1.c **** 
 452:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 376              		.loc 1 452 0
 377 000e FB1D     		add	r3, r7, #7
 378 0010 1B78     		ldrb	r3, [r3]
 453:.\Generated_Source\PSoC4/UART_1.c ****     }
 379              		.loc 1 453 0
 380 0012 181C     		mov	r0, r3
 381 0014 BD46     		mov	sp, r7
 382 0016 02B0     		add	sp, sp, #8
 383              		@ sp needed
 384 0018 80BD     		pop	{r7, pc}
 385              	.L23:
 386 001a C046     		.align	2
 387              	.L22:
 388 001c 42000F40 		.word	1074724930
 389              		.cfi_endproc
 390              	.LFE7:
 391              		.size	UART_1_ReadRxData, .-UART_1_ReadRxData
 392              		.section	.text.UART_1_ReadRxStatus,"ax",%progbits
 393              		.align	2
 394              		.global	UART_1_ReadRxStatus
 395              		.code	16
 396              		.thumb_func
 397              		.type	UART_1_ReadRxStatus, %function
 398              	UART_1_ReadRxStatus:
 399              	.LFB8:
 454:.\Generated_Source\PSoC4/UART_1.c **** 
 455:.\Generated_Source\PSoC4/UART_1.c **** 
 456:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 16


 457:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 458:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 459:.\Generated_Source\PSoC4/UART_1.c ****     *
 460:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 461:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the current state of the receiver status register and the software
 462:.\Generated_Source\PSoC4/UART_1.c ****     *  buffer overflow status.
 463:.\Generated_Source\PSoC4/UART_1.c ****     *
 464:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 465:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 466:.\Generated_Source\PSoC4/UART_1.c ****     *
 467:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 468:.\Generated_Source\PSoC4/UART_1.c ****     *  Current state of the status register.
 469:.\Generated_Source\PSoC4/UART_1.c ****     *
 470:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effect:
 471:.\Generated_Source\PSoC4/UART_1.c ****     *  All status register bits are clear-on-read except
 472:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY.
 473:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474:.\Generated_Source\PSoC4/UART_1.c ****     *  register read.
 475:.\Generated_Source\PSoC4/UART_1.c ****     *
 476:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 477:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 478:.\Generated_Source\PSoC4/UART_1.c ****     *   It set to one in RX interrupt when there isn't free space in
 479:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 480:.\Generated_Source\PSoC4/UART_1.c ****     *   and cleared to zero by this API as an
 481:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482:.\Generated_Source\PSoC4/UART_1.c ****     *   bits.
 483:.\Generated_Source\PSoC4/UART_1.c ****     *
 484:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 485:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 486:.\Generated_Source\PSoC4/UART_1.c ****     {
 400              		.loc 1 486 0
 401              		.cfi_startproc
 402 0000 80B5     		push	{r7, lr}
 403              		.cfi_def_cfa_offset 8
 404              		.cfi_offset 7, -8
 405              		.cfi_offset 14, -4
 406 0002 82B0     		sub	sp, sp, #8
 407              		.cfi_def_cfa_offset 16
 408 0004 00AF     		add	r7, sp, #0
 409              		.cfi_def_cfa_register 7
 487:.\Generated_Source\PSoC4/UART_1.c ****         uint8 status;
 488:.\Generated_Source\PSoC4/UART_1.c **** 
 489:.\Generated_Source\PSoC4/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 410              		.loc 1 489 0
 411 0006 064B     		ldr	r3, .L26
 412 0008 1B78     		ldrb	r3, [r3]
 413 000a D9B2     		uxtb	r1, r3
 414 000c FB1D     		add	r3, r7, #7
 415 000e 7F22     		mov	r2, #127
 416 0010 0A40     		and	r2, r1
 417 0012 1A70     		strb	r2, [r3]
 490:.\Generated_Source\PSoC4/UART_1.c **** 
 491:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 492:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_rxBufferOverflow != 0u)
 493:.\Generated_Source\PSoC4/UART_1.c ****         {
 494:.\Generated_Source\PSoC4/UART_1.c ****             status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 495:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 17


 496:.\Generated_Source\PSoC4/UART_1.c ****         }
 497:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 498:.\Generated_Source\PSoC4/UART_1.c **** 
 499:.\Generated_Source\PSoC4/UART_1.c ****         return(status);
 418              		.loc 1 499 0
 419 0014 FB1D     		add	r3, r7, #7
 420 0016 1B78     		ldrb	r3, [r3]
 500:.\Generated_Source\PSoC4/UART_1.c ****     }
 421              		.loc 1 500 0
 422 0018 181C     		mov	r0, r3
 423 001a BD46     		mov	sp, r7
 424 001c 02B0     		add	sp, sp, #8
 425              		@ sp needed
 426 001e 80BD     		pop	{r7, pc}
 427              	.L27:
 428              		.align	2
 429              	.L26:
 430 0020 63000F40 		.word	1074724963
 431              		.cfi_endproc
 432              	.LFE8:
 433              		.size	UART_1_ReadRxStatus, .-UART_1_ReadRxStatus
 434              		.section	.text.UART_1_GetChar,"ax",%progbits
 435              		.align	2
 436              		.global	UART_1_GetChar
 437              		.code	16
 438              		.thumb_func
 439              		.type	UART_1_GetChar, %function
 440              	UART_1_GetChar:
 441              	.LFB9:
 501:.\Generated_Source\PSoC4/UART_1.c **** 
 502:.\Generated_Source\PSoC4/UART_1.c **** 
 503:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 504:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetChar
 505:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 506:.\Generated_Source\PSoC4/UART_1.c ****     *
 507:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 508:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the last received byte of data. UART_1_GetChar() is
 509:.\Generated_Source\PSoC4/UART_1.c ****     *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510:.\Generated_Source\PSoC4/UART_1.c ****     *  for valid characters and 0 indicates an error occurred or no data is present.
 511:.\Generated_Source\PSoC4/UART_1.c ****     *
 512:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 513:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 514:.\Generated_Source\PSoC4/UART_1.c ****     *
 515:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 516:.\Generated_Source\PSoC4/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517:.\Generated_Source\PSoC4/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 518:.\Generated_Source\PSoC4/UART_1.c ****     *
 519:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 520:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 521:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 522:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 523:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 524:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 525:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 526:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 527:.\Generated_Source\PSoC4/UART_1.c ****     *
 528:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 18


 529:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 530:.\Generated_Source\PSoC4/UART_1.c ****     *
 531:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 532:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetChar(void) 
 533:.\Generated_Source\PSoC4/UART_1.c ****     {
 442              		.loc 1 533 0
 443              		.cfi_startproc
 444 0000 80B5     		push	{r7, lr}
 445              		.cfi_def_cfa_offset 8
 446              		.cfi_offset 7, -8
 447              		.cfi_offset 14, -4
 448 0002 82B0     		sub	sp, sp, #8
 449              		.cfi_def_cfa_offset 16
 450 0004 00AF     		add	r7, sp, #0
 451              		.cfi_def_cfa_register 7
 534:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData = 0u;
 452              		.loc 1 534 0
 453 0006 FB1D     		add	r3, r7, #7
 454 0008 0022     		mov	r2, #0
 455 000a 1A70     		strb	r2, [r3]
 535:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxStatus;
 536:.\Generated_Source\PSoC4/UART_1.c **** 
 537:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 538:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferRead;
 539:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferWrite;
 540:.\Generated_Source\PSoC4/UART_1.c **** 
 541:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 542:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 543:.\Generated_Source\PSoC4/UART_1.c **** 
 544:.\Generated_Source\PSoC4/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 545:.\Generated_Source\PSoC4/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 546:.\Generated_Source\PSoC4/UART_1.c **** 
 547:.\Generated_Source\PSoC4/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548:.\Generated_Source\PSoC4/UART_1.c ****         {
 549:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 550:.\Generated_Source\PSoC4/UART_1.c ****             locRxBufferRead++;
 551:.\Generated_Source\PSoC4/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 552:.\Generated_Source\PSoC4/UART_1.c ****             {
 553:.\Generated_Source\PSoC4/UART_1.c ****                 locRxBufferRead = 0u;
 554:.\Generated_Source\PSoC4/UART_1.c ****             }
 555:.\Generated_Source\PSoC4/UART_1.c ****             /* Update the real pointer */
 556:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 557:.\Generated_Source\PSoC4/UART_1.c **** 
 558:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 559:.\Generated_Source\PSoC4/UART_1.c ****             {
 560:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 561:.\Generated_Source\PSoC4/UART_1.c ****                 #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 562:.\Generated_Source\PSoC4/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 563:.\Generated_Source\PSoC4/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 564:.\Generated_Source\PSoC4/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 565:.\Generated_Source\PSoC4/UART_1.c ****                         {   /* In Half duplex mode return RX mask only if
 566:.\Generated_Source\PSoC4/UART_1.c ****                             *  RX configuration set, otherwise
 567:.\Generated_Source\PSoC4/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 568:.\Generated_Source\PSoC4/UART_1.c ****                             */
 569:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 570:.\Generated_Source\PSoC4/UART_1.c ****                         }
 571:.\Generated_Source\PSoC4/UART_1.c ****                     #else
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 19


 572:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 573:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 574:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575:.\Generated_Source\PSoC4/UART_1.c ****             }
 576:.\Generated_Source\PSoC4/UART_1.c **** 
 577:.\Generated_Source\PSoC4/UART_1.c ****         }
 578:.\Generated_Source\PSoC4/UART_1.c ****         else
 579:.\Generated_Source\PSoC4/UART_1.c ****         {   rxStatus = UART_1_RXSTATUS_REG;
 580:.\Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 581:.\Generated_Source\PSoC4/UART_1.c ****             {   /* Read received data from FIFO */
 582:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 583:.\Generated_Source\PSoC4/UART_1.c ****                 /*Check status on error*/
 584:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 585:.\Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 586:.\Generated_Source\PSoC4/UART_1.c ****                 {
 587:.\Generated_Source\PSoC4/UART_1.c ****                     rxData = 0u;
 588:.\Generated_Source\PSoC4/UART_1.c ****                 }
 589:.\Generated_Source\PSoC4/UART_1.c ****             }
 590:.\Generated_Source\PSoC4/UART_1.c ****         }
 591:.\Generated_Source\PSoC4/UART_1.c **** 
 592:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 593:.\Generated_Source\PSoC4/UART_1.c **** 
 594:.\Generated_Source\PSoC4/UART_1.c ****     #else
 595:.\Generated_Source\PSoC4/UART_1.c **** 
 596:.\Generated_Source\PSoC4/UART_1.c ****         rxStatus =UART_1_RXSTATUS_REG;
 456              		.loc 1 596 0
 457 000c 0D4A     		ldr	r2, .L31
 458 000e BB1D     		add	r3, r7, #6
 459 0010 1278     		ldrb	r2, [r2]
 460 0012 1A70     		strb	r2, [r3]
 597:.\Generated_Source\PSoC4/UART_1.c ****         if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 461              		.loc 1 597 0
 462 0014 BB1D     		add	r3, r7, #6
 463 0016 1A78     		ldrb	r2, [r3]
 464 0018 2023     		mov	r3, #32
 465 001a 1340     		and	r3, r2
 466 001c 0BD0     		beq	.L29
 598:.\Generated_Source\PSoC4/UART_1.c ****         {
 599:.\Generated_Source\PSoC4/UART_1.c ****             /* Read received data from FIFO */
 600:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 467              		.loc 1 600 0
 468 001e 0A4A     		ldr	r2, .L31+4
 469 0020 FB1D     		add	r3, r7, #7
 470 0022 1278     		ldrb	r2, [r2]
 471 0024 1A70     		strb	r2, [r3]
 601:.\Generated_Source\PSoC4/UART_1.c **** 
 602:.\Generated_Source\PSoC4/UART_1.c ****             /*Check status on error*/
 603:.\Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 604:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 472              		.loc 1 604 0
 473 0026 BB1D     		add	r3, r7, #6
 474 0028 1A78     		ldrb	r2, [r3]
 475 002a 1E23     		mov	r3, #30
 476 002c 1340     		and	r3, r2
 603:.\Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 477              		.loc 1 603 0
 478 002e 02D0     		beq	.L29
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 20


 605:.\Generated_Source\PSoC4/UART_1.c ****             {
 606:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = 0u;
 479              		.loc 1 606 0
 480 0030 FB1D     		add	r3, r7, #7
 481 0032 0022     		mov	r2, #0
 482 0034 1A70     		strb	r2, [r3]
 483              	.L29:
 607:.\Generated_Source\PSoC4/UART_1.c ****             }
 608:.\Generated_Source\PSoC4/UART_1.c ****         }
 609:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 610:.\Generated_Source\PSoC4/UART_1.c **** 
 611:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 484              		.loc 1 611 0
 485 0036 FB1D     		add	r3, r7, #7
 486 0038 1B78     		ldrb	r3, [r3]
 612:.\Generated_Source\PSoC4/UART_1.c ****     }
 487              		.loc 1 612 0
 488 003a 181C     		mov	r0, r3
 489 003c BD46     		mov	sp, r7
 490 003e 02B0     		add	sp, sp, #8
 491              		@ sp needed
 492 0040 80BD     		pop	{r7, pc}
 493              	.L32:
 494 0042 C046     		.align	2
 495              	.L31:
 496 0044 63000F40 		.word	1074724963
 497 0048 42000F40 		.word	1074724930
 498              		.cfi_endproc
 499              	.LFE9:
 500              		.size	UART_1_GetChar, .-UART_1_GetChar
 501              		.section	.text.UART_1_GetByte,"ax",%progbits
 502              		.align	2
 503              		.global	UART_1_GetByte
 504              		.code	16
 505              		.thumb_func
 506              		.type	UART_1_GetByte, %function
 507              	UART_1_GetByte:
 508              	.LFB10:
 613:.\Generated_Source\PSoC4/UART_1.c **** 
 614:.\Generated_Source\PSoC4/UART_1.c **** 
 615:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 616:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetByte
 617:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 618:.\Generated_Source\PSoC4/UART_1.c ****     *
 619:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 620:.\Generated_Source\PSoC4/UART_1.c ****     *  Reads UART RX buffer immediately, returns received character and error
 621:.\Generated_Source\PSoC4/UART_1.c ****     *  condition.
 622:.\Generated_Source\PSoC4/UART_1.c ****     *
 623:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 624:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 625:.\Generated_Source\PSoC4/UART_1.c ****     *
 626:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 627:.\Generated_Source\PSoC4/UART_1.c ****     *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628:.\Generated_Source\PSoC4/UART_1.c ****     *  an error has occurred.
 629:.\Generated_Source\PSoC4/UART_1.c ****     *
 630:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 631:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 21


 632:.\Generated_Source\PSoC4/UART_1.c ****     *
 633:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 634:.\Generated_Source\PSoC4/UART_1.c ****     uint16 UART_1_GetByte(void) 
 635:.\Generated_Source\PSoC4/UART_1.c ****     {
 509              		.loc 1 635 0
 510              		.cfi_startproc
 511 0000 98B5     		push	{r3, r4, r7, lr}
 512              		.cfi_def_cfa_offset 16
 513              		.cfi_offset 3, -16
 514              		.cfi_offset 4, -12
 515              		.cfi_offset 7, -8
 516              		.cfi_offset 14, -4
 517 0002 00AF     		add	r7, sp, #0
 518              		.cfi_def_cfa_register 7
 636:.\Generated_Source\PSoC4/UART_1.c ****         
 637:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 638:.\Generated_Source\PSoC4/UART_1.c ****         uint16 locErrorStatus;
 639:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 640:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 641:.\Generated_Source\PSoC4/UART_1.c ****         locErrorStatus = (uint16)UART_1_errorStatus;
 642:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_errorStatus = 0u;
 643:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 644:.\Generated_Source\PSoC4/UART_1.c ****         return ( (uint16)(locErrorStatus << 8u) | UART_1_ReadRxData() );
 645:.\Generated_Source\PSoC4/UART_1.c ****     #else
 646:.\Generated_Source\PSoC4/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 519              		.loc 1 646 0
 520 0004 FFF7FEFF 		bl	UART_1_ReadRxStatus
 521 0008 031C     		mov	r3, r0
 522 000a 1B02     		lsl	r3, r3, #8
 523 000c 9CB2     		uxth	r4, r3
 524 000e FFF7FEFF 		bl	UART_1_ReadRxData
 525 0012 031C     		mov	r3, r0
 526 0014 221C     		add	r2, r4, #0
 527 0016 1343     		orr	r3, r2
 528 0018 9BB2     		uxth	r3, r3
 529 001a 9BB2     		uxth	r3, r3
 647:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 648:.\Generated_Source\PSoC4/UART_1.c ****         
 649:.\Generated_Source\PSoC4/UART_1.c ****     }
 530              		.loc 1 649 0
 531 001c 181C     		mov	r0, r3
 532 001e BD46     		mov	sp, r7
 533              		@ sp needed
 534 0020 98BD     		pop	{r3, r4, r7, pc}
 535              		.cfi_endproc
 536              	.LFE10:
 537              		.size	UART_1_GetByte, .-UART_1_GetByte
 538 0022 C046     		.section	.text.UART_1_GetRxBufferSize,"ax",%progbits
 539              		.align	2
 540              		.global	UART_1_GetRxBufferSize
 541              		.code	16
 542              		.thumb_func
 543              		.type	UART_1_GetRxBufferSize, %function
 544              	UART_1_GetRxBufferSize:
 545              	.LFB11:
 650:.\Generated_Source\PSoC4/UART_1.c **** 
 651:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 22


 652:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 653:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 654:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 655:.\Generated_Source\PSoC4/UART_1.c ****     *
 656:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 657:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the number of received bytes available in the RX buffer.
 658:.\Generated_Source\PSoC4/UART_1.c ****     *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659:.\Generated_Source\PSoC4/UART_1.c ****     *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660:.\Generated_Source\PSoC4/UART_1.c ****     *  * RX software buffer is enabled: returns the number of bytes available in 
 661:.\Generated_Source\PSoC4/UART_1.c ****     *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662:.\Generated_Source\PSoC4/UART_1.c ****     *    account.
 663:.\Generated_Source\PSoC4/UART_1.c ****     *
 664:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 665:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 666:.\Generated_Source\PSoC4/UART_1.c ****     *
 667:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 668:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8: Number of bytes in the RX buffer. 
 669:.\Generated_Source\PSoC4/UART_1.c ****     *    Return value type depends on RX Buffer Size parameter.
 670:.\Generated_Source\PSoC4/UART_1.c ****     *
 671:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 672:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 673:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 674:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 675:.\Generated_Source\PSoC4/UART_1.c ****     *
 676:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 677:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 678:.\Generated_Source\PSoC4/UART_1.c ****     *
 679:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 680:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 681:.\Generated_Source\PSoC4/UART_1.c ****     *
 682:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 683:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 684:.\Generated_Source\PSoC4/UART_1.c ****                                                             
 685:.\Generated_Source\PSoC4/UART_1.c ****     {
 546              		.loc 1 685 0
 547              		.cfi_startproc
 548 0000 80B5     		push	{r7, lr}
 549              		.cfi_def_cfa_offset 8
 550              		.cfi_offset 7, -8
 551              		.cfi_offset 14, -4
 552 0002 82B0     		sub	sp, sp, #8
 553              		.cfi_def_cfa_offset 16
 554 0004 00AF     		add	r7, sp, #0
 555              		.cfi_def_cfa_register 7
 686:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
 687:.\Generated_Source\PSoC4/UART_1.c **** 
 688:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 689:.\Generated_Source\PSoC4/UART_1.c **** 
 690:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 691:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 692:.\Generated_Source\PSoC4/UART_1.c **** 
 693:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 694:.\Generated_Source\PSoC4/UART_1.c ****         {
 695:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 696:.\Generated_Source\PSoC4/UART_1.c ****             {
 697:.\Generated_Source\PSoC4/UART_1.c ****                 size = UART_1_RX_BUFFER_SIZE;
 698:.\Generated_Source\PSoC4/UART_1.c ****             }
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 23


 699:.\Generated_Source\PSoC4/UART_1.c ****             else
 700:.\Generated_Source\PSoC4/UART_1.c ****             {
 701:.\Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
 702:.\Generated_Source\PSoC4/UART_1.c ****             }
 703:.\Generated_Source\PSoC4/UART_1.c ****         }
 704:.\Generated_Source\PSoC4/UART_1.c ****         else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 705:.\Generated_Source\PSoC4/UART_1.c ****         {
 706:.\Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 707:.\Generated_Source\PSoC4/UART_1.c ****         }
 708:.\Generated_Source\PSoC4/UART_1.c ****         else
 709:.\Generated_Source\PSoC4/UART_1.c ****         {
 710:.\Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_RX_BUFFER_SIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 711:.\Generated_Source\PSoC4/UART_1.c ****         }
 712:.\Generated_Source\PSoC4/UART_1.c **** 
 713:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 714:.\Generated_Source\PSoC4/UART_1.c **** 
 715:.\Generated_Source\PSoC4/UART_1.c ****     #else
 716:.\Generated_Source\PSoC4/UART_1.c **** 
 717:.\Generated_Source\PSoC4/UART_1.c ****         /* We can only know if there is data in the fifo. */
 718:.\Generated_Source\PSoC4/UART_1.c ****         size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 556              		.loc 1 718 0
 557 0006 094B     		ldr	r3, .L39
 558 0008 1B78     		ldrb	r3, [r3]
 559 000a DBB2     		uxtb	r3, r3
 560 000c 1A1C     		mov	r2, r3
 561 000e 2023     		mov	r3, #32
 562 0010 1340     		and	r3, r2
 563 0012 01D0     		beq	.L36
 564              		.loc 1 718 0 is_stmt 0 discriminator 1
 565 0014 0123     		mov	r3, #1
 566 0016 00E0     		b	.L37
 567              	.L36:
 568              		.loc 1 718 0 discriminator 2
 569 0018 0023     		mov	r3, #0
 570              	.L37:
 571              		.loc 1 718 0 discriminator 3
 572 001a FA1D     		add	r2, r7, #7
 573 001c 1370     		strb	r3, [r2]
 719:.\Generated_Source\PSoC4/UART_1.c **** 
 720:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 721:.\Generated_Source\PSoC4/UART_1.c **** 
 722:.\Generated_Source\PSoC4/UART_1.c ****         return(size);
 574              		.loc 1 722 0 is_stmt 1 discriminator 3
 575 001e FB1D     		add	r3, r7, #7
 576 0020 1B78     		ldrb	r3, [r3]
 723:.\Generated_Source\PSoC4/UART_1.c ****     }
 577              		.loc 1 723 0 discriminator 3
 578 0022 181C     		mov	r0, r3
 579 0024 BD46     		mov	sp, r7
 580 0026 02B0     		add	sp, sp, #8
 581              		@ sp needed
 582 0028 80BD     		pop	{r7, pc}
 583              	.L40:
 584 002a C046     		.align	2
 585              	.L39:
 586 002c 63000F40 		.word	1074724963
 587              		.cfi_endproc
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 24


 588              	.LFE11:
 589              		.size	UART_1_GetRxBufferSize, .-UART_1_GetRxBufferSize
 590              		.section	.text.UART_1_ClearRxBuffer,"ax",%progbits
 591              		.align	2
 592              		.global	UART_1_ClearRxBuffer
 593              		.code	16
 594              		.thumb_func
 595              		.type	UART_1_ClearRxBuffer, %function
 596              	UART_1_ClearRxBuffer:
 597              	.LFB12:
 724:.\Generated_Source\PSoC4/UART_1.c **** 
 725:.\Generated_Source\PSoC4/UART_1.c **** 
 726:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 727:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 728:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 729:.\Generated_Source\PSoC4/UART_1.c ****     *
 730:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 731:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732:.\Generated_Source\PSoC4/UART_1.c ****     *
 733:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 734:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 735:.\Generated_Source\PSoC4/UART_1.c ****     *
 736:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 737:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 738:.\Generated_Source\PSoC4/UART_1.c ****     *
 739:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 740:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 741:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 742:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 743:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 744:.\Generated_Source\PSoC4/UART_1.c ****     *
 745:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 746:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 747:.\Generated_Source\PSoC4/UART_1.c ****     *
 748:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 749:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 750:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 751:.\Generated_Source\PSoC4/UART_1.c ****     *  have remained in the RAM.
 752:.\Generated_Source\PSoC4/UART_1.c ****     *
 753:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
 754:.\Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 755:.\Generated_Source\PSoC4/UART_1.c ****     *
 756:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 757:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
 758:.\Generated_Source\PSoC4/UART_1.c ****     {
 598              		.loc 1 758 0
 599              		.cfi_startproc
 600 0000 90B5     		push	{r4, r7, lr}
 601              		.cfi_def_cfa_offset 12
 602              		.cfi_offset 4, -12
 603              		.cfi_offset 7, -8
 604              		.cfi_offset 14, -4
 605 0002 83B0     		sub	sp, sp, #12
 606              		.cfi_def_cfa_offset 24
 607 0004 00AF     		add	r7, sp, #0
 608              		.cfi_def_cfa_register 7
 759:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 25


 760:.\Generated_Source\PSoC4/UART_1.c **** 
 761:.\Generated_Source\PSoC4/UART_1.c ****         /* Clear the HW FIFO */
 762:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 609              		.loc 1 762 0
 610 0006 FC1D     		add	r4, r7, #7
 611 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 612 000c 031C     		mov	r3, r0
 613 000e 2370     		strb	r3, [r4]
 763:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |= (uint8)  UART_1_RX_FIFO_CLR;
 614              		.loc 1 763 0
 615 0010 0B4B     		ldr	r3, .L42
 616 0012 0B4A     		ldr	r2, .L42
 617 0014 1278     		ldrb	r2, [r2]
 618 0016 D2B2     		uxtb	r2, r2
 619 0018 0121     		mov	r1, #1
 620 001a 0A43     		orr	r2, r1
 621 001c D2B2     		uxtb	r2, r2
 622 001e 1A70     		strb	r2, [r3]
 764:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8) ~UART_1_RX_FIFO_CLR;
 623              		.loc 1 764 0
 624 0020 074B     		ldr	r3, .L42
 625 0022 074A     		ldr	r2, .L42
 626 0024 1278     		ldrb	r2, [r2]
 627 0026 D2B2     		uxtb	r2, r2
 628 0028 0121     		mov	r1, #1
 629 002a 8A43     		bic	r2, r1
 630 002c D2B2     		uxtb	r2, r2
 631 002e 1A70     		strb	r2, [r3]
 765:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 632              		.loc 1 765 0
 633 0030 FB1D     		add	r3, r7, #7
 634 0032 1B78     		ldrb	r3, [r3]
 635 0034 181C     		mov	r0, r3
 636 0036 FFF7FEFF 		bl	CyExitCriticalSection
 766:.\Generated_Source\PSoC4/UART_1.c **** 
 767:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 768:.\Generated_Source\PSoC4/UART_1.c **** 
 769:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
 770:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 771:.\Generated_Source\PSoC4/UART_1.c **** 
 772:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferRead = 0u;
 773:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferWrite = 0u;
 774:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferLoopDetect = 0u;
 775:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferOverflow = 0u;
 776:.\Generated_Source\PSoC4/UART_1.c **** 
 777:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 778:.\Generated_Source\PSoC4/UART_1.c **** 
 779:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 780:.\Generated_Source\PSoC4/UART_1.c **** 
 781:.\Generated_Source\PSoC4/UART_1.c ****     }
 637              		.loc 1 781 0
 638 003a BD46     		mov	sp, r7
 639 003c 03B0     		add	sp, sp, #12
 640              		@ sp needed
 641 003e 90BD     		pop	{r4, r7, pc}
 642              	.L43:
 643              		.align	2
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 26


 644              	.L42:
 645 0040 92000F40 		.word	1074725010
 646              		.cfi_endproc
 647              	.LFE12:
 648              		.size	UART_1_ClearRxBuffer, .-UART_1_ClearRxBuffer
 649              		.section	.text.UART_1_SetRxAddressMode,"ax",%progbits
 650              		.align	2
 651              		.global	UART_1_SetRxAddressMode
 652              		.code	16
 653              		.thumb_func
 654              		.type	UART_1_SetRxAddressMode, %function
 655              	UART_1_SetRxAddressMode:
 656              	.LFB13:
 782:.\Generated_Source\PSoC4/UART_1.c **** 
 783:.\Generated_Source\PSoC4/UART_1.c **** 
 784:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 785:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 786:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 787:.\Generated_Source\PSoC4/UART_1.c ****     *
 788:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 789:.\Generated_Source\PSoC4/UART_1.c ****     *  Sets the software controlled Addressing mode used by the RX portion of the
 790:.\Generated_Source\PSoC4/UART_1.c ****     *  UART.
 791:.\Generated_Source\PSoC4/UART_1.c ****     *
 792:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 793:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 794:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 796:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 798:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 800:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 802:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 803:.\Generated_Source\PSoC4/UART_1.c ****     *
 804:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 805:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 806:.\Generated_Source\PSoC4/UART_1.c ****     *
 807:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 808:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 809:.\Generated_Source\PSoC4/UART_1.c ****     *   the farther usage in RX ISR.
 810:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 811:.\Generated_Source\PSoC4/UART_1.c ****     *
 812:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 813:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 814:.\Generated_Source\PSoC4/UART_1.c ****                                                         
 815:.\Generated_Source\PSoC4/UART_1.c ****     {
 657              		.loc 1 815 0
 658              		.cfi_startproc
 659 0000 80B5     		push	{r7, lr}
 660              		.cfi_def_cfa_offset 8
 661              		.cfi_offset 7, -8
 662              		.cfi_offset 14, -4
 663 0002 82B0     		sub	sp, sp, #8
 664              		.cfi_def_cfa_offset 16
 665 0004 00AF     		add	r7, sp, #0
 666              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 27


 667 0006 021C     		mov	r2, r0
 668 0008 FB1D     		add	r3, r7, #7
 669 000a 1A70     		strb	r2, [r3]
 816:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 817:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 818:.\Generated_Source\PSoC4/UART_1.c ****                 if(0u != addressMode)
 819:.\Generated_Source\PSoC4/UART_1.c ****                 {
 820:.\Generated_Source\PSoC4/UART_1.c ****                     /* Suppress compiler warning */
 821:.\Generated_Source\PSoC4/UART_1.c ****                 }
 822:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 823:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 tmpCtrl;
 824:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 825:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 826:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 827:.\Generated_Source\PSoC4/UART_1.c **** 
 828:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 829:.\Generated_Source\PSoC4/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 830:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
 831:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 832:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 833:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 834:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 835:.\Generated_Source\PSoC4/UART_1.c ****             if(0u != addressMode)
 836:.\Generated_Source\PSoC4/UART_1.c ****             {
 837:.\Generated_Source\PSoC4/UART_1.c ****                 /* Suppress compiler warning */
 838:.\Generated_Source\PSoC4/UART_1.c ****             }
 839:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 840:.\Generated_Source\PSoC4/UART_1.c ****     }
 670              		.loc 1 840 0
 671 000c BD46     		mov	sp, r7
 672 000e 02B0     		add	sp, sp, #8
 673              		@ sp needed
 674 0010 80BD     		pop	{r7, pc}
 675              		.cfi_endproc
 676              	.LFE13:
 677              		.size	UART_1_SetRxAddressMode, .-UART_1_SetRxAddressMode
 678 0012 C046     		.section	.text.UART_1_SetRxAddress1,"ax",%progbits
 679              		.align	2
 680              		.global	UART_1_SetRxAddress1
 681              		.code	16
 682              		.thumb_func
 683              		.type	UART_1_SetRxAddress1, %function
 684              	UART_1_SetRxAddress1:
 685              	.LFB14:
 841:.\Generated_Source\PSoC4/UART_1.c **** 
 842:.\Generated_Source\PSoC4/UART_1.c **** 
 843:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 844:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
 845:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 846:.\Generated_Source\PSoC4/UART_1.c ****     *
 847:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 848:.\Generated_Source\PSoC4/UART_1.c ****     *  Sets the first of two hardware-detectable receiver addresses.
 849:.\Generated_Source\PSoC4/UART_1.c ****     *
 850:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 851:.\Generated_Source\PSoC4/UART_1.c ****     *  address: Address #1 for hardware address detection.
 852:.\Generated_Source\PSoC4/UART_1.c ****     *
 853:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 28


 854:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 855:.\Generated_Source\PSoC4/UART_1.c ****     *
 856:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 857:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 858:.\Generated_Source\PSoC4/UART_1.c ****     {
 686              		.loc 1 858 0
 687              		.cfi_startproc
 688 0000 80B5     		push	{r7, lr}
 689              		.cfi_def_cfa_offset 8
 690              		.cfi_offset 7, -8
 691              		.cfi_offset 14, -4
 692 0002 82B0     		sub	sp, sp, #8
 693              		.cfi_def_cfa_offset 16
 694 0004 00AF     		add	r7, sp, #0
 695              		.cfi_def_cfa_register 7
 696 0006 021C     		mov	r2, r0
 697 0008 FB1D     		add	r3, r7, #7
 698 000a 1A70     		strb	r2, [r3]
 859:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 699              		.loc 1 859 0
 700 000c 034B     		ldr	r3, .L46
 701 000e FA1D     		add	r2, r7, #7
 702 0010 1278     		ldrb	r2, [r2]
 703 0012 1A70     		strb	r2, [r3]
 860:.\Generated_Source\PSoC4/UART_1.c ****     }
 704              		.loc 1 860 0
 705 0014 BD46     		mov	sp, r7
 706 0016 02B0     		add	sp, sp, #8
 707              		@ sp needed
 708 0018 80BD     		pop	{r7, pc}
 709              	.L47:
 710 001a C046     		.align	2
 711              	.L46:
 712 001c 22000F40 		.word	1074724898
 713              		.cfi_endproc
 714              	.LFE14:
 715              		.size	UART_1_SetRxAddress1, .-UART_1_SetRxAddress1
 716              		.section	.text.UART_1_SetRxAddress2,"ax",%progbits
 717              		.align	2
 718              		.global	UART_1_SetRxAddress2
 719              		.code	16
 720              		.thumb_func
 721              		.type	UART_1_SetRxAddress2, %function
 722              	UART_1_SetRxAddress2:
 723              	.LFB15:
 861:.\Generated_Source\PSoC4/UART_1.c **** 
 862:.\Generated_Source\PSoC4/UART_1.c **** 
 863:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 864:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 865:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 866:.\Generated_Source\PSoC4/UART_1.c ****     *
 867:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 868:.\Generated_Source\PSoC4/UART_1.c ****     *  Sets the second of two hardware-detectable receiver addresses.
 869:.\Generated_Source\PSoC4/UART_1.c ****     *
 870:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 871:.\Generated_Source\PSoC4/UART_1.c ****     *  address: Address #2 for hardware address detection.
 872:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 29


 873:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 874:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 875:.\Generated_Source\PSoC4/UART_1.c ****     *
 876:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 877:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 878:.\Generated_Source\PSoC4/UART_1.c ****     {
 724              		.loc 1 878 0
 725              		.cfi_startproc
 726 0000 80B5     		push	{r7, lr}
 727              		.cfi_def_cfa_offset 8
 728              		.cfi_offset 7, -8
 729              		.cfi_offset 14, -4
 730 0002 82B0     		sub	sp, sp, #8
 731              		.cfi_def_cfa_offset 16
 732 0004 00AF     		add	r7, sp, #0
 733              		.cfi_def_cfa_register 7
 734 0006 021C     		mov	r2, r0
 735 0008 FB1D     		add	r3, r7, #7
 736 000a 1A70     		strb	r2, [r3]
 879:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 737              		.loc 1 879 0
 738 000c 034B     		ldr	r3, .L49
 739 000e FA1D     		add	r2, r7, #7
 740 0010 1278     		ldrb	r2, [r2]
 741 0012 1A70     		strb	r2, [r3]
 880:.\Generated_Source\PSoC4/UART_1.c ****     }
 742              		.loc 1 880 0
 743 0014 BD46     		mov	sp, r7
 744 0016 02B0     		add	sp, sp, #8
 745              		@ sp needed
 746 0018 80BD     		pop	{r7, pc}
 747              	.L50:
 748 001a C046     		.align	2
 749              	.L49:
 750 001c 32000F40 		.word	1074724914
 751              		.cfi_endproc
 752              	.LFE15:
 753              		.size	UART_1_SetRxAddress2, .-UART_1_SetRxAddress2
 754              		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 755              		.align	2
 756              		.global	UART_1_SetTxInterruptMode
 757              		.code	16
 758              		.thumb_func
 759              		.type	UART_1_SetTxInterruptMode, %function
 760              	UART_1_SetTxInterruptMode:
 761              	.LFB16:
 881:.\Generated_Source\PSoC4/UART_1.c **** 
 882:.\Generated_Source\PSoC4/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 883:.\Generated_Source\PSoC4/UART_1.c **** 
 884:.\Generated_Source\PSoC4/UART_1.c **** 
 885:.\Generated_Source\PSoC4/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 886:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 887:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
 888:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 889:.\Generated_Source\PSoC4/UART_1.c ****     *
 890:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 891:.\Generated_Source\PSoC4/UART_1.c ****     *  Configures the TX interrupt sources to be enabled, but does not enable the
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 30


 892:.\Generated_Source\PSoC4/UART_1.c ****     *  interrupt.
 893:.\Generated_Source\PSoC4/UART_1.c ****     *
 894:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 895:.\Generated_Source\PSoC4/UART_1.c ****     *  intSrc: Bit field containing the TX interrupt sources to enable
 896:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_COMPLETE        Interrupt on TX byte complete
 897:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900:.\Generated_Source\PSoC4/UART_1.c ****     *
 901:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 902:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 903:.\Generated_Source\PSoC4/UART_1.c ****     *
 904:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 905:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 906:.\Generated_Source\PSoC4/UART_1.c ****     *
 907:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 908:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
 909:.\Generated_Source\PSoC4/UART_1.c ****     {
 762              		.loc 1 909 0
 763              		.cfi_startproc
 764 0000 80B5     		push	{r7, lr}
 765              		.cfi_def_cfa_offset 8
 766              		.cfi_offset 7, -8
 767              		.cfi_offset 14, -4
 768 0002 82B0     		sub	sp, sp, #8
 769              		.cfi_def_cfa_offset 16
 770 0004 00AF     		add	r7, sp, #0
 771              		.cfi_def_cfa_register 7
 772 0006 021C     		mov	r2, r0
 773 0008 FB1D     		add	r3, r7, #7
 774 000a 1A70     		strb	r2, [r3]
 910:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 775              		.loc 1 910 0
 776 000c 034B     		ldr	r3, .L52
 777 000e FA1D     		add	r2, r7, #7
 778 0010 1278     		ldrb	r2, [r2]
 779 0012 1A70     		strb	r2, [r3]
 911:.\Generated_Source\PSoC4/UART_1.c ****     }
 780              		.loc 1 911 0
 781 0014 BD46     		mov	sp, r7
 782 0016 02B0     		add	sp, sp, #8
 783              		@ sp needed
 784 0018 80BD     		pop	{r7, pc}
 785              	.L53:
 786 001a C046     		.align	2
 787              	.L52:
 788 001c 80000F40 		.word	1074724992
 789              		.cfi_endproc
 790              	.LFE16:
 791              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 792              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 793              		.align	2
 794              		.global	UART_1_WriteTxData
 795              		.code	16
 796              		.thumb_func
 797              		.type	UART_1_WriteTxData, %function
 798              	UART_1_WriteTxData:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 31


 799              	.LFB17:
 912:.\Generated_Source\PSoC4/UART_1.c **** 
 913:.\Generated_Source\PSoC4/UART_1.c **** 
 914:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 915:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_WriteTxData
 916:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 917:.\Generated_Source\PSoC4/UART_1.c ****     *
 918:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 919:.\Generated_Source\PSoC4/UART_1.c ****     *  Places a byte of data into the transmit buffer to be sent when the bus is
 920:.\Generated_Source\PSoC4/UART_1.c ****     *  available without checking the TX status register. You must check status
 921:.\Generated_Source\PSoC4/UART_1.c ****     *  separately.
 922:.\Generated_Source\PSoC4/UART_1.c ****     *
 923:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 924:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: data byte
 925:.\Generated_Source\PSoC4/UART_1.c ****     *
 926:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 927:.\Generated_Source\PSoC4/UART_1.c ****     * None.
 928:.\Generated_Source\PSoC4/UART_1.c ****     *
 929:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 930:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 931:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 932:.\Generated_Source\PSoC4/UART_1.c ****     *    incremented after each byte saved to buffer.
 933:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 934:.\Generated_Source\PSoC4/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 935:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 936:.\Generated_Source\PSoC4/UART_1.c ****     *    initialized.
 937:.\Generated_Source\PSoC4/UART_1.c ****     *
 938:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 939:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 940:.\Generated_Source\PSoC4/UART_1.c ****     *
 941:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 942:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
 943:.\Generated_Source\PSoC4/UART_1.c ****     {
 800              		.loc 1 943 0
 801              		.cfi_startproc
 802 0000 80B5     		push	{r7, lr}
 803              		.cfi_def_cfa_offset 8
 804              		.cfi_offset 7, -8
 805              		.cfi_offset 14, -4
 806 0002 82B0     		sub	sp, sp, #8
 807              		.cfi_def_cfa_offset 16
 808 0004 00AF     		add	r7, sp, #0
 809              		.cfi_def_cfa_register 7
 810 0006 021C     		mov	r2, r0
 811 0008 FB1D     		add	r3, r7, #7
 812 000a 1A70     		strb	r2, [r3]
 944:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
 945:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 813              		.loc 1 945 0
 814 000c 054B     		ldr	r3, .L56
 815 000e 1B78     		ldrb	r3, [r3]
 816 0010 002B     		cmp	r3, #0
 817 0012 03D0     		beq	.L54
 946:.\Generated_Source\PSoC4/UART_1.c ****         {
 947:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 948:.\Generated_Source\PSoC4/UART_1.c **** 
 949:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 32


 950:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
 951:.\Generated_Source\PSoC4/UART_1.c **** 
 952:.\Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
 953:.\Generated_Source\PSoC4/UART_1.c ****                 ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
 954:.\Generated_Source\PSoC4/UART_1.c ****             {
 955:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
 956:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 957:.\Generated_Source\PSoC4/UART_1.c ****             }
 958:.\Generated_Source\PSoC4/UART_1.c ****             else
 959:.\Generated_Source\PSoC4/UART_1.c ****             {
 960:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_txBufferWrite >= UART_1_TX_BUFFER_SIZE)
 961:.\Generated_Source\PSoC4/UART_1.c ****                 {
 962:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite = 0u;
 963:.\Generated_Source\PSoC4/UART_1.c ****                 }
 964:.\Generated_Source\PSoC4/UART_1.c **** 
 965:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
 966:.\Generated_Source\PSoC4/UART_1.c **** 
 967:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add to the software buffer. */
 968:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_txBufferWrite++;
 969:.\Generated_Source\PSoC4/UART_1.c ****             }
 970:.\Generated_Source\PSoC4/UART_1.c **** 
 971:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
 972:.\Generated_Source\PSoC4/UART_1.c **** 
 973:.\Generated_Source\PSoC4/UART_1.c ****         #else
 974:.\Generated_Source\PSoC4/UART_1.c **** 
 975:.\Generated_Source\PSoC4/UART_1.c ****             /* Add directly to the FIFO. */
 976:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
 818              		.loc 1 976 0
 819 0014 044B     		ldr	r3, .L56+4
 820 0016 FA1D     		add	r2, r7, #7
 821 0018 1278     		ldrb	r2, [r2]
 822 001a 1A70     		strb	r2, [r3]
 823              	.L54:
 977:.\Generated_Source\PSoC4/UART_1.c **** 
 978:.\Generated_Source\PSoC4/UART_1.c ****         #endif /*(UART_1_TX_INTERRUPT_ENABLED) */
 979:.\Generated_Source\PSoC4/UART_1.c ****         }
 980:.\Generated_Source\PSoC4/UART_1.c ****     }
 824              		.loc 1 980 0
 825 001c BD46     		mov	sp, r7
 826 001e 02B0     		add	sp, sp, #8
 827              		@ sp needed
 828 0020 80BD     		pop	{r7, pc}
 829              	.L57:
 830 0022 C046     		.align	2
 831              	.L56:
 832 0024 00000000 		.word	UART_1_initVar
 833 0028 40000F40 		.word	1074724928
 834              		.cfi_endproc
 835              	.LFE17:
 836              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
 837              		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 838              		.align	2
 839              		.global	UART_1_ReadTxStatus
 840              		.code	16
 841              		.thumb_func
 842              		.type	UART_1_ReadTxStatus, %function
 843              	UART_1_ReadTxStatus:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 33


 844              	.LFB18:
 981:.\Generated_Source\PSoC4/UART_1.c **** 
 982:.\Generated_Source\PSoC4/UART_1.c **** 
 983:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 984:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
 985:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 986:.\Generated_Source\PSoC4/UART_1.c ****     *
 987:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 988:.\Generated_Source\PSoC4/UART_1.c ****     *  Reads the status register for the TX portion of the UART.
 989:.\Generated_Source\PSoC4/UART_1.c ****     *
 990:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 991:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 992:.\Generated_Source\PSoC4/UART_1.c ****     *
 993:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 994:.\Generated_Source\PSoC4/UART_1.c ****     *  Contents of the status register
 995:.\Generated_Source\PSoC4/UART_1.c ****     *
 996:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 997:.\Generated_Source\PSoC4/UART_1.c ****     *  This function reads the TX status register, which is cleared on read.
 998:.\Generated_Source\PSoC4/UART_1.c ****     *  It is up to the user to handle all bits in this return value accordingly,
 999:.\Generated_Source\PSoC4/UART_1.c ****     *  even if the bit was not enabled as an interrupt source the event happened
1000:.\Generated_Source\PSoC4/UART_1.c ****     *  and must be handled accordingly.
1001:.\Generated_Source\PSoC4/UART_1.c ****     *
1002:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1003:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
1004:.\Generated_Source\PSoC4/UART_1.c ****     {
 845              		.loc 1 1004 0
 846              		.cfi_startproc
 847 0000 80B5     		push	{r7, lr}
 848              		.cfi_def_cfa_offset 8
 849              		.cfi_offset 7, -8
 850              		.cfi_offset 14, -4
 851 0002 00AF     		add	r7, sp, #0
 852              		.cfi_def_cfa_register 7
1005:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 853              		.loc 1 1005 0
 854 0004 024B     		ldr	r3, .L60
 855 0006 1B78     		ldrb	r3, [r3]
 856 0008 DBB2     		uxtb	r3, r3
1006:.\Generated_Source\PSoC4/UART_1.c ****     }
 857              		.loc 1 1006 0
 858 000a 181C     		mov	r0, r3
 859 000c BD46     		mov	sp, r7
 860              		@ sp needed
 861 000e 80BD     		pop	{r7, pc}
 862              	.L61:
 863              		.align	2
 864              	.L60:
 865 0010 60000F40 		.word	1074724960
 866              		.cfi_endproc
 867              	.LFE18:
 868              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 869              		.section	.text.UART_1_PutChar,"ax",%progbits
 870              		.align	2
 871              		.global	UART_1_PutChar
 872              		.code	16
 873              		.thumb_func
 874              		.type	UART_1_PutChar, %function
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 34


 875              	UART_1_PutChar:
 876              	.LFB19:
1007:.\Generated_Source\PSoC4/UART_1.c **** 
1008:.\Generated_Source\PSoC4/UART_1.c **** 
1009:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1010:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutChar
1011:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1012:.\Generated_Source\PSoC4/UART_1.c ****     *
1013:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1014:.\Generated_Source\PSoC4/UART_1.c ****     *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015:.\Generated_Source\PSoC4/UART_1.c ****     *  available. This is a blocking API that waits until the TX buffer has room to
1016:.\Generated_Source\PSoC4/UART_1.c ****     *  hold the data.
1017:.\Generated_Source\PSoC4/UART_1.c ****     *
1018:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1019:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: Byte containing the data to transmit
1020:.\Generated_Source\PSoC4/UART_1.c ****     *
1021:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1022:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1023:.\Generated_Source\PSoC4/UART_1.c ****     *
1024:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1025:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1026:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1027:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1028:.\Generated_Source\PSoC4/UART_1.c ****     *     saved to buffer.
1029:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1030:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer.
1031:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1032:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1033:.\Generated_Source\PSoC4/UART_1.c ****     *
1034:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1035:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1036:.\Generated_Source\PSoC4/UART_1.c ****     *
1037:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1038:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1039:.\Generated_Source\PSoC4/UART_1.c ****     *
1040:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1041:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1042:.\Generated_Source\PSoC4/UART_1.c ****     {
 877              		.loc 1 1042 0
 878              		.cfi_startproc
 879 0000 80B5     		push	{r7, lr}
 880              		.cfi_def_cfa_offset 8
 881              		.cfi_offset 7, -8
 882              		.cfi_offset 14, -4
 883 0002 82B0     		sub	sp, sp, #8
 884              		.cfi_def_cfa_offset 16
 885 0004 00AF     		add	r7, sp, #0
 886              		.cfi_def_cfa_register 7
 887 0006 021C     		mov	r2, r0
 888 0008 FB1D     		add	r3, r7, #7
 889 000a 1A70     		strb	r2, [r3]
1043:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1044:.\Generated_Source\PSoC4/UART_1.c ****         /* The temporary output pointer is used since it takes two instructions
1045:.\Generated_Source\PSoC4/UART_1.c ****         *  to increment with a wrap, and we can't risk doing that with the real
1046:.\Generated_Source\PSoC4/UART_1.c ****         *  pointer and getting an interrupt in between instructions.
1047:.\Generated_Source\PSoC4/UART_1.c ****         */
1048:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locTxBufferWrite;
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 35


1049:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locTxBufferRead;
1050:.\Generated_Source\PSoC4/UART_1.c **** 
1051:.\Generated_Source\PSoC4/UART_1.c ****         do
1052:.\Generated_Source\PSoC4/UART_1.c ****         { /* Block if software buffer is full, so we don't overwrite. */
1053:.\Generated_Source\PSoC4/UART_1.c **** 
1054:.\Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1055:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable TX interrupt to protect variables from modification */
1056:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
1057:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1058:.\Generated_Source\PSoC4/UART_1.c **** 
1059:.\Generated_Source\PSoC4/UART_1.c ****             locTxBufferWrite = UART_1_txBufferWrite;
1060:.\Generated_Source\PSoC4/UART_1.c ****             locTxBufferRead  = UART_1_txBufferRead;
1061:.\Generated_Source\PSoC4/UART_1.c **** 
1062:.\Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1063:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable interrupt to continue transmission */
1064:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
1065:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1066:.\Generated_Source\PSoC4/UART_1.c ****         }
1067:.\Generated_Source\PSoC4/UART_1.c ****         while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) 
1068:.\Generated_Source\PSoC4/UART_1.c ****                                 ((locTxBufferWrite - locTxBufferRead) ==
1069:.\Generated_Source\PSoC4/UART_1.c ****                                 (uint8)(UART_1_TX_BUFFER_SIZE - 1u)) );
1070:.\Generated_Source\PSoC4/UART_1.c **** 
1071:.\Generated_Source\PSoC4/UART_1.c ****         if( (locTxBufferRead == locTxBufferWrite) &&
1072:.\Generated_Source\PSoC4/UART_1.c ****             ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1073:.\Generated_Source\PSoC4/UART_1.c ****         {
1074:.\Generated_Source\PSoC4/UART_1.c ****             /* Add directly to the FIFO */
1075:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
1076:.\Generated_Source\PSoC4/UART_1.c ****         }
1077:.\Generated_Source\PSoC4/UART_1.c ****         else
1078:.\Generated_Source\PSoC4/UART_1.c ****         {
1079:.\Generated_Source\PSoC4/UART_1.c ****             if(locTxBufferWrite >= UART_1_TX_BUFFER_SIZE)
1080:.\Generated_Source\PSoC4/UART_1.c ****             {
1081:.\Generated_Source\PSoC4/UART_1.c ****                 locTxBufferWrite = 0u;
1082:.\Generated_Source\PSoC4/UART_1.c ****             }
1083:.\Generated_Source\PSoC4/UART_1.c ****             /* Add to the software buffer. */
1084:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBuffer[locTxBufferWrite] = txDataByte;
1085:.\Generated_Source\PSoC4/UART_1.c ****             locTxBufferWrite++;
1086:.\Generated_Source\PSoC4/UART_1.c **** 
1087:.\Generated_Source\PSoC4/UART_1.c ****             /* Finally, update the real output pointer */
1088:.\Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1089:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
1090:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1091:.\Generated_Source\PSoC4/UART_1.c **** 
1092:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferWrite = locTxBufferWrite;
1093:.\Generated_Source\PSoC4/UART_1.c **** 
1094:.\Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1095:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
1096:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1097:.\Generated_Source\PSoC4/UART_1.c **** 
1098:.\Generated_Source\PSoC4/UART_1.c ****             if(0u != (UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_EMPTY))
1099:.\Generated_Source\PSoC4/UART_1.c ****             {
1100:.\Generated_Source\PSoC4/UART_1.c ****                 /* Trigger TX interrupt to send software buffer */
1101:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_SetPendingTxInt();
1102:.\Generated_Source\PSoC4/UART_1.c ****             }
1103:.\Generated_Source\PSoC4/UART_1.c ****         }
1104:.\Generated_Source\PSoC4/UART_1.c **** 
1105:.\Generated_Source\PSoC4/UART_1.c ****     #else
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 36


1106:.\Generated_Source\PSoC4/UART_1.c **** 
1107:.\Generated_Source\PSoC4/UART_1.c ****         while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 890              		.loc 1 1107 0
 891 000c C046     		mov	r8, r8
 892              	.L63:
 893              		.loc 1 1107 0 is_stmt 0 discriminator 1
 894 000e 074B     		ldr	r3, .L64
 895 0010 1B78     		ldrb	r3, [r3]
 896 0012 DBB2     		uxtb	r3, r3
 897 0014 1A1C     		mov	r2, r3
 898 0016 0423     		mov	r3, #4
 899 0018 1340     		and	r3, r2
 900 001a F8D1     		bne	.L63
1108:.\Generated_Source\PSoC4/UART_1.c ****         {
1109:.\Generated_Source\PSoC4/UART_1.c ****             /* Wait for room in the FIFO */
1110:.\Generated_Source\PSoC4/UART_1.c ****         }
1111:.\Generated_Source\PSoC4/UART_1.c **** 
1112:.\Generated_Source\PSoC4/UART_1.c ****         /* Add directly to the FIFO */
1113:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_REG = txDataByte;
 901              		.loc 1 1113 0 is_stmt 1
 902 001c 044B     		ldr	r3, .L64+4
 903 001e FA1D     		add	r2, r7, #7
 904 0020 1278     		ldrb	r2, [r2]
 905 0022 1A70     		strb	r2, [r3]
1114:.\Generated_Source\PSoC4/UART_1.c **** 
1115:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End (UART_1_TX_INTERRUPT_ENABLED) */
1116:.\Generated_Source\PSoC4/UART_1.c ****     }
 906              		.loc 1 1116 0
 907 0024 BD46     		mov	sp, r7
 908 0026 02B0     		add	sp, sp, #8
 909              		@ sp needed
 910 0028 80BD     		pop	{r7, pc}
 911              	.L65:
 912 002a C046     		.align	2
 913              	.L64:
 914 002c 60000F40 		.word	1074724960
 915 0030 40000F40 		.word	1074724928
 916              		.cfi_endproc
 917              	.LFE19:
 918              		.size	UART_1_PutChar, .-UART_1_PutChar
 919              		.section	.text.UART_1_PutString,"ax",%progbits
 920              		.align	2
 921              		.global	UART_1_PutString
 922              		.code	16
 923              		.thumb_func
 924              		.type	UART_1_PutString, %function
 925              	UART_1_PutString:
 926              	.LFB20:
1117:.\Generated_Source\PSoC4/UART_1.c **** 
1118:.\Generated_Source\PSoC4/UART_1.c **** 
1119:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1120:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutString
1121:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1122:.\Generated_Source\PSoC4/UART_1.c ****     *
1123:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1124:.\Generated_Source\PSoC4/UART_1.c ****     *  Sends a NULL terminated string to the TX buffer for transmission.
1125:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 37


1126:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1127:.\Generated_Source\PSoC4/UART_1.c ****     *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128:.\Generated_Source\PSoC4/UART_1.c ****     *
1129:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1130:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1131:.\Generated_Source\PSoC4/UART_1.c ****     *
1132:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1133:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1134:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1135:.\Generated_Source\PSoC4/UART_1.c ****     *
1136:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1137:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1138:.\Generated_Source\PSoC4/UART_1.c ****     *
1139:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1140:.\Generated_Source\PSoC4/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1141:.\Generated_Source\PSoC4/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1142:.\Generated_Source\PSoC4/UART_1.c ****     *  TX buffer.
1143:.\Generated_Source\PSoC4/UART_1.c ****     *
1144:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1145:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1146:.\Generated_Source\PSoC4/UART_1.c ****     {
 927              		.loc 1 1146 0
 928              		.cfi_startproc
 929 0000 80B5     		push	{r7, lr}
 930              		.cfi_def_cfa_offset 8
 931              		.cfi_offset 7, -8
 932              		.cfi_offset 14, -4
 933 0002 84B0     		sub	sp, sp, #16
 934              		.cfi_def_cfa_offset 24
 935 0004 00AF     		add	r7, sp, #0
 936              		.cfi_def_cfa_register 7
 937 0006 7860     		str	r0, [r7, #4]
1147:.\Generated_Source\PSoC4/UART_1.c ****         uint16 bufIndex = 0u;
 938              		.loc 1 1147 0
 939 0008 3B1C     		mov	r3, r7
 940 000a 0E33     		add	r3, r3, #14
 941 000c 0022     		mov	r2, #0
 942 000e 1A80     		strh	r2, [r3]
1148:.\Generated_Source\PSoC4/UART_1.c **** 
1149:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1150:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 943              		.loc 1 1150 0
 944 0010 0F4B     		ldr	r3, .L70
 945 0012 1B78     		ldrb	r3, [r3]
 946 0014 002B     		cmp	r3, #0
 947 0016 18D0     		beq	.L66
1151:.\Generated_Source\PSoC4/UART_1.c ****         {
1152:.\Generated_Source\PSoC4/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent */
1153:.\Generated_Source\PSoC4/UART_1.c ****             while(string[bufIndex] != (char8) 0)
 948              		.loc 1 1153 0
 949 0018 0FE0     		b	.L68
 950              	.L69:
1154:.\Generated_Source\PSoC4/UART_1.c ****             {
1155:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar((uint8)string[bufIndex]);
 951              		.loc 1 1155 0
 952 001a 3B1C     		mov	r3, r7
 953 001c 0E33     		add	r3, r3, #14
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 38


 954 001e 1B88     		ldrh	r3, [r3]
 955 0020 7A68     		ldr	r2, [r7, #4]
 956 0022 D318     		add	r3, r2, r3
 957 0024 1B78     		ldrb	r3, [r3]
 958 0026 181C     		mov	r0, r3
 959 0028 FFF7FEFF 		bl	UART_1_PutChar
1156:.\Generated_Source\PSoC4/UART_1.c ****                 bufIndex++;
 960              		.loc 1 1156 0
 961 002c 3B1C     		mov	r3, r7
 962 002e 0E33     		add	r3, r3, #14
 963 0030 1A88     		ldrh	r2, [r3]
 964 0032 3B1C     		mov	r3, r7
 965 0034 0E33     		add	r3, r3, #14
 966 0036 0132     		add	r2, r2, #1
 967 0038 1A80     		strh	r2, [r3]
 968              	.L68:
1153:.\Generated_Source\PSoC4/UART_1.c ****             while(string[bufIndex] != (char8) 0)
 969              		.loc 1 1153 0 discriminator 1
 970 003a 3B1C     		mov	r3, r7
 971 003c 0E33     		add	r3, r3, #14
 972 003e 1B88     		ldrh	r3, [r3]
 973 0040 7A68     		ldr	r2, [r7, #4]
 974 0042 D318     		add	r3, r2, r3
 975 0044 1B78     		ldrb	r3, [r3]
 976 0046 002B     		cmp	r3, #0
 977 0048 E7D1     		bne	.L69
 978              	.L66:
1157:.\Generated_Source\PSoC4/UART_1.c ****             }
1158:.\Generated_Source\PSoC4/UART_1.c ****         }
1159:.\Generated_Source\PSoC4/UART_1.c ****     }
 979              		.loc 1 1159 0
 980 004a BD46     		mov	sp, r7
 981 004c 04B0     		add	sp, sp, #16
 982              		@ sp needed
 983 004e 80BD     		pop	{r7, pc}
 984              	.L71:
 985              		.align	2
 986              	.L70:
 987 0050 00000000 		.word	UART_1_initVar
 988              		.cfi_endproc
 989              	.LFE20:
 990              		.size	UART_1_PutString, .-UART_1_PutString
 991              		.section	.text.UART_1_PutArray,"ax",%progbits
 992              		.align	2
 993              		.global	UART_1_PutArray
 994              		.code	16
 995              		.thumb_func
 996              		.type	UART_1_PutArray, %function
 997              	UART_1_PutArray:
 998              	.LFB21:
1160:.\Generated_Source\PSoC4/UART_1.c **** 
1161:.\Generated_Source\PSoC4/UART_1.c **** 
1162:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1163:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutArray
1164:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1165:.\Generated_Source\PSoC4/UART_1.c ****     *
1166:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 39


1167:.\Generated_Source\PSoC4/UART_1.c ****     *  Places N bytes of data from a memory array into the TX buffer for
1168:.\Generated_Source\PSoC4/UART_1.c ****     *  transmission.
1169:.\Generated_Source\PSoC4/UART_1.c ****     *
1170:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1171:.\Generated_Source\PSoC4/UART_1.c ****     *  string[]: Address of the memory array residing in RAM or ROM.
1172:.\Generated_Source\PSoC4/UART_1.c ****     *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173:.\Generated_Source\PSoC4/UART_1.c ****     *             Size parameter.
1174:.\Generated_Source\PSoC4/UART_1.c ****     *
1175:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1176:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1177:.\Generated_Source\PSoC4/UART_1.c ****     *
1178:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1179:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1180:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1181:.\Generated_Source\PSoC4/UART_1.c ****     *
1182:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1183:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1184:.\Generated_Source\PSoC4/UART_1.c ****     *
1185:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1186:.\Generated_Source\PSoC4/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1187:.\Generated_Source\PSoC4/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1188:.\Generated_Source\PSoC4/UART_1.c ****     *  TX buffer.
1189:.\Generated_Source\PSoC4/UART_1.c ****     *
1190:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1191:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1192:.\Generated_Source\PSoC4/UART_1.c ****                                                                     
1193:.\Generated_Source\PSoC4/UART_1.c ****     {
 999              		.loc 1 1193 0
 1000              		.cfi_startproc
 1001 0000 80B5     		push	{r7, lr}
 1002              		.cfi_def_cfa_offset 8
 1003              		.cfi_offset 7, -8
 1004              		.cfi_offset 14, -4
 1005 0002 84B0     		sub	sp, sp, #16
 1006              		.cfi_def_cfa_offset 24
 1007 0004 00AF     		add	r7, sp, #0
 1008              		.cfi_def_cfa_register 7
 1009 0006 7860     		str	r0, [r7, #4]
 1010 0008 0A1C     		mov	r2, r1
 1011 000a FB1C     		add	r3, r7, #3
 1012 000c 1A70     		strb	r2, [r3]
1194:.\Generated_Source\PSoC4/UART_1.c ****         uint8 bufIndex = 0u;
 1013              		.loc 1 1194 0
 1014 000e 3B1C     		mov	r3, r7
 1015 0010 0F33     		add	r3, r3, #15
 1016 0012 0022     		mov	r2, #0
 1017 0014 1A70     		strb	r2, [r3]
1195:.\Generated_Source\PSoC4/UART_1.c **** 
1196:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1197:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1018              		.loc 1 1197 0
 1019 0016 0F4B     		ldr	r3, .L76
 1020 0018 1B78     		ldrb	r3, [r3]
 1021 001a 002B     		cmp	r3, #0
 1022 001c 17D0     		beq	.L72
1198:.\Generated_Source\PSoC4/UART_1.c ****         {
1199:.\Generated_Source\PSoC4/UART_1.c ****             while(bufIndex < byteCount)
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 40


 1023              		.loc 1 1199 0
 1024 001e 0FE0     		b	.L74
 1025              	.L75:
1200:.\Generated_Source\PSoC4/UART_1.c ****             {
1201:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar(string[bufIndex]);
 1026              		.loc 1 1201 0
 1027 0020 3B1C     		mov	r3, r7
 1028 0022 0F33     		add	r3, r3, #15
 1029 0024 1B78     		ldrb	r3, [r3]
 1030 0026 7A68     		ldr	r2, [r7, #4]
 1031 0028 D318     		add	r3, r2, r3
 1032 002a 1B78     		ldrb	r3, [r3]
 1033 002c 181C     		mov	r0, r3
 1034 002e FFF7FEFF 		bl	UART_1_PutChar
1202:.\Generated_Source\PSoC4/UART_1.c ****                 bufIndex++;
 1035              		.loc 1 1202 0
 1036 0032 3B1C     		mov	r3, r7
 1037 0034 0F33     		add	r3, r3, #15
 1038 0036 1A78     		ldrb	r2, [r3]
 1039 0038 3B1C     		mov	r3, r7
 1040 003a 0F33     		add	r3, r3, #15
 1041 003c 0132     		add	r2, r2, #1
 1042 003e 1A70     		strb	r2, [r3]
 1043              	.L74:
1199:.\Generated_Source\PSoC4/UART_1.c ****             while(bufIndex < byteCount)
 1044              		.loc 1 1199 0 discriminator 1
 1045 0040 3A1C     		mov	r2, r7
 1046 0042 0F32     		add	r2, r2, #15
 1047 0044 FB1C     		add	r3, r7, #3
 1048 0046 1278     		ldrb	r2, [r2]
 1049 0048 1B78     		ldrb	r3, [r3]
 1050 004a 9A42     		cmp	r2, r3
 1051 004c E8D3     		bcc	.L75
 1052              	.L72:
1203:.\Generated_Source\PSoC4/UART_1.c ****             }
1204:.\Generated_Source\PSoC4/UART_1.c ****         }
1205:.\Generated_Source\PSoC4/UART_1.c ****     }
 1053              		.loc 1 1205 0
 1054 004e BD46     		mov	sp, r7
 1055 0050 04B0     		add	sp, sp, #16
 1056              		@ sp needed
 1057 0052 80BD     		pop	{r7, pc}
 1058              	.L77:
 1059              		.align	2
 1060              	.L76:
 1061 0054 00000000 		.word	UART_1_initVar
 1062              		.cfi_endproc
 1063              	.LFE21:
 1064              		.size	UART_1_PutArray, .-UART_1_PutArray
 1065              		.section	.text.UART_1_PutCRLF,"ax",%progbits
 1066              		.align	2
 1067              		.global	UART_1_PutCRLF
 1068              		.code	16
 1069              		.thumb_func
 1070              		.type	UART_1_PutCRLF, %function
 1071              	UART_1_PutCRLF:
 1072              	.LFB22:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 41


1206:.\Generated_Source\PSoC4/UART_1.c **** 
1207:.\Generated_Source\PSoC4/UART_1.c **** 
1208:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1209:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutCRLF
1210:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1211:.\Generated_Source\PSoC4/UART_1.c ****     *
1212:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1213:.\Generated_Source\PSoC4/UART_1.c ****     *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214:.\Generated_Source\PSoC4/UART_1.c ****     *  (0x0A) to the transmit buffer.
1215:.\Generated_Source\PSoC4/UART_1.c ****     *
1216:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1217:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218:.\Generated_Source\PSoC4/UART_1.c ****     *
1219:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1220:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1221:.\Generated_Source\PSoC4/UART_1.c ****     *
1222:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1223:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1224:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1225:.\Generated_Source\PSoC4/UART_1.c ****     *
1226:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1227:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1228:.\Generated_Source\PSoC4/UART_1.c ****     *
1229:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1230:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1231:.\Generated_Source\PSoC4/UART_1.c ****     {
 1073              		.loc 1 1231 0
 1074              		.cfi_startproc
 1075 0000 80B5     		push	{r7, lr}
 1076              		.cfi_def_cfa_offset 8
 1077              		.cfi_offset 7, -8
 1078              		.cfi_offset 14, -4
 1079 0002 82B0     		sub	sp, sp, #8
 1080              		.cfi_def_cfa_offset 16
 1081 0004 00AF     		add	r7, sp, #0
 1082              		.cfi_def_cfa_register 7
 1083 0006 021C     		mov	r2, r0
 1084 0008 FB1D     		add	r3, r7, #7
 1085 000a 1A70     		strb	r2, [r3]
1232:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1233:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1086              		.loc 1 1233 0
 1087 000c 084B     		ldr	r3, .L80
 1088 000e 1B78     		ldrb	r3, [r3]
 1089 0010 002B     		cmp	r3, #0
 1090 0012 0AD0     		beq	.L78
1234:.\Generated_Source\PSoC4/UART_1.c ****         {
1235:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(txDataByte);
 1091              		.loc 1 1235 0
 1092 0014 FB1D     		add	r3, r7, #7
 1093 0016 1B78     		ldrb	r3, [r3]
 1094 0018 181C     		mov	r0, r3
 1095 001a FFF7FEFF 		bl	UART_1_PutChar
1236:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Du);
 1096              		.loc 1 1236 0
 1097 001e 0D20     		mov	r0, #13
 1098 0020 FFF7FEFF 		bl	UART_1_PutChar
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 42


1237:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Au);
 1099              		.loc 1 1237 0
 1100 0024 0A20     		mov	r0, #10
 1101 0026 FFF7FEFF 		bl	UART_1_PutChar
 1102              	.L78:
1238:.\Generated_Source\PSoC4/UART_1.c ****         }
1239:.\Generated_Source\PSoC4/UART_1.c ****     }
 1103              		.loc 1 1239 0
 1104 002a BD46     		mov	sp, r7
 1105 002c 02B0     		add	sp, sp, #8
 1106              		@ sp needed
 1107 002e 80BD     		pop	{r7, pc}
 1108              	.L81:
 1109              		.align	2
 1110              	.L80:
 1111 0030 00000000 		.word	UART_1_initVar
 1112              		.cfi_endproc
 1113              	.LFE22:
 1114              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 1115              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 1116              		.align	2
 1117              		.global	UART_1_GetTxBufferSize
 1118              		.code	16
 1119              		.thumb_func
 1120              		.type	UART_1_GetTxBufferSize, %function
 1121              	UART_1_GetTxBufferSize:
 1122              	.LFB23:
1240:.\Generated_Source\PSoC4/UART_1.c **** 
1241:.\Generated_Source\PSoC4/UART_1.c **** 
1242:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1243:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1244:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1245:.\Generated_Source\PSoC4/UART_1.c ****     *
1246:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1247:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the number of bytes in the TX buffer which are waiting to be 
1248:.\Generated_Source\PSoC4/UART_1.c ****     *  transmitted.
1249:.\Generated_Source\PSoC4/UART_1.c ****     *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250:.\Generated_Source\PSoC4/UART_1.c ****     *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251:.\Generated_Source\PSoC4/UART_1.c ****     *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252:.\Generated_Source\PSoC4/UART_1.c ****     *    software buffer which are waiting to be transmitted. Bytes available in the
1253:.\Generated_Source\PSoC4/UART_1.c ****     *    TX FIFO do not take to account.
1254:.\Generated_Source\PSoC4/UART_1.c ****     *
1255:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1256:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1257:.\Generated_Source\PSoC4/UART_1.c ****     *
1258:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1259:.\Generated_Source\PSoC4/UART_1.c ****     *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260:.\Generated_Source\PSoC4/UART_1.c ****     *  Buffer Size parameter.
1261:.\Generated_Source\PSoC4/UART_1.c ****     *
1262:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1263:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1264:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1265:.\Generated_Source\PSoC4/UART_1.c ****     *
1266:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1267:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1268:.\Generated_Source\PSoC4/UART_1.c ****     *
1269:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 43


1270:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
1271:.\Generated_Source\PSoC4/UART_1.c ****     *
1272:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1274:.\Generated_Source\PSoC4/UART_1.c ****                                                             
1275:.\Generated_Source\PSoC4/UART_1.c ****     {
 1123              		.loc 1 1275 0
 1124              		.cfi_startproc
 1125 0000 80B5     		push	{r7, lr}
 1126              		.cfi_def_cfa_offset 8
 1127              		.cfi_offset 7, -8
 1128              		.cfi_offset 14, -4
 1129 0002 82B0     		sub	sp, sp, #8
 1130              		.cfi_def_cfa_offset 16
 1131 0004 00AF     		add	r7, sp, #0
 1132              		.cfi_def_cfa_register 7
1276:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
1277:.\Generated_Source\PSoC4/UART_1.c **** 
1278:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1279:.\Generated_Source\PSoC4/UART_1.c **** 
1280:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
1281:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableTxInt();
1282:.\Generated_Source\PSoC4/UART_1.c **** 
1283:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_txBufferRead == UART_1_txBufferWrite)
1284:.\Generated_Source\PSoC4/UART_1.c ****         {
1285:.\Generated_Source\PSoC4/UART_1.c ****             size = 0u;
1286:.\Generated_Source\PSoC4/UART_1.c ****         }
1287:.\Generated_Source\PSoC4/UART_1.c ****         else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1288:.\Generated_Source\PSoC4/UART_1.c ****         {
1289:.\Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1290:.\Generated_Source\PSoC4/UART_1.c ****         }
1291:.\Generated_Source\PSoC4/UART_1.c ****         else
1292:.\Generated_Source\PSoC4/UART_1.c ****         {
1293:.\Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_TX_BUFFER_SIZE - UART_1_txBufferRead) +
1294:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite;
1295:.\Generated_Source\PSoC4/UART_1.c ****         }
1296:.\Generated_Source\PSoC4/UART_1.c **** 
1297:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableTxInt();
1298:.\Generated_Source\PSoC4/UART_1.c **** 
1299:.\Generated_Source\PSoC4/UART_1.c ****     #else
1300:.\Generated_Source\PSoC4/UART_1.c **** 
1301:.\Generated_Source\PSoC4/UART_1.c ****         size = UART_1_TXSTATUS_REG;
 1133              		.loc 1 1301 0
 1134 0006 0F4A     		ldr	r2, .L87
 1135 0008 FB1D     		add	r3, r7, #7
 1136 000a 1278     		ldrb	r2, [r2]
 1137 000c 1A70     		strb	r2, [r3]
1302:.\Generated_Source\PSoC4/UART_1.c **** 
1303:.\Generated_Source\PSoC4/UART_1.c ****         /* Is the fifo is full. */
1304:.\Generated_Source\PSoC4/UART_1.c ****         if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 1138              		.loc 1 1304 0
 1139 000e FB1D     		add	r3, r7, #7
 1140 0010 1A78     		ldrb	r2, [r3]
 1141 0012 0423     		mov	r3, #4
 1142 0014 1340     		and	r3, r2
 1143 0016 03D0     		beq	.L83
1305:.\Generated_Source\PSoC4/UART_1.c ****         {
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 44


1306:.\Generated_Source\PSoC4/UART_1.c ****             size = UART_1_FIFO_LENGTH;
 1144              		.loc 1 1306 0
 1145 0018 FB1D     		add	r3, r7, #7
 1146 001a 0422     		mov	r2, #4
 1147 001c 1A70     		strb	r2, [r3]
 1148 001e 0BE0     		b	.L84
 1149              	.L83:
1307:.\Generated_Source\PSoC4/UART_1.c ****         }
1308:.\Generated_Source\PSoC4/UART_1.c ****         else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 1150              		.loc 1 1308 0
 1151 0020 FB1D     		add	r3, r7, #7
 1152 0022 1A78     		ldrb	r2, [r3]
 1153 0024 0223     		mov	r3, #2
 1154 0026 1340     		and	r3, r2
 1155 0028 03D0     		beq	.L85
1309:.\Generated_Source\PSoC4/UART_1.c ****         {
1310:.\Generated_Source\PSoC4/UART_1.c ****             size = 0u;
 1156              		.loc 1 1310 0
 1157 002a FB1D     		add	r3, r7, #7
 1158 002c 0022     		mov	r2, #0
 1159 002e 1A70     		strb	r2, [r3]
 1160 0030 02E0     		b	.L84
 1161              	.L85:
1311:.\Generated_Source\PSoC4/UART_1.c ****         }
1312:.\Generated_Source\PSoC4/UART_1.c ****         else
1313:.\Generated_Source\PSoC4/UART_1.c ****         {
1314:.\Generated_Source\PSoC4/UART_1.c ****             /* We only know there is data in the fifo. */
1315:.\Generated_Source\PSoC4/UART_1.c ****             size = 1u;
 1162              		.loc 1 1315 0
 1163 0032 FB1D     		add	r3, r7, #7
 1164 0034 0122     		mov	r2, #1
 1165 0036 1A70     		strb	r2, [r3]
 1166              	.L84:
1316:.\Generated_Source\PSoC4/UART_1.c ****         }
1317:.\Generated_Source\PSoC4/UART_1.c **** 
1318:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1319:.\Generated_Source\PSoC4/UART_1.c **** 
1320:.\Generated_Source\PSoC4/UART_1.c ****     return(size);
 1167              		.loc 1 1320 0
 1168 0038 FB1D     		add	r3, r7, #7
 1169 003a 1B78     		ldrb	r3, [r3]
1321:.\Generated_Source\PSoC4/UART_1.c ****     }
 1170              		.loc 1 1321 0
 1171 003c 181C     		mov	r0, r3
 1172 003e BD46     		mov	sp, r7
 1173 0040 02B0     		add	sp, sp, #8
 1174              		@ sp needed
 1175 0042 80BD     		pop	{r7, pc}
 1176              	.L88:
 1177              		.align	2
 1178              	.L87:
 1179 0044 60000F40 		.word	1074724960
 1180              		.cfi_endproc
 1181              	.LFE23:
 1182              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
 1183              		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 1184              		.align	2
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 45


 1185              		.global	UART_1_ClearTxBuffer
 1186              		.code	16
 1187              		.thumb_func
 1188              		.type	UART_1_ClearTxBuffer, %function
 1189              	UART_1_ClearTxBuffer:
 1190              	.LFB24:
1322:.\Generated_Source\PSoC4/UART_1.c **** 
1323:.\Generated_Source\PSoC4/UART_1.c **** 
1324:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1325:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1326:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1327:.\Generated_Source\PSoC4/UART_1.c ****     *
1328:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1329:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears all data from the TX buffer and hardware TX FIFO.
1330:.\Generated_Source\PSoC4/UART_1.c ****     *
1331:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1332:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1333:.\Generated_Source\PSoC4/UART_1.c ****     *
1334:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1335:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1336:.\Generated_Source\PSoC4/UART_1.c ****     *
1337:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1338:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1339:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1340:.\Generated_Source\PSoC4/UART_1.c ****     *
1341:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1342:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1343:.\Generated_Source\PSoC4/UART_1.c ****     *
1344:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1345:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1346:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1347:.\Generated_Source\PSoC4/UART_1.c ****     *  remained in the RAM.
1348:.\Generated_Source\PSoC4/UART_1.c ****     *
1349:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1350:.\Generated_Source\PSoC4/UART_1.c ****     *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351:.\Generated_Source\PSoC4/UART_1.c ****     *  transmitting finishes transmitting.
1352:.\Generated_Source\PSoC4/UART_1.c ****     *
1353:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1354:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1355:.\Generated_Source\PSoC4/UART_1.c ****     {
 1191              		.loc 1 1355 0
 1192              		.cfi_startproc
 1193 0000 90B5     		push	{r4, r7, lr}
 1194              		.cfi_def_cfa_offset 12
 1195              		.cfi_offset 4, -12
 1196              		.cfi_offset 7, -8
 1197              		.cfi_offset 14, -4
 1198 0002 83B0     		sub	sp, sp, #12
 1199              		.cfi_def_cfa_offset 24
 1200 0004 00AF     		add	r7, sp, #0
 1201              		.cfi_def_cfa_register 7
1356:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
1357:.\Generated_Source\PSoC4/UART_1.c **** 
1358:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 1202              		.loc 1 1358 0
 1203 0006 FC1D     		add	r4, r7, #7
 1204 0008 FFF7FEFF 		bl	CyEnterCriticalSection
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 46


 1205 000c 031C     		mov	r3, r0
 1206 000e 2370     		strb	r3, [r4]
1359:.\Generated_Source\PSoC4/UART_1.c ****         /* Clear the HW FIFO */
1360:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |= (uint8)  UART_1_TX_FIFO_CLR;
 1207              		.loc 1 1360 0
 1208 0010 0B4B     		ldr	r3, .L90
 1209 0012 0B4A     		ldr	r2, .L90
 1210 0014 1278     		ldrb	r2, [r2]
 1211 0016 D2B2     		uxtb	r2, r2
 1212 0018 0121     		mov	r1, #1
 1213 001a 0A43     		orr	r2, r1
 1214 001c D2B2     		uxtb	r2, r2
 1215 001e 1A70     		strb	r2, [r3]
1361:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8) ~UART_1_TX_FIFO_CLR;
 1216              		.loc 1 1361 0
 1217 0020 074B     		ldr	r3, .L90
 1218 0022 074A     		ldr	r2, .L90
 1219 0024 1278     		ldrb	r2, [r2]
 1220 0026 D2B2     		uxtb	r2, r2
 1221 0028 0121     		mov	r1, #1
 1222 002a 8A43     		bic	r2, r1
 1223 002c D2B2     		uxtb	r2, r2
 1224 002e 1A70     		strb	r2, [r3]
1362:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 1225              		.loc 1 1362 0
 1226 0030 FB1D     		add	r3, r7, #7
 1227 0032 1B78     		ldrb	r3, [r3]
 1228 0034 181C     		mov	r0, r3
 1229 0036 FFF7FEFF 		bl	CyExitCriticalSection
1363:.\Generated_Source\PSoC4/UART_1.c **** 
1364:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1365:.\Generated_Source\PSoC4/UART_1.c **** 
1366:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
1367:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableTxInt();
1368:.\Generated_Source\PSoC4/UART_1.c **** 
1369:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_txBufferRead = 0u;
1370:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_txBufferWrite = 0u;
1371:.\Generated_Source\PSoC4/UART_1.c **** 
1372:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable Tx interrupt. */
1373:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableTxInt();
1374:.\Generated_Source\PSoC4/UART_1.c **** 
1375:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1376:.\Generated_Source\PSoC4/UART_1.c ****     }
 1230              		.loc 1 1376 0
 1231 003a BD46     		mov	sp, r7
 1232 003c 03B0     		add	sp, sp, #12
 1233              		@ sp needed
 1234 003e 90BD     		pop	{r4, r7, pc}
 1235              	.L91:
 1236              		.align	2
 1237              	.L90:
 1238 0040 90000F40 		.word	1074725008
 1239              		.cfi_endproc
 1240              	.LFE24:
 1241              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
 1242              		.section	.text.UART_1_SendBreak,"ax",%progbits
 1243              		.align	2
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 47


 1244              		.global	UART_1_SendBreak
 1245              		.code	16
 1246              		.thumb_func
 1247              		.type	UART_1_SendBreak, %function
 1248              	UART_1_SendBreak:
 1249              	.LFB25:
1377:.\Generated_Source\PSoC4/UART_1.c **** 
1378:.\Generated_Source\PSoC4/UART_1.c **** 
1379:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1380:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SendBreak
1381:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1382:.\Generated_Source\PSoC4/UART_1.c ****     *
1383:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1384:.\Generated_Source\PSoC4/UART_1.c ****     *  Transmits a break signal on the bus.
1385:.\Generated_Source\PSoC4/UART_1.c ****     *
1386:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1387:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8 retMode:  Send Break return mode. See the following table for options.
1388:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_SEND_BREAK - Initialize registers for break, send the Break
1389:.\Generated_Source\PSoC4/UART_1.c ****     *       signal and return immediately.
1390:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391:.\Generated_Source\PSoC4/UART_1.c ****     *       complete, reinitialize registers to normal transmission mode then return
1392:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_REINIT - Reinitialize registers to normal transmission mode
1393:.\Generated_Source\PSoC4/UART_1.c ****     *       then return.
1394:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_SEND_WAIT_REINIT - Performs both options: 
1395:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_SEND_BREAK and UART_1_WAIT_FOR_COMPLETE_REINIT.
1396:.\Generated_Source\PSoC4/UART_1.c ****     *      This option is recommended for most cases.
1397:.\Generated_Source\PSoC4/UART_1.c ****     *
1398:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1399:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1400:.\Generated_Source\PSoC4/UART_1.c ****     *
1401:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1402:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1403:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1404:.\Generated_Source\PSoC4/UART_1.c ****     *  txPeriod - static variable, used for keeping TX period configuration.
1405:.\Generated_Source\PSoC4/UART_1.c ****     *
1406:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1407:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1408:.\Generated_Source\PSoC4/UART_1.c ****     *
1409:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1410:.\Generated_Source\PSoC4/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1411:.\Generated_Source\PSoC4/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1412:.\Generated_Source\PSoC4/UART_1.c ****     *  operation.
1413:.\Generated_Source\PSoC4/UART_1.c ****     *  There are 3 variants for this API usage:
1414:.\Generated_Source\PSoC4/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1415:.\Generated_Source\PSoC4/UART_1.c ****     *     configuration returning. Function will block CPU until transmission
1416:.\Generated_Source\PSoC4/UART_1.c ****     *     complete.
1417:.\Generated_Source\PSoC4/UART_1.c ****     *  2) User may want to use blocking time if UART configured to the low speed
1418:.\Generated_Source\PSoC4/UART_1.c ****     *     operation
1419:.\Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
1420:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1421:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1422:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1423:.\Generated_Source\PSoC4/UART_1.c ****     *  3) Same to 2) but user may want to initialize and use the interrupt to
1424:.\Generated_Source\PSoC4/UART_1.c ****     *     complete break operation.
1425:.\Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
1426:.\Generated_Source\PSoC4/UART_1.c ****     *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 48


1428:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1429:.\Generated_Source\PSoC4/UART_1.c ****     *     When interrupt appear with UART_1_TX_STS_COMPLETE status:
1430:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1431:.\Generated_Source\PSoC4/UART_1.c ****     *
1432:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1433:.\Generated_Source\PSoC4/UART_1.c ****     *  The UART_1_SendBreak() function initializes registers to send a
1434:.\Generated_Source\PSoC4/UART_1.c ****     *  break signal.
1435:.\Generated_Source\PSoC4/UART_1.c ****     *  Break signal length depends on the break signal bits configuration.
1436:.\Generated_Source\PSoC4/UART_1.c ****     *  The register configuration should be reinitialized before normal 8-bit
1437:.\Generated_Source\PSoC4/UART_1.c ****     *  communication can continue.
1438:.\Generated_Source\PSoC4/UART_1.c ****     *
1439:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1440:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1441:.\Generated_Source\PSoC4/UART_1.c ****     {
 1250              		.loc 1 1441 0
 1251              		.cfi_startproc
 1252 0000 80B5     		push	{r7, lr}
 1253              		.cfi_def_cfa_offset 8
 1254              		.cfi_offset 7, -8
 1255              		.cfi_offset 14, -4
 1256 0002 84B0     		sub	sp, sp, #16
 1257              		.cfi_def_cfa_offset 24
 1258 0004 00AF     		add	r7, sp, #0
 1259              		.cfi_def_cfa_register 7
 1260 0006 021C     		mov	r2, r0
 1261 0008 FB1D     		add	r3, r7, #7
 1262 000a 1A70     		strb	r2, [r3]
1442:.\Generated_Source\PSoC4/UART_1.c **** 
1443:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1444:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1263              		.loc 1 1444 0
 1264 000c 254B     		ldr	r3, .L100
 1265 000e 1B78     		ldrb	r3, [r3]
 1266 0010 002B     		cmp	r3, #0
 1267 0012 43D0     		beq	.L92
 1268              	.LBB2:
1445:.\Generated_Source\PSoC4/UART_1.c ****         {
1446:.\Generated_Source\PSoC4/UART_1.c ****             /* Set the Counter to 13-bits and transmit a 00 byte */
1447:.\Generated_Source\PSoC4/UART_1.c ****             /* When that is done then reset the counter value back */
1448:.\Generated_Source\PSoC4/UART_1.c ****             uint8 tmpStat;
1449:.\Generated_Source\PSoC4/UART_1.c **** 
1450:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1451:.\Generated_Source\PSoC4/UART_1.c **** 
1452:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
1453:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT ) )
1454:.\Generated_Source\PSoC4/UART_1.c ****             {
1455:.\Generated_Source\PSoC4/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
1456:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1457:.\Generated_Source\PSoC4/UART_1.c ****                                                       UART_1_CTRL_HD_SEND_BREAK);
1458:.\Generated_Source\PSoC4/UART_1.c ****                 /* Send zeros */
1459:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
1460:.\Generated_Source\PSoC4/UART_1.c **** 
1461:.\Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit starts */
1462:.\Generated_Source\PSoC4/UART_1.c ****                 {
1463:.\Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
1464:.\Generated_Source\PSoC4/UART_1.c ****                 }
1465:.\Generated_Source\PSoC4/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 49


1466:.\Generated_Source\PSoC4/UART_1.c ****             }
1467:.\Generated_Source\PSoC4/UART_1.c **** 
1468:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1469:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1470:.\Generated_Source\PSoC4/UART_1.c ****             {
1471:.\Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit complete */
1472:.\Generated_Source\PSoC4/UART_1.c ****                 {
1473:.\Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
1474:.\Generated_Source\PSoC4/UART_1.c ****                 }
1475:.\Generated_Source\PSoC4/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1476:.\Generated_Source\PSoC4/UART_1.c ****             }
1477:.\Generated_Source\PSoC4/UART_1.c **** 
1478:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1479:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_REINIT) ||
1480:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1481:.\Generated_Source\PSoC4/UART_1.c ****             {
1482:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1483:.\Generated_Source\PSoC4/UART_1.c ****                                               (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1484:.\Generated_Source\PSoC4/UART_1.c ****             }
1485:.\Generated_Source\PSoC4/UART_1.c **** 
1486:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_HD_ENABLED Full Duplex mode */
1487:.\Generated_Source\PSoC4/UART_1.c **** 
1488:.\Generated_Source\PSoC4/UART_1.c ****             static uint8 txPeriod;
1489:.\Generated_Source\PSoC4/UART_1.c **** 
1490:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
 1269              		.loc 1 1490 0
 1270 0014 FB1D     		add	r3, r7, #7
 1271 0016 1B78     		ldrb	r3, [r3]
 1272 0018 002B     		cmp	r3, #0
 1273 001a 03D0     		beq	.L94
 1274              		.loc 1 1490 0 is_stmt 0 discriminator 1
 1275 001c FB1D     		add	r3, r7, #7
 1276 001e 1B78     		ldrb	r3, [r3]
 1277 0020 032B     		cmp	r3, #3
 1278 0022 15D1     		bne	.L95
 1279              	.L94:
1491:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1492:.\Generated_Source\PSoC4/UART_1.c ****             {
1493:.\Generated_Source\PSoC4/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode
1494:.\Generated_Source\PSoC4/UART_1.c ****                 #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1495:.\Generated_Source\PSoC4/UART_1.c ****                                     (UART_1_PARITY_TYPE_SW != 0u) )
1496:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1497:.\Generated_Source\PSoC4/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1498:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1499:.\Generated_Source\PSoC4/UART_1.c **** 
1500:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TXCLKGEN_DP)
1501:.\Generated_Source\PSoC4/UART_1.c ****                     txPeriod = UART_1_TXBITCLKTX_COMPLETE_REG;
 1280              		.loc 1 1501 0 is_stmt 1
 1281 0024 204B     		ldr	r3, .L100+4
 1282 0026 1B78     		ldrb	r3, [r3]
 1283 0028 DAB2     		uxtb	r2, r3
 1284 002a 204B     		ldr	r3, .L100+8
 1285 002c 1A70     		strb	r2, [r3]
1502:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
 1286              		.loc 1 1502 0
 1287 002e 1E4B     		ldr	r3, .L100+4
 1288 0030 6722     		mov	r2, #103
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 50


 1289 0032 1A70     		strb	r2, [r3]
1503:.\Generated_Source\PSoC4/UART_1.c ****                 #else
1504:.\Generated_Source\PSoC4/UART_1.c ****                     txPeriod = UART_1_TXBITCTR_PERIOD_REG;
1505:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1506:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TXCLKGEN_DP */
1507:.\Generated_Source\PSoC4/UART_1.c **** 
1508:.\Generated_Source\PSoC4/UART_1.c ****                 /* Send zeros */
1509:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
 1290              		.loc 1 1509 0
 1291 0034 1E4B     		ldr	r3, .L100+12
 1292 0036 0022     		mov	r2, #0
 1293 0038 1A70     		strb	r2, [r3]
 1294              	.L96:
1510:.\Generated_Source\PSoC4/UART_1.c **** 
1511:.\Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit starts */
1512:.\Generated_Source\PSoC4/UART_1.c ****                 {
1513:.\Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 1295              		.loc 1 1513 0 discriminator 1
 1296 003a 1E4A     		ldr	r2, .L100+16
 1297 003c 3B1C     		mov	r3, r7
 1298 003e 0F33     		add	r3, r3, #15
 1299 0040 1278     		ldrb	r2, [r2]
 1300 0042 1A70     		strb	r2, [r3]
1514:.\Generated_Source\PSoC4/UART_1.c ****                 }
1515:.\Generated_Source\PSoC4/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 1301              		.loc 1 1515 0 discriminator 1
 1302 0044 3B1C     		mov	r3, r7
 1303 0046 0F33     		add	r3, r3, #15
 1304 0048 1A78     		ldrb	r2, [r3]
 1305 004a 0223     		mov	r3, #2
 1306 004c 1340     		and	r3, r2
 1307 004e F4D1     		bne	.L96
 1308              	.L95:
1516:.\Generated_Source\PSoC4/UART_1.c ****             }
1517:.\Generated_Source\PSoC4/UART_1.c **** 
1518:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1309              		.loc 1 1518 0
 1310 0050 FB1D     		add	r3, r7, #7
 1311 0052 1B78     		ldrb	r3, [r3]
 1312 0054 012B     		cmp	r3, #1
 1313 0056 03D0     		beq	.L97
 1314              		.loc 1 1518 0 is_stmt 0 discriminator 1
 1315 0058 FB1D     		add	r3, r7, #7
 1316 005a 1B78     		ldrb	r3, [r3]
 1317 005c 032B     		cmp	r3, #3
 1318 005e 0DD1     		bne	.L98
 1319              	.L97:
1519:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1520:.\Generated_Source\PSoC4/UART_1.c ****             {
1521:.\Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit complete */
1522:.\Generated_Source\PSoC4/UART_1.c ****                 {
1523:.\Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 1320              		.loc 1 1523 0 is_stmt 1 discriminator 1
 1321 0060 144A     		ldr	r2, .L100+16
 1322 0062 3B1C     		mov	r3, r7
 1323 0064 0F33     		add	r3, r3, #15
 1324 0066 1278     		ldrb	r2, [r2]
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 51


 1325 0068 1A70     		strb	r2, [r3]
1524:.\Generated_Source\PSoC4/UART_1.c ****                 }
1525:.\Generated_Source\PSoC4/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 1326              		.loc 1 1525 0 discriminator 1
 1327 006a 3B1C     		mov	r3, r7
 1328 006c 0F33     		add	r3, r3, #15
 1329 006e 1B78     		ldrb	r3, [r3]
 1330 0070 DB43     		mvn	r3, r3
 1331 0072 DBB2     		uxtb	r3, r3
 1332 0074 1A1C     		mov	r2, r3
 1333 0076 0123     		mov	r3, #1
 1334 0078 1340     		and	r3, r2
 1335 007a F1D1     		bne	.L97
 1336              	.L98:
1526:.\Generated_Source\PSoC4/UART_1.c ****             }
1527:.\Generated_Source\PSoC4/UART_1.c **** 
1528:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1337              		.loc 1 1528 0
 1338 007c FB1D     		add	r3, r7, #7
 1339 007e 1B78     		ldrb	r3, [r3]
 1340 0080 012B     		cmp	r3, #1
 1341 0082 07D0     		beq	.L99
 1342              		.loc 1 1528 0 is_stmt 0 discriminator 1
 1343 0084 FB1D     		add	r3, r7, #7
 1344 0086 1B78     		ldrb	r3, [r3]
 1345 0088 022B     		cmp	r3, #2
 1346 008a 03D0     		beq	.L99
1529:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_REINIT) ||
 1347              		.loc 1 1529 0 is_stmt 1
 1348 008c FB1D     		add	r3, r7, #7
 1349 008e 1B78     		ldrb	r3, [r3]
 1350 0090 032B     		cmp	r3, #3
 1351 0092 03D1     		bne	.L92
 1352              	.L99:
1530:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1531:.\Generated_Source\PSoC4/UART_1.c ****             {
1532:.\Generated_Source\PSoC4/UART_1.c **** 
1533:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXCLKGEN_DP)
1534:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXBITCLKTX_COMPLETE_REG = txPeriod;
 1353              		.loc 1 1534 0
 1354 0094 044B     		ldr	r3, .L100+4
 1355 0096 054A     		ldr	r2, .L100+8
 1356 0098 1278     		ldrb	r2, [r2]
 1357 009a 1A70     		strb	r2, [r3]
 1358              	.L92:
 1359              	.LBE2:
1535:.\Generated_Source\PSoC4/UART_1.c ****             #else
1536:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXBITCTR_PERIOD_REG = txPeriod;
1537:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXCLKGEN_DP */
1538:.\Generated_Source\PSoC4/UART_1.c **** 
1539:.\Generated_Source\PSoC4/UART_1.c ****             #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1540:.\Generated_Source\PSoC4/UART_1.c ****                  (UART_1_PARITY_TYPE_SW != 0u) )
1541:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1542:.\Generated_Source\PSoC4/UART_1.c ****                                                       (uint8) ~UART_1_CTRL_HD_SEND_BREAK);
1543:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_PARITY_TYPE != NONE */
1544:.\Generated_Source\PSoC4/UART_1.c ****             }
1545:.\Generated_Source\PSoC4/UART_1.c ****         #endif    /* End UART_1_HD_ENABLED */
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 52


1546:.\Generated_Source\PSoC4/UART_1.c ****         }
1547:.\Generated_Source\PSoC4/UART_1.c ****     }
 1360              		.loc 1 1547 0
 1361 009c BD46     		mov	sp, r7
 1362 009e 04B0     		add	sp, sp, #16
 1363              		@ sp needed
 1364 00a0 80BD     		pop	{r7, pc}
 1365              	.L101:
 1366 00a2 C046     		.align	2
 1367              	.L100:
 1368 00a4 00000000 		.word	UART_1_initVar
 1369 00a8 31000F40 		.word	1074724913
 1370 00ac 01000000 		.word	txPeriod.4827
 1371 00b0 40000F40 		.word	1074724928
 1372 00b4 60000F40 		.word	1074724960
 1373              		.cfi_endproc
 1374              	.LFE25:
 1375              		.size	UART_1_SendBreak, .-UART_1_SendBreak
 1376              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 1377              		.align	2
 1378              		.global	UART_1_SetTxAddressMode
 1379              		.code	16
 1380              		.thumb_func
 1381              		.type	UART_1_SetTxAddressMode, %function
 1382              	UART_1_SetTxAddressMode:
 1383              	.LFB26:
1548:.\Generated_Source\PSoC4/UART_1.c **** 
1549:.\Generated_Source\PSoC4/UART_1.c **** 
1550:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1551:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1552:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1553:.\Generated_Source\PSoC4/UART_1.c ****     *
1554:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1555:.\Generated_Source\PSoC4/UART_1.c ****     *  Configures the transmitter to signal the next bytes is address or data.
1556:.\Generated_Source\PSoC4/UART_1.c ****     *
1557:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1558:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: 
1559:.\Generated_Source\PSoC4/UART_1.c ****     *       UART_1_SET_SPACE - Configure the transmitter to send the next
1560:.\Generated_Source\PSoC4/UART_1.c ****     *                                    byte as a data.
1561:.\Generated_Source\PSoC4/UART_1.c ****     *       UART_1_SET_MARK  - Configure the transmitter to send the next
1562:.\Generated_Source\PSoC4/UART_1.c ****     *                                    byte as an address.
1563:.\Generated_Source\PSoC4/UART_1.c ****     *
1564:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1565:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1566:.\Generated_Source\PSoC4/UART_1.c ****     *
1567:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1568:.\Generated_Source\PSoC4/UART_1.c ****     *  This function sets and clears UART_1_CTRL_MARK bit in the Control
1569:.\Generated_Source\PSoC4/UART_1.c ****     *  register.
1570:.\Generated_Source\PSoC4/UART_1.c ****     *
1571:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1572:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1573:.\Generated_Source\PSoC4/UART_1.c ****     {
 1384              		.loc 1 1573 0
 1385              		.cfi_startproc
 1386 0000 80B5     		push	{r7, lr}
 1387              		.cfi_def_cfa_offset 8
 1388              		.cfi_offset 7, -8
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 53


 1389              		.cfi_offset 14, -4
 1390 0002 82B0     		sub	sp, sp, #8
 1391              		.cfi_def_cfa_offset 16
 1392 0004 00AF     		add	r7, sp, #0
 1393              		.cfi_def_cfa_register 7
 1394 0006 021C     		mov	r2, r0
 1395 0008 FB1D     		add	r3, r7, #7
 1396 000a 1A70     		strb	r2, [r3]
1574:.\Generated_Source\PSoC4/UART_1.c ****         /* Mark/Space sending enable */
1575:.\Generated_Source\PSoC4/UART_1.c ****         if(addressMode != 0u)
1576:.\Generated_Source\PSoC4/UART_1.c ****         {
1577:.\Generated_Source\PSoC4/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1578:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1579:.\Generated_Source\PSoC4/UART_1.c ****                                                   UART_1_CTRL_MARK);
1580:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1581:.\Generated_Source\PSoC4/UART_1.c ****         }
1582:.\Generated_Source\PSoC4/UART_1.c ****         else
1583:.\Generated_Source\PSoC4/UART_1.c ****         {
1584:.\Generated_Source\PSoC4/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1585:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1586:.\Generated_Source\PSoC4/UART_1.c ****                                                   (uint8) ~UART_1_CTRL_MARK);
1587:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1588:.\Generated_Source\PSoC4/UART_1.c ****         }
1589:.\Generated_Source\PSoC4/UART_1.c ****     }
 1397              		.loc 1 1589 0
 1398 000c BD46     		mov	sp, r7
 1399 000e 02B0     		add	sp, sp, #8
 1400              		@ sp needed
 1401 0010 80BD     		pop	{r7, pc}
 1402              		.cfi_endproc
 1403              	.LFE26:
 1404              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 1405 0012 C046     		.bss
 1406              	txPeriod.4827:
 1407 0001 00       		.space	1
 1408              		.text
 1409              	.Letext0:
 1410              		.file 2 ".\\Generated_Source\\PSoC4\\cytypes.h"
 1411              		.section	.debug_info,"",%progbits
 1412              	.Ldebug_info0:
 1413 0000 FC040000 		.4byte	0x4fc
 1414 0004 0400     		.2byte	0x4
 1415 0006 00000000 		.4byte	.Ldebug_abbrev0
 1416 000a 04       		.byte	0x4
 1417 000b 01       		.uleb128 0x1
 1418 000c C3020000 		.4byte	.LASF60
 1419 0010 01       		.byte	0x1
 1420 0011 EF000000 		.4byte	.LASF61
 1421 0015 51020000 		.4byte	.LASF62
 1422 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1423 001d 00000000 		.4byte	0
 1424 0021 00000000 		.4byte	.Ldebug_line0
 1425 0025 02       		.uleb128 0x2
 1426 0026 01       		.byte	0x1
 1427 0027 06       		.byte	0x6
 1428 0028 9C000000 		.4byte	.LASF0
 1429 002c 02       		.uleb128 0x2
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 54


 1430 002d 01       		.byte	0x1
 1431 002e 08       		.byte	0x8
 1432 002f 71030000 		.4byte	.LASF1
 1433 0033 02       		.uleb128 0x2
 1434 0034 02       		.byte	0x2
 1435 0035 05       		.byte	0x5
 1436 0036 7F030000 		.4byte	.LASF2
 1437 003a 02       		.uleb128 0x2
 1438 003b 02       		.byte	0x2
 1439 003c 07       		.byte	0x7
 1440 003d 73010000 		.4byte	.LASF3
 1441 0041 02       		.uleb128 0x2
 1442 0042 04       		.byte	0x4
 1443 0043 05       		.byte	0x5
 1444 0044 C0000000 		.4byte	.LASF4
 1445 0048 02       		.uleb128 0x2
 1446 0049 04       		.byte	0x4
 1447 004a 07       		.byte	0x7
 1448 004b 5C010000 		.4byte	.LASF5
 1449 004f 02       		.uleb128 0x2
 1450 0050 08       		.byte	0x8
 1451 0051 05       		.byte	0x5
 1452 0052 8E000000 		.4byte	.LASF6
 1453 0056 02       		.uleb128 0x2
 1454 0057 08       		.byte	0x8
 1455 0058 07       		.byte	0x7
 1456 0059 60000000 		.4byte	.LASF7
 1457 005d 03       		.uleb128 0x3
 1458 005e 04       		.byte	0x4
 1459 005f 05       		.byte	0x5
 1460 0060 696E7400 		.ascii	"int\000"
 1461 0064 02       		.uleb128 0x2
 1462 0065 04       		.byte	0x4
 1463 0066 07       		.byte	0x7
 1464 0067 3B010000 		.4byte	.LASF8
 1465 006b 04       		.uleb128 0x4
 1466 006c D6000000 		.4byte	.LASF9
 1467 0070 02       		.byte	0x2
 1468 0071 A1       		.byte	0xa1
 1469 0072 2C000000 		.4byte	0x2c
 1470 0076 04       		.uleb128 0x4
 1471 0077 00000000 		.4byte	.LASF10
 1472 007b 02       		.byte	0x2
 1473 007c A2       		.byte	0xa2
 1474 007d 3A000000 		.4byte	0x3a
 1475 0081 02       		.uleb128 0x2
 1476 0082 04       		.byte	0x4
 1477 0083 04       		.byte	0x4
 1478 0084 BD020000 		.4byte	.LASF11
 1479 0088 02       		.uleb128 0x2
 1480 0089 08       		.byte	0x8
 1481 008a 04       		.byte	0x4
 1482 008b DC000000 		.4byte	.LASF12
 1483 008f 04       		.uleb128 0x4
 1484 0090 E1030000 		.4byte	.LASF13
 1485 0094 02       		.byte	0x2
 1486 0095 B2       		.byte	0xb2
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 55


 1487 0096 9A000000 		.4byte	0x9a
 1488 009a 02       		.uleb128 0x2
 1489 009b 01       		.byte	0x1
 1490 009c 08       		.byte	0x8
 1491 009d DC030000 		.4byte	.LASF14
 1492 00a1 05       		.uleb128 0x5
 1493 00a2 6C030000 		.4byte	.LASF15
 1494 00a6 02       		.byte	0x2
 1495 00a7 4B01     		.2byte	0x14b
 1496 00a9 AD000000 		.4byte	0xad
 1497 00ad 06       		.uleb128 0x6
 1498 00ae 6B000000 		.4byte	0x6b
 1499 00b2 02       		.uleb128 0x2
 1500 00b3 04       		.byte	0x4
 1501 00b4 07       		.byte	0x7
 1502 00b5 1E020000 		.4byte	.LASF16
 1503 00b9 07       		.uleb128 0x7
 1504 00ba C9000000 		.4byte	.LASF17
 1505 00be 01       		.byte	0x1
 1506 00bf 4C       		.byte	0x4c
 1507 00c0 00000000 		.4byte	.LFB0
 1508 00c4 24000000 		.4byte	.LFE0-.LFB0
 1509 00c8 01       		.uleb128 0x1
 1510 00c9 9C       		.byte	0x9c
 1511 00ca 08       		.uleb128 0x8
 1512 00cb E7030000 		.4byte	.LASF18
 1513 00cf 01       		.byte	0x1
 1514 00d0 6A       		.byte	0x6a
 1515 00d1 00000000 		.4byte	.LFB1
 1516 00d5 3C000000 		.4byte	.LFE1-.LFB1
 1517 00d9 01       		.uleb128 0x1
 1518 00da 9C       		.byte	0x9c
 1519 00db 09       		.uleb128 0x9
 1520 00dc 86010000 		.4byte	.LASF19
 1521 00e0 01       		.byte	0x1
 1522 00e1 B7       		.byte	0xb7
 1523 00e2 00000000 		.4byte	.LFB2
 1524 00e6 60000000 		.4byte	.LFE2-.LFB2
 1525 00ea 01       		.uleb128 0x1
 1526 00eb 9C       		.byte	0x9c
 1527 00ec FF000000 		.4byte	0xff
 1528 00f0 0A       		.uleb128 0xa
 1529 00f1 F3030000 		.4byte	.LASF21
 1530 00f5 01       		.byte	0x1
 1531 00f6 B9       		.byte	0xb9
 1532 00f7 6B000000 		.4byte	0x6b
 1533 00fb 02       		.uleb128 0x2
 1534 00fc 91       		.byte	0x91
 1535 00fd 6F       		.sleb128 -17
 1536 00fe 00       		.byte	0
 1537 00ff 09       		.uleb128 0x9
 1538 0100 D7010000 		.4byte	.LASF20
 1539 0104 01       		.byte	0x1
 1540 0105 F0       		.byte	0xf0
 1541 0106 00000000 		.4byte	.LFB3
 1542 010a 60000000 		.4byte	.LFE3-.LFB3
 1543 010e 01       		.uleb128 0x1
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 56


 1544 010f 9C       		.byte	0x9c
 1545 0110 23010000 		.4byte	0x123
 1546 0114 0A       		.uleb128 0xa
 1547 0115 F3030000 		.4byte	.LASF21
 1548 0119 01       		.byte	0x1
 1549 011a F2       		.byte	0xf2
 1550 011b 6B000000 		.4byte	0x6b
 1551 011f 02       		.uleb128 0x2
 1552 0120 91       		.byte	0x91
 1553 0121 6F       		.sleb128 -17
 1554 0122 00       		.byte	0
 1555 0123 0B       		.uleb128 0xb
 1556 0124 BC010000 		.4byte	.LASF32
 1557 0128 01       		.byte	0x1
 1558 0129 2701     		.2byte	0x127
 1559 012b 6B000000 		.4byte	0x6b
 1560 012f 00000000 		.4byte	.LFB4
 1561 0133 0C000000 		.4byte	.LFE4-.LFB4
 1562 0137 01       		.uleb128 0x1
 1563 0138 9C       		.byte	0x9c
 1564 0139 0C       		.uleb128 0xc
 1565 013a 89030000 		.4byte	.LASF22
 1566 013e 01       		.byte	0x1
 1567 013f 3F01     		.2byte	0x13f
 1568 0141 00000000 		.4byte	.LFB5
 1569 0145 12000000 		.4byte	.LFE5-.LFB5
 1570 0149 01       		.uleb128 0x1
 1571 014a 9C       		.byte	0x9c
 1572 014b 5F010000 		.4byte	0x15f
 1573 014f 0D       		.uleb128 0xd
 1574 0150 11010000 		.4byte	.LASF24
 1575 0154 01       		.byte	0x1
 1576 0155 3F01     		.2byte	0x13f
 1577 0157 6B000000 		.4byte	0x6b
 1578 015b 02       		.uleb128 0x2
 1579 015c 91       		.byte	0x91
 1580 015d 77       		.sleb128 -9
 1581 015e 00       		.byte	0
 1582 015f 0C       		.uleb128 0xc
 1583 0160 19010000 		.4byte	.LASF23
 1584 0164 01       		.byte	0x1
 1585 0165 6701     		.2byte	0x167
 1586 0167 00000000 		.4byte	.LFB6
 1587 016b 20000000 		.4byte	.LFE6-.LFB6
 1588 016f 01       		.uleb128 0x1
 1589 0170 9C       		.byte	0x9c
 1590 0171 85010000 		.4byte	0x185
 1591 0175 0D       		.uleb128 0xd
 1592 0176 B5010000 		.4byte	.LASF25
 1593 017a 01       		.byte	0x1
 1594 017b 6701     		.2byte	0x167
 1595 017d 6B000000 		.4byte	0x6b
 1596 0181 02       		.uleb128 0x2
 1597 0182 91       		.byte	0x91
 1598 0183 77       		.sleb128 -9
 1599 0184 00       		.byte	0
 1600 0185 0E       		.uleb128 0xe
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 57


 1601 0186 4E000000 		.4byte	.LASF27
 1602 018a 01       		.byte	0x1
 1603 018b 8801     		.2byte	0x188
 1604 018d 6B000000 		.4byte	0x6b
 1605 0191 00000000 		.4byte	.LFB7
 1606 0195 20000000 		.4byte	.LFE7-.LFB7
 1607 0199 01       		.uleb128 0x1
 1608 019a 9C       		.byte	0x9c
 1609 019b AF010000 		.4byte	0x1af
 1610 019f 0F       		.uleb128 0xf
 1611 01a0 D5030000 		.4byte	.LASF26
 1612 01a4 01       		.byte	0x1
 1613 01a5 8A01     		.2byte	0x18a
 1614 01a7 6B000000 		.4byte	0x6b
 1615 01ab 02       		.uleb128 0x2
 1616 01ac 91       		.byte	0x91
 1617 01ad 77       		.sleb128 -9
 1618 01ae 00       		.byte	0
 1619 01af 0E       		.uleb128 0xe
 1620 01b0 13040000 		.4byte	.LASF28
 1621 01b4 01       		.byte	0x1
 1622 01b5 E501     		.2byte	0x1e5
 1623 01b7 6B000000 		.4byte	0x6b
 1624 01bb 00000000 		.4byte	.LFB8
 1625 01bf 24000000 		.4byte	.LFE8-.LFB8
 1626 01c3 01       		.uleb128 0x1
 1627 01c4 9C       		.byte	0x9c
 1628 01c5 D9010000 		.4byte	0x1d9
 1629 01c9 0F       		.uleb128 0xf
 1630 01ca 04040000 		.4byte	.LASF29
 1631 01ce 01       		.byte	0x1
 1632 01cf E701     		.2byte	0x1e7
 1633 01d1 6B000000 		.4byte	0x6b
 1634 01d5 02       		.uleb128 0x2
 1635 01d6 91       		.byte	0x91
 1636 01d7 77       		.sleb128 -9
 1637 01d8 00       		.byte	0
 1638 01d9 0E       		.uleb128 0xe
 1639 01da 27040000 		.4byte	.LASF30
 1640 01de 01       		.byte	0x1
 1641 01df 1402     		.2byte	0x214
 1642 01e1 6B000000 		.4byte	0x6b
 1643 01e5 00000000 		.4byte	.LFB9
 1644 01e9 4C000000 		.4byte	.LFE9-.LFB9
 1645 01ed 01       		.uleb128 0x1
 1646 01ee 9C       		.byte	0x9c
 1647 01ef 12020000 		.4byte	0x212
 1648 01f3 0F       		.uleb128 0xf
 1649 01f4 D5030000 		.4byte	.LASF26
 1650 01f8 01       		.byte	0x1
 1651 01f9 1602     		.2byte	0x216
 1652 01fb 6B000000 		.4byte	0x6b
 1653 01ff 02       		.uleb128 0x2
 1654 0200 91       		.byte	0x91
 1655 0201 77       		.sleb128 -9
 1656 0202 0F       		.uleb128 0xf
 1657 0203 9A020000 		.4byte	.LASF31
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 58


 1658 0207 01       		.byte	0x1
 1659 0208 1702     		.2byte	0x217
 1660 020a 6B000000 		.4byte	0x6b
 1661 020e 02       		.uleb128 0x2
 1662 020f 91       		.byte	0x91
 1663 0210 76       		.sleb128 -10
 1664 0211 00       		.byte	0
 1665 0212 10       		.uleb128 0x10
 1666 0213 E3010000 		.4byte	.LASF33
 1667 0217 01       		.byte	0x1
 1668 0218 7A02     		.2byte	0x27a
 1669 021a 76000000 		.4byte	0x76
 1670 021e 00000000 		.4byte	.LFB10
 1671 0222 22000000 		.4byte	.LFE10-.LFB10
 1672 0226 01       		.uleb128 0x1
 1673 0227 9C       		.byte	0x9c
 1674 0228 0E       		.uleb128 0xe
 1675 0229 BE030000 		.4byte	.LASF34
 1676 022d 01       		.byte	0x1
 1677 022e AB02     		.2byte	0x2ab
 1678 0230 6B000000 		.4byte	0x6b
 1679 0234 00000000 		.4byte	.LFB11
 1680 0238 30000000 		.4byte	.LFE11-.LFB11
 1681 023c 01       		.uleb128 0x1
 1682 023d 9C       		.byte	0x9c
 1683 023e 52020000 		.4byte	0x252
 1684 0242 0F       		.uleb128 0xf
 1685 0243 6E010000 		.4byte	.LASF35
 1686 0247 01       		.byte	0x1
 1687 0248 AE02     		.2byte	0x2ae
 1688 024a 6B000000 		.4byte	0x6b
 1689 024e 02       		.uleb128 0x2
 1690 024f 91       		.byte	0x91
 1691 0250 77       		.sleb128 -9
 1692 0251 00       		.byte	0
 1693 0252 11       		.uleb128 0x11
 1694 0253 3F030000 		.4byte	.LASF36
 1695 0257 01       		.byte	0x1
 1696 0258 F502     		.2byte	0x2f5
 1697 025a 00000000 		.4byte	.LFB12
 1698 025e 44000000 		.4byte	.LFE12-.LFB12
 1699 0262 01       		.uleb128 0x1
 1700 0263 9C       		.byte	0x9c
 1701 0264 78020000 		.4byte	0x278
 1702 0268 0F       		.uleb128 0xf
 1703 0269 F3030000 		.4byte	.LASF21
 1704 026d 01       		.byte	0x1
 1705 026e F702     		.2byte	0x2f7
 1706 0270 6B000000 		.4byte	0x6b
 1707 0274 02       		.uleb128 0x2
 1708 0275 91       		.byte	0x91
 1709 0276 6F       		.sleb128 -17
 1710 0277 00       		.byte	0
 1711 0278 0C       		.uleb128 0xc
 1712 0279 54030000 		.4byte	.LASF37
 1713 027d 01       		.byte	0x1
 1714 027e 2D03     		.2byte	0x32d
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 59


 1715 0280 00000000 		.4byte	.LFB13
 1716 0284 12000000 		.4byte	.LFE13-.LFB13
 1717 0288 01       		.uleb128 0x1
 1718 0289 9C       		.byte	0x9c
 1719 028a 9E020000 		.4byte	0x29e
 1720 028e 0D       		.uleb128 0xd
 1721 028f E3000000 		.4byte	.LASF38
 1722 0293 01       		.byte	0x1
 1723 0294 2D03     		.2byte	0x32d
 1724 0296 6B000000 		.4byte	0x6b
 1725 029a 02       		.uleb128 0x2
 1726 029b 91       		.byte	0x91
 1727 029c 77       		.sleb128 -9
 1728 029d 00       		.byte	0
 1729 029e 0C       		.uleb128 0xc
 1730 029f 27020000 		.4byte	.LASF39
 1731 02a3 01       		.byte	0x1
 1732 02a4 5903     		.2byte	0x359
 1733 02a6 00000000 		.4byte	.LFB14
 1734 02aa 20000000 		.4byte	.LFE14-.LFB14
 1735 02ae 01       		.uleb128 0x1
 1736 02af 9C       		.byte	0x9c
 1737 02b0 C4020000 		.4byte	0x2c4
 1738 02b4 0D       		.uleb128 0xd
 1739 02b5 0B040000 		.4byte	.LASF40
 1740 02b9 01       		.byte	0x1
 1741 02ba 5903     		.2byte	0x359
 1742 02bc 6B000000 		.4byte	0x6b
 1743 02c0 02       		.uleb128 0x2
 1744 02c1 91       		.byte	0x91
 1745 02c2 77       		.sleb128 -9
 1746 02c3 00       		.byte	0
 1747 02c4 0C       		.uleb128 0xc
 1748 02c5 3C020000 		.4byte	.LASF41
 1749 02c9 01       		.byte	0x1
 1750 02ca 6D03     		.2byte	0x36d
 1751 02cc 00000000 		.4byte	.LFB15
 1752 02d0 20000000 		.4byte	.LFE15-.LFB15
 1753 02d4 01       		.uleb128 0x1
 1754 02d5 9C       		.byte	0x9c
 1755 02d6 EA020000 		.4byte	0x2ea
 1756 02da 0D       		.uleb128 0xd
 1757 02db 0B040000 		.4byte	.LASF40
 1758 02df 01       		.byte	0x1
 1759 02e0 6D03     		.2byte	0x36d
 1760 02e2 6B000000 		.4byte	0x6b
 1761 02e6 02       		.uleb128 0x2
 1762 02e7 91       		.byte	0x91
 1763 02e8 77       		.sleb128 -9
 1764 02e9 00       		.byte	0
 1765 02ea 0C       		.uleb128 0xc
 1766 02eb A3020000 		.4byte	.LASF42
 1767 02ef 01       		.byte	0x1
 1768 02f0 8C03     		.2byte	0x38c
 1769 02f2 00000000 		.4byte	.LFB16
 1770 02f6 20000000 		.4byte	.LFE16-.LFB16
 1771 02fa 01       		.uleb128 0x1
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 60


 1772 02fb 9C       		.byte	0x9c
 1773 02fc 10030000 		.4byte	0x310
 1774 0300 0D       		.uleb128 0xd
 1775 0301 B5010000 		.4byte	.LASF25
 1776 0305 01       		.byte	0x1
 1777 0306 8C03     		.2byte	0x38c
 1778 0308 6B000000 		.4byte	0x6b
 1779 030c 02       		.uleb128 0x2
 1780 030d 91       		.byte	0x91
 1781 030e 77       		.sleb128 -9
 1782 030f 00       		.byte	0
 1783 0310 0C       		.uleb128 0xc
 1784 0311 03020000 		.4byte	.LASF43
 1785 0315 01       		.byte	0x1
 1786 0316 AE03     		.2byte	0x3ae
 1787 0318 00000000 		.4byte	.LFB17
 1788 031c 2C000000 		.4byte	.LFE17-.LFB17
 1789 0320 01       		.uleb128 0x1
 1790 0321 9C       		.byte	0x9c
 1791 0322 36030000 		.4byte	0x336
 1792 0326 0D       		.uleb128 0xd
 1793 0327 1C000000 		.4byte	.LASF44
 1794 032b 01       		.byte	0x1
 1795 032c AE03     		.2byte	0x3ae
 1796 032e 6B000000 		.4byte	0x6b
 1797 0332 02       		.uleb128 0x2
 1798 0333 91       		.byte	0x91
 1799 0334 77       		.sleb128 -9
 1800 0335 00       		.byte	0
 1801 0336 0B       		.uleb128 0xb
 1802 0337 48010000 		.4byte	.LASF45
 1803 033b 01       		.byte	0x1
 1804 033c EB03     		.2byte	0x3eb
 1805 033e 6B000000 		.4byte	0x6b
 1806 0342 00000000 		.4byte	.LFB18
 1807 0346 14000000 		.4byte	.LFE18-.LFB18
 1808 034a 01       		.uleb128 0x1
 1809 034b 9C       		.byte	0x9c
 1810 034c 0C       		.uleb128 0xc
 1811 034d 27000000 		.4byte	.LASF46
 1812 0351 01       		.byte	0x1
 1813 0352 1104     		.2byte	0x411
 1814 0354 00000000 		.4byte	.LFB19
 1815 0358 34000000 		.4byte	.LFE19-.LFB19
 1816 035c 01       		.uleb128 0x1
 1817 035d 9C       		.byte	0x9c
 1818 035e 72030000 		.4byte	0x372
 1819 0362 0D       		.uleb128 0xd
 1820 0363 1C000000 		.4byte	.LASF44
 1821 0367 01       		.byte	0x1
 1822 0368 1104     		.2byte	0x411
 1823 036a 6B000000 		.4byte	0x6b
 1824 036e 02       		.uleb128 0x2
 1825 036f 91       		.byte	0x91
 1826 0370 77       		.sleb128 -9
 1827 0371 00       		.byte	0
 1828 0372 11       		.uleb128 0x11
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 61


 1829 0373 F2010000 		.4byte	.LASF47
 1830 0377 01       		.byte	0x1
 1831 0378 7904     		.2byte	0x479
 1832 037a 00000000 		.4byte	.LFB20
 1833 037e 54000000 		.4byte	.LFE20-.LFB20
 1834 0382 01       		.uleb128 0x1
 1835 0383 9C       		.byte	0x9c
 1836 0384 A7030000 		.4byte	0x3a7
 1837 0388 0D       		.uleb128 0xd
 1838 0389 36000000 		.4byte	.LASF48
 1839 038d 01       		.byte	0x1
 1840 038e 7904     		.2byte	0x479
 1841 0390 A7030000 		.4byte	0x3a7
 1842 0394 02       		.uleb128 0x2
 1843 0395 91       		.byte	0x91
 1844 0396 6C       		.sleb128 -20
 1845 0397 0F       		.uleb128 0xf
 1846 0398 94010000 		.4byte	.LASF49
 1847 039c 01       		.byte	0x1
 1848 039d 7B04     		.2byte	0x47b
 1849 039f 76000000 		.4byte	0x76
 1850 03a3 02       		.uleb128 0x2
 1851 03a4 91       		.byte	0x91
 1852 03a5 76       		.sleb128 -10
 1853 03a6 00       		.byte	0
 1854 03a7 12       		.uleb128 0x12
 1855 03a8 04       		.byte	0x4
 1856 03a9 AD030000 		.4byte	0x3ad
 1857 03ad 13       		.uleb128 0x13
 1858 03ae 8F000000 		.4byte	0x8f
 1859 03b2 11       		.uleb128 0x11
 1860 03b3 36040000 		.4byte	.LASF50
 1861 03b7 01       		.byte	0x1
 1862 03b8 A704     		.2byte	0x4a7
 1863 03ba 00000000 		.4byte	.LFB21
 1864 03be 58000000 		.4byte	.LFE21-.LFB21
 1865 03c2 01       		.uleb128 0x1
 1866 03c3 9C       		.byte	0x9c
 1867 03c4 F6030000 		.4byte	0x3f6
 1868 03c8 0D       		.uleb128 0xd
 1869 03c9 36000000 		.4byte	.LASF48
 1870 03cd 01       		.byte	0x1
 1871 03ce A704     		.2byte	0x4a7
 1872 03d0 F6030000 		.4byte	0x3f6
 1873 03d4 02       		.uleb128 0x2
 1874 03d5 91       		.byte	0x91
 1875 03d6 6C       		.sleb128 -20
 1876 03d7 0D       		.uleb128 0xd
 1877 03d8 B4030000 		.4byte	.LASF51
 1878 03dc 01       		.byte	0x1
 1879 03dd A704     		.2byte	0x4a7
 1880 03df 6B000000 		.4byte	0x6b
 1881 03e3 02       		.uleb128 0x2
 1882 03e4 91       		.byte	0x91
 1883 03e5 6B       		.sleb128 -21
 1884 03e6 0F       		.uleb128 0xf
 1885 03e7 94010000 		.4byte	.LASF49
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 62


 1886 03eb 01       		.byte	0x1
 1887 03ec AA04     		.2byte	0x4aa
 1888 03ee 6B000000 		.4byte	0x6b
 1889 03f2 02       		.uleb128 0x2
 1890 03f3 91       		.byte	0x91
 1891 03f4 77       		.sleb128 -9
 1892 03f5 00       		.byte	0
 1893 03f6 12       		.uleb128 0x12
 1894 03f7 04       		.byte	0x4
 1895 03f8 FC030000 		.4byte	0x3fc
 1896 03fc 13       		.uleb128 0x13
 1897 03fd 6B000000 		.4byte	0x6b
 1898 0401 11       		.uleb128 0x11
 1899 0402 B1000000 		.4byte	.LASF52
 1900 0406 01       		.byte	0x1
 1901 0407 CE04     		.2byte	0x4ce
 1902 0409 00000000 		.4byte	.LFB22
 1903 040d 34000000 		.4byte	.LFE22-.LFB22
 1904 0411 01       		.uleb128 0x1
 1905 0412 9C       		.byte	0x9c
 1906 0413 27040000 		.4byte	0x427
 1907 0417 0D       		.uleb128 0xd
 1908 0418 1C000000 		.4byte	.LASF44
 1909 041c 01       		.byte	0x1
 1910 041d CE04     		.2byte	0x4ce
 1911 041f 6B000000 		.4byte	0x6b
 1912 0423 02       		.uleb128 0x2
 1913 0424 91       		.byte	0x91
 1914 0425 77       		.sleb128 -9
 1915 0426 00       		.byte	0
 1916 0427 0E       		.uleb128 0xe
 1917 0428 77000000 		.4byte	.LASF53
 1918 042c 01       		.byte	0x1
 1919 042d F904     		.2byte	0x4f9
 1920 042f 6B000000 		.4byte	0x6b
 1921 0433 00000000 		.4byte	.LFB23
 1922 0437 48000000 		.4byte	.LFE23-.LFB23
 1923 043b 01       		.uleb128 0x1
 1924 043c 9C       		.byte	0x9c
 1925 043d 51040000 		.4byte	0x451
 1926 0441 0F       		.uleb128 0xf
 1927 0442 6E010000 		.4byte	.LASF35
 1928 0446 01       		.byte	0x1
 1929 0447 FC04     		.2byte	0x4fc
 1930 0449 6B000000 		.4byte	0x6b
 1931 044d 02       		.uleb128 0x2
 1932 044e 91       		.byte	0x91
 1933 044f 77       		.sleb128 -9
 1934 0450 00       		.byte	0
 1935 0451 11       		.uleb128 0x11
 1936 0452 07000000 		.4byte	.LASF54
 1937 0456 01       		.byte	0x1
 1938 0457 4A05     		.2byte	0x54a
 1939 0459 00000000 		.4byte	.LFB24
 1940 045d 44000000 		.4byte	.LFE24-.LFB24
 1941 0461 01       		.uleb128 0x1
 1942 0462 9C       		.byte	0x9c
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 63


 1943 0463 77040000 		.4byte	0x477
 1944 0467 0F       		.uleb128 0xf
 1945 0468 F3030000 		.4byte	.LASF21
 1946 046c 01       		.byte	0x1
 1947 046d 4C05     		.2byte	0x54c
 1948 046f 6B000000 		.4byte	0x6b
 1949 0473 02       		.uleb128 0x2
 1950 0474 91       		.byte	0x91
 1951 0475 6F       		.sleb128 -17
 1952 0476 00       		.byte	0
 1953 0477 0C       		.uleb128 0xc
 1954 0478 3D000000 		.4byte	.LASF55
 1955 047c 01       		.byte	0x1
 1956 047d A005     		.2byte	0x5a0
 1957 047f 00000000 		.4byte	.LFB25
 1958 0483 B8000000 		.4byte	.LFE25-.LFB25
 1959 0487 01       		.uleb128 0x1
 1960 0488 9C       		.byte	0x9c
 1961 0489 C8040000 		.4byte	0x4c8
 1962 048d 0D       		.uleb128 0xd
 1963 048e 33010000 		.4byte	.LASF56
 1964 0492 01       		.byte	0x1
 1965 0493 A005     		.2byte	0x5a0
 1966 0495 6B000000 		.4byte	0x6b
 1967 0499 02       		.uleb128 0x2
 1968 049a 91       		.byte	0x91
 1969 049b 6F       		.sleb128 -17
 1970 049c 14       		.uleb128 0x14
 1971 049d 14000000 		.4byte	.LBB2
 1972 04a1 88000000 		.4byte	.LBE2-.LBB2
 1973 04a5 0F       		.uleb128 0xf
 1974 04a6 16020000 		.4byte	.LASF57
 1975 04aa 01       		.byte	0x1
 1976 04ab A805     		.2byte	0x5a8
 1977 04ad 6B000000 		.4byte	0x6b
 1978 04b1 02       		.uleb128 0x2
 1979 04b2 91       		.byte	0x91
 1980 04b3 77       		.sleb128 -9
 1981 04b4 0F       		.uleb128 0xf
 1982 04b5 A8000000 		.4byte	.LASF58
 1983 04b9 01       		.byte	0x1
 1984 04ba D005     		.2byte	0x5d0
 1985 04bc 6B000000 		.4byte	0x6b
 1986 04c0 05       		.uleb128 0x5
 1987 04c1 03       		.byte	0x3
 1988 04c2 01000000 		.4byte	txPeriod.4827
 1989 04c6 00       		.byte	0
 1990 04c7 00       		.byte	0
 1991 04c8 0C       		.uleb128 0xc
 1992 04c9 9D010000 		.4byte	.LASF59
 1993 04cd 01       		.byte	0x1
 1994 04ce 2406     		.2byte	0x624
 1995 04d0 00000000 		.4byte	.LFB26
 1996 04d4 12000000 		.4byte	.LFE26-.LFB26
 1997 04d8 01       		.uleb128 0x1
 1998 04d9 9C       		.byte	0x9c
 1999 04da EE040000 		.4byte	0x4ee
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 64


 2000 04de 0D       		.uleb128 0xd
 2001 04df E3000000 		.4byte	.LASF38
 2002 04e3 01       		.byte	0x1
 2003 04e4 2406     		.2byte	0x624
 2004 04e6 6B000000 		.4byte	0x6b
 2005 04ea 02       		.uleb128 0x2
 2006 04eb 91       		.byte	0x91
 2007 04ec 77       		.sleb128 -9
 2008 04ed 00       		.byte	0
 2009 04ee 15       		.uleb128 0x15
 2010 04ef A5030000 		.4byte	.LASF63
 2011 04f3 01       		.byte	0x1
 2012 04f4 1B       		.byte	0x1b
 2013 04f5 6B000000 		.4byte	0x6b
 2014 04f9 05       		.uleb128 0x5
 2015 04fa 03       		.byte	0x3
 2016 04fb 00000000 		.4byte	UART_1_initVar
 2017 04ff 00       		.byte	0
 2018              		.section	.debug_abbrev,"",%progbits
 2019              	.Ldebug_abbrev0:
 2020 0000 01       		.uleb128 0x1
 2021 0001 11       		.uleb128 0x11
 2022 0002 01       		.byte	0x1
 2023 0003 25       		.uleb128 0x25
 2024 0004 0E       		.uleb128 0xe
 2025 0005 13       		.uleb128 0x13
 2026 0006 0B       		.uleb128 0xb
 2027 0007 03       		.uleb128 0x3
 2028 0008 0E       		.uleb128 0xe
 2029 0009 1B       		.uleb128 0x1b
 2030 000a 0E       		.uleb128 0xe
 2031 000b 55       		.uleb128 0x55
 2032 000c 17       		.uleb128 0x17
 2033 000d 11       		.uleb128 0x11
 2034 000e 01       		.uleb128 0x1
 2035 000f 10       		.uleb128 0x10
 2036 0010 17       		.uleb128 0x17
 2037 0011 00       		.byte	0
 2038 0012 00       		.byte	0
 2039 0013 02       		.uleb128 0x2
 2040 0014 24       		.uleb128 0x24
 2041 0015 00       		.byte	0
 2042 0016 0B       		.uleb128 0xb
 2043 0017 0B       		.uleb128 0xb
 2044 0018 3E       		.uleb128 0x3e
 2045 0019 0B       		.uleb128 0xb
 2046 001a 03       		.uleb128 0x3
 2047 001b 0E       		.uleb128 0xe
 2048 001c 00       		.byte	0
 2049 001d 00       		.byte	0
 2050 001e 03       		.uleb128 0x3
 2051 001f 24       		.uleb128 0x24
 2052 0020 00       		.byte	0
 2053 0021 0B       		.uleb128 0xb
 2054 0022 0B       		.uleb128 0xb
 2055 0023 3E       		.uleb128 0x3e
 2056 0024 0B       		.uleb128 0xb
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 65


 2057 0025 03       		.uleb128 0x3
 2058 0026 08       		.uleb128 0x8
 2059 0027 00       		.byte	0
 2060 0028 00       		.byte	0
 2061 0029 04       		.uleb128 0x4
 2062 002a 16       		.uleb128 0x16
 2063 002b 00       		.byte	0
 2064 002c 03       		.uleb128 0x3
 2065 002d 0E       		.uleb128 0xe
 2066 002e 3A       		.uleb128 0x3a
 2067 002f 0B       		.uleb128 0xb
 2068 0030 3B       		.uleb128 0x3b
 2069 0031 0B       		.uleb128 0xb
 2070 0032 49       		.uleb128 0x49
 2071 0033 13       		.uleb128 0x13
 2072 0034 00       		.byte	0
 2073 0035 00       		.byte	0
 2074 0036 05       		.uleb128 0x5
 2075 0037 16       		.uleb128 0x16
 2076 0038 00       		.byte	0
 2077 0039 03       		.uleb128 0x3
 2078 003a 0E       		.uleb128 0xe
 2079 003b 3A       		.uleb128 0x3a
 2080 003c 0B       		.uleb128 0xb
 2081 003d 3B       		.uleb128 0x3b
 2082 003e 05       		.uleb128 0x5
 2083 003f 49       		.uleb128 0x49
 2084 0040 13       		.uleb128 0x13
 2085 0041 00       		.byte	0
 2086 0042 00       		.byte	0
 2087 0043 06       		.uleb128 0x6
 2088 0044 35       		.uleb128 0x35
 2089 0045 00       		.byte	0
 2090 0046 49       		.uleb128 0x49
 2091 0047 13       		.uleb128 0x13
 2092 0048 00       		.byte	0
 2093 0049 00       		.byte	0
 2094 004a 07       		.uleb128 0x7
 2095 004b 2E       		.uleb128 0x2e
 2096 004c 00       		.byte	0
 2097 004d 3F       		.uleb128 0x3f
 2098 004e 19       		.uleb128 0x19
 2099 004f 03       		.uleb128 0x3
 2100 0050 0E       		.uleb128 0xe
 2101 0051 3A       		.uleb128 0x3a
 2102 0052 0B       		.uleb128 0xb
 2103 0053 3B       		.uleb128 0x3b
 2104 0054 0B       		.uleb128 0xb
 2105 0055 27       		.uleb128 0x27
 2106 0056 19       		.uleb128 0x19
 2107 0057 11       		.uleb128 0x11
 2108 0058 01       		.uleb128 0x1
 2109 0059 12       		.uleb128 0x12
 2110 005a 06       		.uleb128 0x6
 2111 005b 40       		.uleb128 0x40
 2112 005c 18       		.uleb128 0x18
 2113 005d 9642     		.uleb128 0x2116
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 66


 2114 005f 19       		.uleb128 0x19
 2115 0060 00       		.byte	0
 2116 0061 00       		.byte	0
 2117 0062 08       		.uleb128 0x8
 2118 0063 2E       		.uleb128 0x2e
 2119 0064 00       		.byte	0
 2120 0065 3F       		.uleb128 0x3f
 2121 0066 19       		.uleb128 0x19
 2122 0067 03       		.uleb128 0x3
 2123 0068 0E       		.uleb128 0xe
 2124 0069 3A       		.uleb128 0x3a
 2125 006a 0B       		.uleb128 0xb
 2126 006b 3B       		.uleb128 0x3b
 2127 006c 0B       		.uleb128 0xb
 2128 006d 27       		.uleb128 0x27
 2129 006e 19       		.uleb128 0x19
 2130 006f 11       		.uleb128 0x11
 2131 0070 01       		.uleb128 0x1
 2132 0071 12       		.uleb128 0x12
 2133 0072 06       		.uleb128 0x6
 2134 0073 40       		.uleb128 0x40
 2135 0074 18       		.uleb128 0x18
 2136 0075 9742     		.uleb128 0x2117
 2137 0077 19       		.uleb128 0x19
 2138 0078 00       		.byte	0
 2139 0079 00       		.byte	0
 2140 007a 09       		.uleb128 0x9
 2141 007b 2E       		.uleb128 0x2e
 2142 007c 01       		.byte	0x1
 2143 007d 3F       		.uleb128 0x3f
 2144 007e 19       		.uleb128 0x19
 2145 007f 03       		.uleb128 0x3
 2146 0080 0E       		.uleb128 0xe
 2147 0081 3A       		.uleb128 0x3a
 2148 0082 0B       		.uleb128 0xb
 2149 0083 3B       		.uleb128 0x3b
 2150 0084 0B       		.uleb128 0xb
 2151 0085 27       		.uleb128 0x27
 2152 0086 19       		.uleb128 0x19
 2153 0087 11       		.uleb128 0x11
 2154 0088 01       		.uleb128 0x1
 2155 0089 12       		.uleb128 0x12
 2156 008a 06       		.uleb128 0x6
 2157 008b 40       		.uleb128 0x40
 2158 008c 18       		.uleb128 0x18
 2159 008d 9642     		.uleb128 0x2116
 2160 008f 19       		.uleb128 0x19
 2161 0090 01       		.uleb128 0x1
 2162 0091 13       		.uleb128 0x13
 2163 0092 00       		.byte	0
 2164 0093 00       		.byte	0
 2165 0094 0A       		.uleb128 0xa
 2166 0095 34       		.uleb128 0x34
 2167 0096 00       		.byte	0
 2168 0097 03       		.uleb128 0x3
 2169 0098 0E       		.uleb128 0xe
 2170 0099 3A       		.uleb128 0x3a
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 67


 2171 009a 0B       		.uleb128 0xb
 2172 009b 3B       		.uleb128 0x3b
 2173 009c 0B       		.uleb128 0xb
 2174 009d 49       		.uleb128 0x49
 2175 009e 13       		.uleb128 0x13
 2176 009f 02       		.uleb128 0x2
 2177 00a0 18       		.uleb128 0x18
 2178 00a1 00       		.byte	0
 2179 00a2 00       		.byte	0
 2180 00a3 0B       		.uleb128 0xb
 2181 00a4 2E       		.uleb128 0x2e
 2182 00a5 00       		.byte	0
 2183 00a6 3F       		.uleb128 0x3f
 2184 00a7 19       		.uleb128 0x19
 2185 00a8 03       		.uleb128 0x3
 2186 00a9 0E       		.uleb128 0xe
 2187 00aa 3A       		.uleb128 0x3a
 2188 00ab 0B       		.uleb128 0xb
 2189 00ac 3B       		.uleb128 0x3b
 2190 00ad 05       		.uleb128 0x5
 2191 00ae 27       		.uleb128 0x27
 2192 00af 19       		.uleb128 0x19
 2193 00b0 49       		.uleb128 0x49
 2194 00b1 13       		.uleb128 0x13
 2195 00b2 11       		.uleb128 0x11
 2196 00b3 01       		.uleb128 0x1
 2197 00b4 12       		.uleb128 0x12
 2198 00b5 06       		.uleb128 0x6
 2199 00b6 40       		.uleb128 0x40
 2200 00b7 18       		.uleb128 0x18
 2201 00b8 9742     		.uleb128 0x2117
 2202 00ba 19       		.uleb128 0x19
 2203 00bb 00       		.byte	0
 2204 00bc 00       		.byte	0
 2205 00bd 0C       		.uleb128 0xc
 2206 00be 2E       		.uleb128 0x2e
 2207 00bf 01       		.byte	0x1
 2208 00c0 3F       		.uleb128 0x3f
 2209 00c1 19       		.uleb128 0x19
 2210 00c2 03       		.uleb128 0x3
 2211 00c3 0E       		.uleb128 0xe
 2212 00c4 3A       		.uleb128 0x3a
 2213 00c5 0B       		.uleb128 0xb
 2214 00c6 3B       		.uleb128 0x3b
 2215 00c7 05       		.uleb128 0x5
 2216 00c8 27       		.uleb128 0x27
 2217 00c9 19       		.uleb128 0x19
 2218 00ca 11       		.uleb128 0x11
 2219 00cb 01       		.uleb128 0x1
 2220 00cc 12       		.uleb128 0x12
 2221 00cd 06       		.uleb128 0x6
 2222 00ce 40       		.uleb128 0x40
 2223 00cf 18       		.uleb128 0x18
 2224 00d0 9742     		.uleb128 0x2117
 2225 00d2 19       		.uleb128 0x19
 2226 00d3 01       		.uleb128 0x1
 2227 00d4 13       		.uleb128 0x13
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 68


 2228 00d5 00       		.byte	0
 2229 00d6 00       		.byte	0
 2230 00d7 0D       		.uleb128 0xd
 2231 00d8 05       		.uleb128 0x5
 2232 00d9 00       		.byte	0
 2233 00da 03       		.uleb128 0x3
 2234 00db 0E       		.uleb128 0xe
 2235 00dc 3A       		.uleb128 0x3a
 2236 00dd 0B       		.uleb128 0xb
 2237 00de 3B       		.uleb128 0x3b
 2238 00df 05       		.uleb128 0x5
 2239 00e0 49       		.uleb128 0x49
 2240 00e1 13       		.uleb128 0x13
 2241 00e2 02       		.uleb128 0x2
 2242 00e3 18       		.uleb128 0x18
 2243 00e4 00       		.byte	0
 2244 00e5 00       		.byte	0
 2245 00e6 0E       		.uleb128 0xe
 2246 00e7 2E       		.uleb128 0x2e
 2247 00e8 01       		.byte	0x1
 2248 00e9 3F       		.uleb128 0x3f
 2249 00ea 19       		.uleb128 0x19
 2250 00eb 03       		.uleb128 0x3
 2251 00ec 0E       		.uleb128 0xe
 2252 00ed 3A       		.uleb128 0x3a
 2253 00ee 0B       		.uleb128 0xb
 2254 00ef 3B       		.uleb128 0x3b
 2255 00f0 05       		.uleb128 0x5
 2256 00f1 27       		.uleb128 0x27
 2257 00f2 19       		.uleb128 0x19
 2258 00f3 49       		.uleb128 0x49
 2259 00f4 13       		.uleb128 0x13
 2260 00f5 11       		.uleb128 0x11
 2261 00f6 01       		.uleb128 0x1
 2262 00f7 12       		.uleb128 0x12
 2263 00f8 06       		.uleb128 0x6
 2264 00f9 40       		.uleb128 0x40
 2265 00fa 18       		.uleb128 0x18
 2266 00fb 9742     		.uleb128 0x2117
 2267 00fd 19       		.uleb128 0x19
 2268 00fe 01       		.uleb128 0x1
 2269 00ff 13       		.uleb128 0x13
 2270 0100 00       		.byte	0
 2271 0101 00       		.byte	0
 2272 0102 0F       		.uleb128 0xf
 2273 0103 34       		.uleb128 0x34
 2274 0104 00       		.byte	0
 2275 0105 03       		.uleb128 0x3
 2276 0106 0E       		.uleb128 0xe
 2277 0107 3A       		.uleb128 0x3a
 2278 0108 0B       		.uleb128 0xb
 2279 0109 3B       		.uleb128 0x3b
 2280 010a 05       		.uleb128 0x5
 2281 010b 49       		.uleb128 0x49
 2282 010c 13       		.uleb128 0x13
 2283 010d 02       		.uleb128 0x2
 2284 010e 18       		.uleb128 0x18
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 69


 2285 010f 00       		.byte	0
 2286 0110 00       		.byte	0
 2287 0111 10       		.uleb128 0x10
 2288 0112 2E       		.uleb128 0x2e
 2289 0113 00       		.byte	0
 2290 0114 3F       		.uleb128 0x3f
 2291 0115 19       		.uleb128 0x19
 2292 0116 03       		.uleb128 0x3
 2293 0117 0E       		.uleb128 0xe
 2294 0118 3A       		.uleb128 0x3a
 2295 0119 0B       		.uleb128 0xb
 2296 011a 3B       		.uleb128 0x3b
 2297 011b 05       		.uleb128 0x5
 2298 011c 27       		.uleb128 0x27
 2299 011d 19       		.uleb128 0x19
 2300 011e 49       		.uleb128 0x49
 2301 011f 13       		.uleb128 0x13
 2302 0120 11       		.uleb128 0x11
 2303 0121 01       		.uleb128 0x1
 2304 0122 12       		.uleb128 0x12
 2305 0123 06       		.uleb128 0x6
 2306 0124 40       		.uleb128 0x40
 2307 0125 18       		.uleb128 0x18
 2308 0126 9642     		.uleb128 0x2116
 2309 0128 19       		.uleb128 0x19
 2310 0129 00       		.byte	0
 2311 012a 00       		.byte	0
 2312 012b 11       		.uleb128 0x11
 2313 012c 2E       		.uleb128 0x2e
 2314 012d 01       		.byte	0x1
 2315 012e 3F       		.uleb128 0x3f
 2316 012f 19       		.uleb128 0x19
 2317 0130 03       		.uleb128 0x3
 2318 0131 0E       		.uleb128 0xe
 2319 0132 3A       		.uleb128 0x3a
 2320 0133 0B       		.uleb128 0xb
 2321 0134 3B       		.uleb128 0x3b
 2322 0135 05       		.uleb128 0x5
 2323 0136 27       		.uleb128 0x27
 2324 0137 19       		.uleb128 0x19
 2325 0138 11       		.uleb128 0x11
 2326 0139 01       		.uleb128 0x1
 2327 013a 12       		.uleb128 0x12
 2328 013b 06       		.uleb128 0x6
 2329 013c 40       		.uleb128 0x40
 2330 013d 18       		.uleb128 0x18
 2331 013e 9642     		.uleb128 0x2116
 2332 0140 19       		.uleb128 0x19
 2333 0141 01       		.uleb128 0x1
 2334 0142 13       		.uleb128 0x13
 2335 0143 00       		.byte	0
 2336 0144 00       		.byte	0
 2337 0145 12       		.uleb128 0x12
 2338 0146 0F       		.uleb128 0xf
 2339 0147 00       		.byte	0
 2340 0148 0B       		.uleb128 0xb
 2341 0149 0B       		.uleb128 0xb
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 70


 2342 014a 49       		.uleb128 0x49
 2343 014b 13       		.uleb128 0x13
 2344 014c 00       		.byte	0
 2345 014d 00       		.byte	0
 2346 014e 13       		.uleb128 0x13
 2347 014f 26       		.uleb128 0x26
 2348 0150 00       		.byte	0
 2349 0151 49       		.uleb128 0x49
 2350 0152 13       		.uleb128 0x13
 2351 0153 00       		.byte	0
 2352 0154 00       		.byte	0
 2353 0155 14       		.uleb128 0x14
 2354 0156 0B       		.uleb128 0xb
 2355 0157 01       		.byte	0x1
 2356 0158 11       		.uleb128 0x11
 2357 0159 01       		.uleb128 0x1
 2358 015a 12       		.uleb128 0x12
 2359 015b 06       		.uleb128 0x6
 2360 015c 00       		.byte	0
 2361 015d 00       		.byte	0
 2362 015e 15       		.uleb128 0x15
 2363 015f 34       		.uleb128 0x34
 2364 0160 00       		.byte	0
 2365 0161 03       		.uleb128 0x3
 2366 0162 0E       		.uleb128 0xe
 2367 0163 3A       		.uleb128 0x3a
 2368 0164 0B       		.uleb128 0xb
 2369 0165 3B       		.uleb128 0x3b
 2370 0166 0B       		.uleb128 0xb
 2371 0167 49       		.uleb128 0x49
 2372 0168 13       		.uleb128 0x13
 2373 0169 3F       		.uleb128 0x3f
 2374 016a 19       		.uleb128 0x19
 2375 016b 02       		.uleb128 0x2
 2376 016c 18       		.uleb128 0x18
 2377 016d 00       		.byte	0
 2378 016e 00       		.byte	0
 2379 016f 00       		.byte	0
 2380              		.section	.debug_aranges,"",%progbits
 2381 0000 EC000000 		.4byte	0xec
 2382 0004 0200     		.2byte	0x2
 2383 0006 00000000 		.4byte	.Ldebug_info0
 2384 000a 04       		.byte	0x4
 2385 000b 00       		.byte	0
 2386 000c 0000     		.2byte	0
 2387 000e 0000     		.2byte	0
 2388 0010 00000000 		.4byte	.LFB0
 2389 0014 24000000 		.4byte	.LFE0-.LFB0
 2390 0018 00000000 		.4byte	.LFB1
 2391 001c 3C000000 		.4byte	.LFE1-.LFB1
 2392 0020 00000000 		.4byte	.LFB2
 2393 0024 60000000 		.4byte	.LFE2-.LFB2
 2394 0028 00000000 		.4byte	.LFB3
 2395 002c 60000000 		.4byte	.LFE3-.LFB3
 2396 0030 00000000 		.4byte	.LFB4
 2397 0034 0C000000 		.4byte	.LFE4-.LFB4
 2398 0038 00000000 		.4byte	.LFB5
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 71


 2399 003c 12000000 		.4byte	.LFE5-.LFB5
 2400 0040 00000000 		.4byte	.LFB6
 2401 0044 20000000 		.4byte	.LFE6-.LFB6
 2402 0048 00000000 		.4byte	.LFB7
 2403 004c 20000000 		.4byte	.LFE7-.LFB7
 2404 0050 00000000 		.4byte	.LFB8
 2405 0054 24000000 		.4byte	.LFE8-.LFB8
 2406 0058 00000000 		.4byte	.LFB9
 2407 005c 4C000000 		.4byte	.LFE9-.LFB9
 2408 0060 00000000 		.4byte	.LFB10
 2409 0064 22000000 		.4byte	.LFE10-.LFB10
 2410 0068 00000000 		.4byte	.LFB11
 2411 006c 30000000 		.4byte	.LFE11-.LFB11
 2412 0070 00000000 		.4byte	.LFB12
 2413 0074 44000000 		.4byte	.LFE12-.LFB12
 2414 0078 00000000 		.4byte	.LFB13
 2415 007c 12000000 		.4byte	.LFE13-.LFB13
 2416 0080 00000000 		.4byte	.LFB14
 2417 0084 20000000 		.4byte	.LFE14-.LFB14
 2418 0088 00000000 		.4byte	.LFB15
 2419 008c 20000000 		.4byte	.LFE15-.LFB15
 2420 0090 00000000 		.4byte	.LFB16
 2421 0094 20000000 		.4byte	.LFE16-.LFB16
 2422 0098 00000000 		.4byte	.LFB17
 2423 009c 2C000000 		.4byte	.LFE17-.LFB17
 2424 00a0 00000000 		.4byte	.LFB18
 2425 00a4 14000000 		.4byte	.LFE18-.LFB18
 2426 00a8 00000000 		.4byte	.LFB19
 2427 00ac 34000000 		.4byte	.LFE19-.LFB19
 2428 00b0 00000000 		.4byte	.LFB20
 2429 00b4 54000000 		.4byte	.LFE20-.LFB20
 2430 00b8 00000000 		.4byte	.LFB21
 2431 00bc 58000000 		.4byte	.LFE21-.LFB21
 2432 00c0 00000000 		.4byte	.LFB22
 2433 00c4 34000000 		.4byte	.LFE22-.LFB22
 2434 00c8 00000000 		.4byte	.LFB23
 2435 00cc 48000000 		.4byte	.LFE23-.LFB23
 2436 00d0 00000000 		.4byte	.LFB24
 2437 00d4 44000000 		.4byte	.LFE24-.LFB24
 2438 00d8 00000000 		.4byte	.LFB25
 2439 00dc B8000000 		.4byte	.LFE25-.LFB25
 2440 00e0 00000000 		.4byte	.LFB26
 2441 00e4 12000000 		.4byte	.LFE26-.LFB26
 2442 00e8 00000000 		.4byte	0
 2443 00ec 00000000 		.4byte	0
 2444              		.section	.debug_ranges,"",%progbits
 2445              	.Ldebug_ranges0:
 2446 0000 00000000 		.4byte	.LFB0
 2447 0004 24000000 		.4byte	.LFE0
 2448 0008 00000000 		.4byte	.LFB1
 2449 000c 3C000000 		.4byte	.LFE1
 2450 0010 00000000 		.4byte	.LFB2
 2451 0014 60000000 		.4byte	.LFE2
 2452 0018 00000000 		.4byte	.LFB3
 2453 001c 60000000 		.4byte	.LFE3
 2454 0020 00000000 		.4byte	.LFB4
 2455 0024 0C000000 		.4byte	.LFE4
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 72


 2456 0028 00000000 		.4byte	.LFB5
 2457 002c 12000000 		.4byte	.LFE5
 2458 0030 00000000 		.4byte	.LFB6
 2459 0034 20000000 		.4byte	.LFE6
 2460 0038 00000000 		.4byte	.LFB7
 2461 003c 20000000 		.4byte	.LFE7
 2462 0040 00000000 		.4byte	.LFB8
 2463 0044 24000000 		.4byte	.LFE8
 2464 0048 00000000 		.4byte	.LFB9
 2465 004c 4C000000 		.4byte	.LFE9
 2466 0050 00000000 		.4byte	.LFB10
 2467 0054 22000000 		.4byte	.LFE10
 2468 0058 00000000 		.4byte	.LFB11
 2469 005c 30000000 		.4byte	.LFE11
 2470 0060 00000000 		.4byte	.LFB12
 2471 0064 44000000 		.4byte	.LFE12
 2472 0068 00000000 		.4byte	.LFB13
 2473 006c 12000000 		.4byte	.LFE13
 2474 0070 00000000 		.4byte	.LFB14
 2475 0074 20000000 		.4byte	.LFE14
 2476 0078 00000000 		.4byte	.LFB15
 2477 007c 20000000 		.4byte	.LFE15
 2478 0080 00000000 		.4byte	.LFB16
 2479 0084 20000000 		.4byte	.LFE16
 2480 0088 00000000 		.4byte	.LFB17
 2481 008c 2C000000 		.4byte	.LFE17
 2482 0090 00000000 		.4byte	.LFB18
 2483 0094 14000000 		.4byte	.LFE18
 2484 0098 00000000 		.4byte	.LFB19
 2485 009c 34000000 		.4byte	.LFE19
 2486 00a0 00000000 		.4byte	.LFB20
 2487 00a4 54000000 		.4byte	.LFE20
 2488 00a8 00000000 		.4byte	.LFB21
 2489 00ac 58000000 		.4byte	.LFE21
 2490 00b0 00000000 		.4byte	.LFB22
 2491 00b4 34000000 		.4byte	.LFE22
 2492 00b8 00000000 		.4byte	.LFB23
 2493 00bc 48000000 		.4byte	.LFE23
 2494 00c0 00000000 		.4byte	.LFB24
 2495 00c4 44000000 		.4byte	.LFE24
 2496 00c8 00000000 		.4byte	.LFB25
 2497 00cc B8000000 		.4byte	.LFE25
 2498 00d0 00000000 		.4byte	.LFB26
 2499 00d4 12000000 		.4byte	.LFE26
 2500 00d8 00000000 		.4byte	0
 2501 00dc 00000000 		.4byte	0
 2502              		.section	.debug_line,"",%progbits
 2503              	.Ldebug_line0:
 2504 0000 EA020000 		.section	.debug_str,"MS",%progbits,1
 2504      02004500 
 2504      00000201 
 2504      FB0E0D00 
 2504      01010101 
 2505              	.LASF10:
 2506 0000 75696E74 		.ascii	"uint16\000"
 2506      313600
 2507              	.LASF54:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 73


 2508 0007 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 2508      5F315F43 
 2508      6C656172 
 2508      54784275 
 2508      66666572 
 2509              	.LASF44:
 2510 001c 74784461 		.ascii	"txDataByte\000"
 2510      74614279 
 2510      746500
 2511              	.LASF46:
 2512 0027 55415254 		.ascii	"UART_1_PutChar\000"
 2512      5F315F50 
 2512      75744368 
 2512      617200
 2513              	.LASF48:
 2514 0036 73747269 		.ascii	"string\000"
 2514      6E6700
 2515              	.LASF55:
 2516 003d 55415254 		.ascii	"UART_1_SendBreak\000"
 2516      5F315F53 
 2516      656E6442 
 2516      7265616B 
 2516      00
 2517              	.LASF27:
 2518 004e 55415254 		.ascii	"UART_1_ReadRxData\000"
 2518      5F315F52 
 2518      65616452 
 2518      78446174 
 2518      6100
 2519              	.LASF7:
 2520 0060 6C6F6E67 		.ascii	"long long unsigned int\000"
 2520      206C6F6E 
 2520      6720756E 
 2520      7369676E 
 2520      65642069 
 2521              	.LASF53:
 2522 0077 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 2522      5F315F47 
 2522      65745478 
 2522      42756666 
 2522      65725369 
 2523              	.LASF6:
 2524 008e 6C6F6E67 		.ascii	"long long int\000"
 2524      206C6F6E 
 2524      6720696E 
 2524      7400
 2525              	.LASF0:
 2526 009c 7369676E 		.ascii	"signed char\000"
 2526      65642063 
 2526      68617200 
 2527              	.LASF58:
 2528 00a8 74785065 		.ascii	"txPeriod\000"
 2528      72696F64 
 2528      00
 2529              	.LASF52:
 2530 00b1 55415254 		.ascii	"UART_1_PutCRLF\000"
 2530      5F315F50 
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 74


 2530      75744352 
 2530      4C4600
 2531              	.LASF4:
 2532 00c0 6C6F6E67 		.ascii	"long int\000"
 2532      20696E74 
 2532      00
 2533              	.LASF17:
 2534 00c9 55415254 		.ascii	"UART_1_Start\000"
 2534      5F315F53 
 2534      74617274 
 2534      00
 2535              	.LASF9:
 2536 00d6 75696E74 		.ascii	"uint8\000"
 2536      3800
 2537              	.LASF12:
 2538 00dc 646F7562 		.ascii	"double\000"
 2538      6C6500
 2539              	.LASF38:
 2540 00e3 61646472 		.ascii	"addressMode\000"
 2540      6573734D 
 2540      6F646500 
 2541              	.LASF61:
 2542 00ef 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\UART_1.c\000"
 2542      6E657261 
 2542      7465645F 
 2542      536F7572 
 2542      63655C50 
 2543              	.LASF24:
 2544 0111 636F6E74 		.ascii	"control\000"
 2544      726F6C00 
 2545              	.LASF23:
 2546 0119 55415254 		.ascii	"UART_1_SetRxInterruptMode\000"
 2546      5F315F53 
 2546      65745278 
 2546      496E7465 
 2546      72727570 
 2547              	.LASF56:
 2548 0133 7265744D 		.ascii	"retMode\000"
 2548      6F646500 
 2549              	.LASF8:
 2550 013b 756E7369 		.ascii	"unsigned int\000"
 2550      676E6564 
 2550      20696E74 
 2550      00
 2551              	.LASF45:
 2552 0148 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 2552      5F315F52 
 2552      65616454 
 2552      78537461 
 2552      74757300 
 2553              	.LASF5:
 2554 015c 6C6F6E67 		.ascii	"long unsigned int\000"
 2554      20756E73 
 2554      69676E65 
 2554      6420696E 
 2554      7400
 2555              	.LASF35:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 75


 2556 016e 73697A65 		.ascii	"size\000"
 2556      00
 2557              	.LASF3:
 2558 0173 73686F72 		.ascii	"short unsigned int\000"
 2558      7420756E 
 2558      7369676E 
 2558      65642069 
 2558      6E7400
 2559              	.LASF19:
 2560 0186 55415254 		.ascii	"UART_1_Enable\000"
 2560      5F315F45 
 2560      6E61626C 
 2560      6500
 2561              	.LASF49:
 2562 0194 62756649 		.ascii	"bufIndex\000"
 2562      6E646578 
 2562      00
 2563              	.LASF59:
 2564 019d 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 2564      5F315F53 
 2564      65745478 
 2564      41646472 
 2564      6573734D 
 2565              	.LASF25:
 2566 01b5 696E7453 		.ascii	"intSrc\000"
 2566      726300
 2567              	.LASF32:
 2568 01bc 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 2568      5F315F52 
 2568      65616443 
 2568      6F6E7472 
 2568      6F6C5265 
 2569              	.LASF20:
 2570 01d7 55415254 		.ascii	"UART_1_Stop\000"
 2570      5F315F53 
 2570      746F7000 
 2571              	.LASF33:
 2572 01e3 55415254 		.ascii	"UART_1_GetByte\000"
 2572      5F315F47 
 2572      65744279 
 2572      746500
 2573              	.LASF47:
 2574 01f2 55415254 		.ascii	"UART_1_PutString\000"
 2574      5F315F50 
 2574      75745374 
 2574      72696E67 
 2574      00
 2575              	.LASF43:
 2576 0203 55415254 		.ascii	"UART_1_WriteTxData\000"
 2576      5F315F57 
 2576      72697465 
 2576      54784461 
 2576      746100
 2577              	.LASF57:
 2578 0216 746D7053 		.ascii	"tmpStat\000"
 2578      74617400 
 2579              	.LASF16:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 76


 2580 021e 73697A65 		.ascii	"sizetype\000"
 2580      74797065 
 2580      00
 2581              	.LASF39:
 2582 0227 55415254 		.ascii	"UART_1_SetRxAddress1\000"
 2582      5F315F53 
 2582      65745278 
 2582      41646472 
 2582      65737331 
 2583              	.LASF41:
 2584 023c 55415254 		.ascii	"UART_1_SetRxAddress2\000"
 2584      5F315F53 
 2584      65745278 
 2584      41646472 
 2584      65737332 
 2585              	.LASF62:
 2586 0251 433A5C55 		.ascii	"C:\\Users\\Matthew Arbesfeld\\Documents\\PSoC Creat"
 2586      73657273 
 2586      5C4D6174 
 2586      74686577 
 2586      20417262 
 2587 0280 6F725C42 		.ascii	"or\\BoxesUART\\Boxes4.cydsn\000"
 2587      6F786573 
 2587      55415254 
 2587      5C426F78 
 2587      6573342E 
 2588              	.LASF31:
 2589 029a 72785374 		.ascii	"rxStatus\000"
 2589      61747573 
 2589      00
 2590              	.LASF42:
 2591 02a3 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 2591      5F315F53 
 2591      65745478 
 2591      496E7465 
 2591      72727570 
 2592              	.LASF11:
 2593 02bd 666C6F61 		.ascii	"float\000"
 2593      7400
 2594              	.LASF60:
 2595 02c3 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 2595      4320342E 
 2595      382E3420 
 2595      32303134 
 2595      30353236 
 2596 02f6 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m0 -mthumb -g -O"
 2596      20726576 
 2596      6973696F 
 2596      6E203231 
 2596      31333538 
 2597 0329 30202D66 		.ascii	"0 -ffunction-sections\000"
 2597      66756E63 
 2597      74696F6E 
 2597      2D736563 
 2597      74696F6E 
 2598              	.LASF36:
 2599 033f 55415254 		.ascii	"UART_1_ClearRxBuffer\000"
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 77


 2599      5F315F43 
 2599      6C656172 
 2599      52784275 
 2599      66666572 
 2600              	.LASF37:
 2601 0354 55415254 		.ascii	"UART_1_SetRxAddressMode\000"
 2601      5F315F53 
 2601      65745278 
 2601      41646472 
 2601      6573734D 
 2602              	.LASF15:
 2603 036c 72656738 		.ascii	"reg8\000"
 2603      00
 2604              	.LASF1:
 2605 0371 756E7369 		.ascii	"unsigned char\000"
 2605      676E6564 
 2605      20636861 
 2605      7200
 2606              	.LASF2:
 2607 037f 73686F72 		.ascii	"short int\000"
 2607      7420696E 
 2607      7400
 2608              	.LASF22:
 2609 0389 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 2609      5F315F57 
 2609      72697465 
 2609      436F6E74 
 2609      726F6C52 
 2610              	.LASF63:
 2611 03a5 55415254 		.ascii	"UART_1_initVar\000"
 2611      5F315F69 
 2611      6E697456 
 2611      617200
 2612              	.LASF51:
 2613 03b4 62797465 		.ascii	"byteCount\000"
 2613      436F756E 
 2613      7400
 2614              	.LASF34:
 2615 03be 55415254 		.ascii	"UART_1_GetRxBufferSize\000"
 2615      5F315F47 
 2615      65745278 
 2615      42756666 
 2615      65725369 
 2616              	.LASF26:
 2617 03d5 72784461 		.ascii	"rxData\000"
 2617      746100
 2618              	.LASF14:
 2619 03dc 63686172 		.ascii	"char\000"
 2619      00
 2620              	.LASF13:
 2621 03e1 63686172 		.ascii	"char8\000"
 2621      3800
 2622              	.LASF18:
 2623 03e7 55415254 		.ascii	"UART_1_Init\000"
 2623      5F315F49 
 2623      6E697400 
 2624              	.LASF21:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cclqJn8X.s 			page 78


 2625 03f3 656E6162 		.ascii	"enableInterrupts\000"
 2625      6C65496E 
 2625      74657272 
 2625      75707473 
 2625      00
 2626              	.LASF29:
 2627 0404 73746174 		.ascii	"status\000"
 2627      757300
 2628              	.LASF40:
 2629 040b 61646472 		.ascii	"address\000"
 2629      65737300 
 2630              	.LASF28:
 2631 0413 55415254 		.ascii	"UART_1_ReadRxStatus\000"
 2631      5F315F52 
 2631      65616452 
 2631      78537461 
 2631      74757300 
 2632              	.LASF30:
 2633 0427 55415254 		.ascii	"UART_1_GetChar\000"
 2633      5F315F47 
 2633      65744368 
 2633      617200
 2634              	.LASF50:
 2635 0436 55415254 		.ascii	"UART_1_PutArray\000"
 2635      5F315F50 
 2635      75744172 
 2635      72617900 
 2636              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
