ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"UART_1.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	UART_1_initVar
  19              		.bss
  20              		.type	UART_1_initVar, %object
  21              		.size	UART_1_initVar, 1
  22              	UART_1_initVar:
  23 0000 00       		.space	1
  24              		.section	.text.UART_1_Start,"ax",%progbits
  25              		.align	2
  26              		.global	UART_1_Start
  27              		.thumb
  28              		.thumb_func
  29              		.type	UART_1_Start, %function
  30              	UART_1_Start:
  31              	.LFB0:
  32              		.file 1 ".\\Generated_Source\\PSoC5\\UART_1.c"
   1:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC5/UART_1.c **** * File Name: UART_1.c
   3:.\Generated_Source\PSoC5/UART_1.c **** * Version 2.40
   4:.\Generated_Source\PSoC5/UART_1.c **** *
   5:.\Generated_Source\PSoC5/UART_1.c **** * Description:
   6:.\Generated_Source\PSoC5/UART_1.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC5/UART_1.c **** *
   8:.\Generated_Source\PSoC5/UART_1.c **** * Note:
   9:.\Generated_Source\PSoC5/UART_1.c **** *
  10:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  11:.\Generated_Source\PSoC5/UART_1.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC5/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC5/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC5/UART_1.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC5/UART_1.c **** 
  17:.\Generated_Source\PSoC5/UART_1.c **** #include "UART_1.h"
  18:.\Generated_Source\PSoC5/UART_1.c **** #if (UART_1_INTERNAL_CLOCK_USED)
  19:.\Generated_Source\PSoC5/UART_1.c ****     #include "UART_1_IntClock.h"
  20:.\Generated_Source\PSoC5/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  21:.\Generated_Source\PSoC5/UART_1.c **** 
  22:.\Generated_Source\PSoC5/UART_1.c **** 
  23:.\Generated_Source\PSoC5/UART_1.c **** /***************************************
  24:.\Generated_Source\PSoC5/UART_1.c **** * Global data allocation
  25:.\Generated_Source\PSoC5/UART_1.c **** ***************************************/
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 2


  26:.\Generated_Source\PSoC5/UART_1.c **** 
  27:.\Generated_Source\PSoC5/UART_1.c **** uint8 UART_1_initVar = 0u;
  28:.\Generated_Source\PSoC5/UART_1.c **** 
  29:.\Generated_Source\PSoC5/UART_1.c **** #if (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED)
  30:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TX_BUFFER_SIZE];
  31:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC5/UART_1.c **** #endif /* (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED) */
  34:.\Generated_Source\PSoC5/UART_1.c **** 
  35:.\Generated_Source\PSoC5/UART_1.c **** #if (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED))
  36:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_errorStatus = 0u;
  37:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RX_BUFFER_SIZE];
  38:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferRead  = 0u;
  39:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  40:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  41:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow   = 0u;
  42:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  43:.\Generated_Source\PSoC5/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RX_ADDRESS_MODE;
  44:.\Generated_Source\PSoC5/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  45:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
  46:.\Generated_Source\PSoC5/UART_1.c **** #endif /* (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED)) */
  47:.\Generated_Source\PSoC5/UART_1.c **** 
  48:.\Generated_Source\PSoC5/UART_1.c **** 
  49:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
  50:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Start
  51:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  52:.\Generated_Source\PSoC5/UART_1.c **** *
  53:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
  54:.\Generated_Source\PSoC5/UART_1.c **** *  This is the preferred method to begin component operation.
  55:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_Start() sets the initVar variable, calls the
  56:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_Init() function, and then calls the
  57:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_Enable() function.
  58:.\Generated_Source\PSoC5/UART_1.c **** *
  59:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
  60:.\Generated_Source\PSoC5/UART_1.c **** *  None.
  61:.\Generated_Source\PSoC5/UART_1.c **** *
  62:.\Generated_Source\PSoC5/UART_1.c **** * Return:
  63:.\Generated_Source\PSoC5/UART_1.c **** *  None.
  64:.\Generated_Source\PSoC5/UART_1.c **** *
  65:.\Generated_Source\PSoC5/UART_1.c **** * Global variables:
  66:.\Generated_Source\PSoC5/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  67:.\Generated_Source\PSoC5/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  68:.\Generated_Source\PSoC5/UART_1.c **** *  and set to one (1u) the first time UART_1_Start() is called. This
  69:.\Generated_Source\PSoC5/UART_1.c **** *  allows for component initialization without re-initialization in all
  70:.\Generated_Source\PSoC5/UART_1.c **** *  subsequent calls to the UART_1_Start() routine.
  71:.\Generated_Source\PSoC5/UART_1.c **** *
  72:.\Generated_Source\PSoC5/UART_1.c **** * Reentrant:
  73:.\Generated_Source\PSoC5/UART_1.c **** *  No.
  74:.\Generated_Source\PSoC5/UART_1.c **** *
  75:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
  76:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Start(void) 
  77:.\Generated_Source\PSoC5/UART_1.c **** {
  33              		.loc 1 77 0
  34              		.cfi_startproc
  35              		@ args = 0, pretend = 0, frame = 0
  36              		@ frame_needed = 1, uses_anonymous_args = 0
  37 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 3


  38              		.cfi_def_cfa_offset 8
  39              		.cfi_offset 7, -8
  40              		.cfi_offset 14, -4
  41 0002 00AF     		add	r7, sp, #0
  42              		.cfi_def_cfa_register 7
  78:.\Generated_Source\PSoC5/UART_1.c ****     /* If not initialized then initialize all required hardware and software */
  79:.\Generated_Source\PSoC5/UART_1.c ****     if(UART_1_initVar == 0u)
  43              		.loc 1 79 0
  44 0004 054B     		ldr	r3, .L3
  45 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  46 0008 002B     		cmp	r3, #0
  47 000a 04D1     		bne	.L2
  80:.\Generated_Source\PSoC5/UART_1.c ****     {
  81:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_Init();
  48              		.loc 1 81 0
  49 000c FFF7FEFF 		bl	UART_1_Init
  82:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_initVar = 1u;
  50              		.loc 1 82 0
  51 0010 024B     		ldr	r3, .L3
  52 0012 0122     		movs	r2, #1
  53 0014 1A70     		strb	r2, [r3]
  54              	.L2:
  83:.\Generated_Source\PSoC5/UART_1.c ****     }
  84:.\Generated_Source\PSoC5/UART_1.c **** 
  85:.\Generated_Source\PSoC5/UART_1.c ****     UART_1_Enable();
  55              		.loc 1 85 0
  56 0016 FFF7FEFF 		bl	UART_1_Enable
  86:.\Generated_Source\PSoC5/UART_1.c **** }
  57              		.loc 1 86 0
  58 001a 80BD     		pop	{r7, pc}
  59              	.L4:
  60              		.align	2
  61              	.L3:
  62 001c 00000000 		.word	UART_1_initVar
  63              		.cfi_endproc
  64              	.LFE0:
  65              		.size	UART_1_Start, .-UART_1_Start
  66              		.section	.text.UART_1_Init,"ax",%progbits
  67              		.align	2
  68              		.global	UART_1_Init
  69              		.thumb
  70              		.thumb_func
  71              		.type	UART_1_Init, %function
  72              	UART_1_Init:
  73              	.LFB1:
  87:.\Generated_Source\PSoC5/UART_1.c **** 
  88:.\Generated_Source\PSoC5/UART_1.c **** 
  89:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
  90:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Init
  91:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  92:.\Generated_Source\PSoC5/UART_1.c **** *
  93:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
  94:.\Generated_Source\PSoC5/UART_1.c **** *  Initializes or restores the component according to the customizer Configure
  95:.\Generated_Source\PSoC5/UART_1.c **** *  dialog settings. It is not necessary to call UART_1_Init() because
  96:.\Generated_Source\PSoC5/UART_1.c **** *  the UART_1_Start() API calls this function and is the preferred
  97:.\Generated_Source\PSoC5/UART_1.c **** *  method to begin component operation.
  98:.\Generated_Source\PSoC5/UART_1.c **** *
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 4


  99:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 100:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 101:.\Generated_Source\PSoC5/UART_1.c **** *
 102:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 103:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 104:.\Generated_Source\PSoC5/UART_1.c **** *
 105:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 106:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Init(void) 
 107:.\Generated_Source\PSoC5/UART_1.c **** {
  74              		.loc 1 107 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 1, uses_anonymous_args = 0
  78              		@ link register save eliminated.
  79 0000 80B4     		push	{r7}
  80              		.cfi_def_cfa_offset 4
  81              		.cfi_offset 7, -4
  82 0002 00AF     		add	r7, sp, #0
  83              		.cfi_def_cfa_register 7
 108:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 109:.\Generated_Source\PSoC5/UART_1.c **** 
 110:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 111:.\Generated_Source\PSoC5/UART_1.c ****             /* Set RX interrupt vector and priority */
 112:.\Generated_Source\PSoC5/UART_1.c ****             (void) CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 113:.\Generated_Source\PSoC5/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 114:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_errorStatus = 0u;
 115:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 116:.\Generated_Source\PSoC5/UART_1.c **** 
 117:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 118:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RX_ADDRESS_MODE);
 119:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RX_HW_ADDRESS1);
 120:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RX_HW_ADDRESS2);
 121:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 122:.\Generated_Source\PSoC5/UART_1.c **** 
 123:.\Generated_Source\PSoC5/UART_1.c ****         /* Init Count7 period */
 124:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
 125:.\Generated_Source\PSoC5/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 126:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
 127:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 128:.\Generated_Source\PSoC5/UART_1.c **** 
 129:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_ENABLED)
 130:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 131:.\Generated_Source\PSoC5/UART_1.c ****             /* Set TX interrupt vector and priority */
 132:.\Generated_Source\PSoC5/UART_1.c ****             (void) CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 133:.\Generated_Source\PSoC5/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 134:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 135:.\Generated_Source\PSoC5/UART_1.c **** 
 136:.\Generated_Source\PSoC5/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 137:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TXCLKGEN_DP)
 138:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
  84              		.loc 1 138 0
  85 0004 064B     		ldr	r3, .L6
  86 0006 0622     		movs	r2, #6
  87 0008 1A70     		strb	r2, [r3]
 139:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = ((UART_1_NUMBER_OF_DATA_BITS +
  88              		.loc 1 139 0
  89 000a 064B     		ldr	r3, .L6+4
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 5


  90 000c 4722     		movs	r2, #71
  91 000e 1A70     		strb	r2, [r3]
 140:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT) - 1u;
 141:.\Generated_Source\PSoC5/UART_1.c ****         #else
 142:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 143:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 144:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 145:.\Generated_Source\PSoC5/UART_1.c **** 
 146:.\Generated_Source\PSoC5/UART_1.c ****         /* Configure the Initial TX interrupt mask */
 147:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 148:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 149:.\Generated_Source\PSoC5/UART_1.c ****         #else
 150:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
  92              		.loc 1 150 0
  93 0010 054B     		ldr	r3, .L6+8
  94 0012 0022     		movs	r2, #0
  95 0014 1A70     		strb	r2, [r3]
 151:.\Generated_Source\PSoC5/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 152:.\Generated_Source\PSoC5/UART_1.c **** 
 153:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 154:.\Generated_Source\PSoC5/UART_1.c **** 
 155:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 156:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_WriteControlRegister( \
 157:.\Generated_Source\PSoC5/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 158:.\Generated_Source\PSoC5/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 159:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 160:.\Generated_Source\PSoC5/UART_1.c **** }
  96              		.loc 1 160 0
  97 0016 BD46     		mov	sp, r7
  98              		@ sp needed
  99 0018 5DF8047B 		ldr	r7, [sp], #4
 100 001c 7047     		bx	lr
 101              	.L7:
 102 001e 00BF     		.align	2
 103              	.L6:
 104 0020 2B640040 		.word	1073767467
 105 0024 3B640040 		.word	1073767483
 106 0028 8A640040 		.word	1073767562
 107              		.cfi_endproc
 108              	.LFE1:
 109              		.size	UART_1_Init, .-UART_1_Init
 110              		.section	.text.UART_1_Enable,"ax",%progbits
 111              		.align	2
 112              		.global	UART_1_Enable
 113              		.thumb
 114              		.thumb_func
 115              		.type	UART_1_Enable, %function
 116              	UART_1_Enable:
 117              	.LFB2:
 161:.\Generated_Source\PSoC5/UART_1.c **** 
 162:.\Generated_Source\PSoC5/UART_1.c **** 
 163:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 164:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Enable
 165:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 166:.\Generated_Source\PSoC5/UART_1.c **** *
 167:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 168:.\Generated_Source\PSoC5/UART_1.c **** *  Activates the hardware and begins component operation. It is not necessary
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 6


 169:.\Generated_Source\PSoC5/UART_1.c **** *  to call UART_1_Enable() because the UART_1_Start() API
 170:.\Generated_Source\PSoC5/UART_1.c **** *  calls this function, which is the preferred method to begin component
 171:.\Generated_Source\PSoC5/UART_1.c **** *  operation.
 172:.\Generated_Source\PSoC5/UART_1.c **** 
 173:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 174:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 175:.\Generated_Source\PSoC5/UART_1.c **** *
 176:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 177:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 178:.\Generated_Source\PSoC5/UART_1.c **** *
 179:.\Generated_Source\PSoC5/UART_1.c **** * Global Variables:
 180:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 181:.\Generated_Source\PSoC5/UART_1.c **** *
 182:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 183:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Enable(void) 
 184:.\Generated_Source\PSoC5/UART_1.c **** {
 118              		.loc 1 184 0
 119              		.cfi_startproc
 120              		@ args = 0, pretend = 0, frame = 8
 121              		@ frame_needed = 1, uses_anonymous_args = 0
 122 0000 80B5     		push	{r7, lr}
 123              		.cfi_def_cfa_offset 8
 124              		.cfi_offset 7, -8
 125              		.cfi_offset 14, -4
 126 0002 82B0     		sub	sp, sp, #8
 127              		.cfi_def_cfa_offset 16
 128 0004 00AF     		add	r7, sp, #0
 129              		.cfi_def_cfa_register 7
 185:.\Generated_Source\PSoC5/UART_1.c ****     uint8 enableInterrupts;
 186:.\Generated_Source\PSoC5/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 130              		.loc 1 186 0
 131 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 132 000a 0346     		mov	r3, r0
 133 000c FB71     		strb	r3, [r7, #7]
 187:.\Generated_Source\PSoC5/UART_1.c **** 
 188:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 189:.\Generated_Source\PSoC5/UART_1.c ****         /* RX Counter (Count7) Enable */
 190:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 191:.\Generated_Source\PSoC5/UART_1.c **** 
 192:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable the RX Interrupt */
 193:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 194:.\Generated_Source\PSoC5/UART_1.c **** 
 195:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 196:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableRxInt();
 197:.\Generated_Source\PSoC5/UART_1.c **** 
 198:.\Generated_Source\PSoC5/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
 199:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 200:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
 201:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 202:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 203:.\Generated_Source\PSoC5/UART_1.c **** 
 204:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_ENABLED)
 205:.\Generated_Source\PSoC5/UART_1.c ****         /* TX Counter (DP/Count7) Enable */
 206:.\Generated_Source\PSoC5/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 207:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 208:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 209:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 7


 210:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable the TX Interrupt */
 211:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 134              		.loc 1 211 0
 135 000e 084B     		ldr	r3, .L9
 136 0010 074A     		ldr	r2, .L9
 137 0012 1278     		ldrb	r2, [r2]
 138 0014 D2B2     		uxtb	r2, r2
 139 0016 42F01002 		orr	r2, r2, #16
 140 001a D2B2     		uxtb	r2, r2
 141 001c 1A70     		strb	r2, [r3]
 212:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 213:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableTxInt();
 215:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 216:.\Generated_Source\PSoC5/UART_1.c ****      #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 217:.\Generated_Source\PSoC5/UART_1.c **** 
 218:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 219:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_IntClock_Start();  /* Enable the clock */
 142              		.loc 1 219 0
 143 001e FFF7FEFF 		bl	UART_1_IntClock_Start
 220:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 221:.\Generated_Source\PSoC5/UART_1.c **** 
 222:.\Generated_Source\PSoC5/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 144              		.loc 1 222 0
 145 0022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 146 0024 1846     		mov	r0, r3
 147 0026 FFF7FEFF 		bl	CyExitCriticalSection
 223:.\Generated_Source\PSoC5/UART_1.c **** }
 148              		.loc 1 223 0
 149 002a 0837     		adds	r7, r7, #8
 150 002c BD46     		mov	sp, r7
 151              		@ sp needed
 152 002e 80BD     		pop	{r7, pc}
 153              	.L10:
 154              		.align	2
 155              	.L9:
 156 0030 9A640040 		.word	1073767578
 157              		.cfi_endproc
 158              	.LFE2:
 159              		.size	UART_1_Enable, .-UART_1_Enable
 160              		.section	.text.UART_1_Stop,"ax",%progbits
 161              		.align	2
 162              		.global	UART_1_Stop
 163              		.thumb
 164              		.thumb_func
 165              		.type	UART_1_Stop, %function
 166              	UART_1_Stop:
 167              	.LFB3:
 224:.\Generated_Source\PSoC5/UART_1.c **** 
 225:.\Generated_Source\PSoC5/UART_1.c **** 
 226:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 227:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Stop
 228:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 229:.\Generated_Source\PSoC5/UART_1.c **** *
 230:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 231:.\Generated_Source\PSoC5/UART_1.c **** *  Disables the UART operation.
 232:.\Generated_Source\PSoC5/UART_1.c **** *
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 8


 233:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 234:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 235:.\Generated_Source\PSoC5/UART_1.c **** *
 236:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 237:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 238:.\Generated_Source\PSoC5/UART_1.c **** *
 239:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 240:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Stop(void) 
 241:.\Generated_Source\PSoC5/UART_1.c **** {
 168              		.loc 1 241 0
 169              		.cfi_startproc
 170              		@ args = 0, pretend = 0, frame = 8
 171              		@ frame_needed = 1, uses_anonymous_args = 0
 172 0000 80B5     		push	{r7, lr}
 173              		.cfi_def_cfa_offset 8
 174              		.cfi_offset 7, -8
 175              		.cfi_offset 14, -4
 176 0002 82B0     		sub	sp, sp, #8
 177              		.cfi_def_cfa_offset 16
 178 0004 00AF     		add	r7, sp, #0
 179              		.cfi_def_cfa_register 7
 242:.\Generated_Source\PSoC5/UART_1.c ****     uint8 enableInterrupts;
 243:.\Generated_Source\PSoC5/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 180              		.loc 1 243 0
 181 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 182 000a 0346     		mov	r3, r0
 183 000c FB71     		strb	r3, [r7, #7]
 244:.\Generated_Source\PSoC5/UART_1.c **** 
 245:.\Generated_Source\PSoC5/UART_1.c ****     /* Write Bit Counter Disable */
 246:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 247:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 248:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 249:.\Generated_Source\PSoC5/UART_1.c **** 
 250:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_ENABLED)
 251:.\Generated_Source\PSoC5/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 252:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 253:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (!UART_1_TXCLKGEN_DP) */
 254:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 255:.\Generated_Source\PSoC5/UART_1.c **** 
 256:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 257:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_IntClock_Stop();   /* Disable the clock */
 184              		.loc 1 257 0
 185 000e FFF7FEFF 		bl	UART_1_IntClock_Stop
 258:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 259:.\Generated_Source\PSoC5/UART_1.c **** 
 260:.\Generated_Source\PSoC5/UART_1.c ****     /* Disable internal interrupt component */
 261:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 262:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8) ~UART_1_INT_ENABLE;
 263:.\Generated_Source\PSoC5/UART_1.c **** 
 264:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 265:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableRxInt();
 266:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 267:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 268:.\Generated_Source\PSoC5/UART_1.c **** 
 269:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_ENABLED)
 270:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8) ~UART_1_INT_ENABLE;
 186              		.loc 1 270 0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 9


 187 0012 074B     		ldr	r3, .L12
 188 0014 064A     		ldr	r2, .L12
 189 0016 1278     		ldrb	r2, [r2]
 190 0018 D2B2     		uxtb	r2, r2
 191 001a 22F01002 		bic	r2, r2, #16
 192 001e D2B2     		uxtb	r2, r2
 193 0020 1A70     		strb	r2, [r3]
 271:.\Generated_Source\PSoC5/UART_1.c **** 
 272:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 273:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
 274:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 275:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 276:.\Generated_Source\PSoC5/UART_1.c **** 
 277:.\Generated_Source\PSoC5/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 194              		.loc 1 277 0
 195 0022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 196 0024 1846     		mov	r0, r3
 197 0026 FFF7FEFF 		bl	CyExitCriticalSection
 278:.\Generated_Source\PSoC5/UART_1.c **** }
 198              		.loc 1 278 0
 199 002a 0837     		adds	r7, r7, #8
 200 002c BD46     		mov	sp, r7
 201              		@ sp needed
 202 002e 80BD     		pop	{r7, pc}
 203              	.L13:
 204              		.align	2
 205              	.L12:
 206 0030 9A640040 		.word	1073767578
 207              		.cfi_endproc
 208              	.LFE3:
 209              		.size	UART_1_Stop, .-UART_1_Stop
 210              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 211              		.align	2
 212              		.global	UART_1_ReadControlRegister
 213              		.thumb
 214              		.thumb_func
 215              		.type	UART_1_ReadControlRegister, %function
 216              	UART_1_ReadControlRegister:
 217              	.LFB4:
 279:.\Generated_Source\PSoC5/UART_1.c **** 
 280:.\Generated_Source\PSoC5/UART_1.c **** 
 281:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 282:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 283:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 284:.\Generated_Source\PSoC5/UART_1.c **** *
 285:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 286:.\Generated_Source\PSoC5/UART_1.c **** *  Returns the current value of the control register.
 287:.\Generated_Source\PSoC5/UART_1.c **** *
 288:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 289:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 290:.\Generated_Source\PSoC5/UART_1.c **** *
 291:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 292:.\Generated_Source\PSoC5/UART_1.c **** *  Contents of the control register.
 293:.\Generated_Source\PSoC5/UART_1.c **** *
 294:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 295:.\Generated_Source\PSoC5/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 296:.\Generated_Source\PSoC5/UART_1.c **** {
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 10


 218              		.loc 1 296 0
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 0
 221              		@ frame_needed = 1, uses_anonymous_args = 0
 222              		@ link register save eliminated.
 223 0000 80B4     		push	{r7}
 224              		.cfi_def_cfa_offset 4
 225              		.cfi_offset 7, -4
 226 0002 00AF     		add	r7, sp, #0
 227              		.cfi_def_cfa_register 7
 297:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 298:.\Generated_Source\PSoC5/UART_1.c ****         return(0u);
 228              		.loc 1 298 0
 229 0004 0023     		movs	r3, #0
 299:.\Generated_Source\PSoC5/UART_1.c ****     #else
 300:.\Generated_Source\PSoC5/UART_1.c ****         return(UART_1_CONTROL_REG);
 301:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 302:.\Generated_Source\PSoC5/UART_1.c **** }
 230              		.loc 1 302 0
 231 0006 1846     		mov	r0, r3
 232 0008 BD46     		mov	sp, r7
 233              		@ sp needed
 234 000a 5DF8047B 		ldr	r7, [sp], #4
 235 000e 7047     		bx	lr
 236              		.cfi_endproc
 237              	.LFE4:
 238              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 239              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
 240              		.align	2
 241              		.global	UART_1_WriteControlRegister
 242              		.thumb
 243              		.thumb_func
 244              		.type	UART_1_WriteControlRegister, %function
 245              	UART_1_WriteControlRegister:
 246              	.LFB5:
 303:.\Generated_Source\PSoC5/UART_1.c **** 
 304:.\Generated_Source\PSoC5/UART_1.c **** 
 305:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 306:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 307:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 308:.\Generated_Source\PSoC5/UART_1.c **** *
 309:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 310:.\Generated_Source\PSoC5/UART_1.c **** *  Writes an 8-bit value into the control register
 311:.\Generated_Source\PSoC5/UART_1.c **** *
 312:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 313:.\Generated_Source\PSoC5/UART_1.c **** *  control:  control register value
 314:.\Generated_Source\PSoC5/UART_1.c **** *
 315:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 316:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 317:.\Generated_Source\PSoC5/UART_1.c **** *
 318:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 319:.\Generated_Source\PSoC5/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 320:.\Generated_Source\PSoC5/UART_1.c **** {
 247              		.loc 1 320 0
 248              		.cfi_startproc
 249              		@ args = 0, pretend = 0, frame = 8
 250              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 11


 251              		@ link register save eliminated.
 252 0000 80B4     		push	{r7}
 253              		.cfi_def_cfa_offset 4
 254              		.cfi_offset 7, -4
 255 0002 83B0     		sub	sp, sp, #12
 256              		.cfi_def_cfa_offset 16
 257 0004 00AF     		add	r7, sp, #0
 258              		.cfi_def_cfa_register 7
 259 0006 0346     		mov	r3, r0
 260 0008 FB71     		strb	r3, [r7, #7]
 321:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 322:.\Generated_Source\PSoC5/UART_1.c ****         if(0u != control)
 323:.\Generated_Source\PSoC5/UART_1.c ****         {
 324:.\Generated_Source\PSoC5/UART_1.c ****             /* Suppress compiler warning */
 325:.\Generated_Source\PSoC5/UART_1.c ****         }
 326:.\Generated_Source\PSoC5/UART_1.c ****     #else
 327:.\Generated_Source\PSoC5/UART_1.c ****        UART_1_CONTROL_REG = control;
 328:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 329:.\Generated_Source\PSoC5/UART_1.c **** }
 261              		.loc 1 329 0
 262 000a 0C37     		adds	r7, r7, #12
 263 000c BD46     		mov	sp, r7
 264              		@ sp needed
 265 000e 5DF8047B 		ldr	r7, [sp], #4
 266 0012 7047     		bx	lr
 267              		.cfi_endproc
 268              	.LFE5:
 269              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 270              		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 271              		.align	2
 272              		.global	UART_1_SetTxInterruptMode
 273              		.thumb
 274              		.thumb_func
 275              		.type	UART_1_SetTxInterruptMode, %function
 276              	UART_1_SetTxInterruptMode:
 277              	.LFB6:
 330:.\Generated_Source\PSoC5/UART_1.c **** 
 331:.\Generated_Source\PSoC5/UART_1.c **** 
 332:.\Generated_Source\PSoC5/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 333:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 334:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 335:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 336:.\Generated_Source\PSoC5/UART_1.c ****     *
 337:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 338:.\Generated_Source\PSoC5/UART_1.c ****     *  Configures the RX interrupt sources enabled.
 339:.\Generated_Source\PSoC5/UART_1.c ****     *
 340:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 341:.\Generated_Source\PSoC5/UART_1.c ****     *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342:.\Generated_Source\PSoC5/UART_1.c ****     *  bit-field arrangement of the status register. This value must be a 
 343:.\Generated_Source\PSoC5/UART_1.c ****     *  combination of status register bit-masks shown below:
 344:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_PAR_ERROR        Interrupt on parity error.
 346:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_STOP_ERROR       Interrupt on stop error.
 347:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_BREAK            Interrupt on break.
 348:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_OVERRUN          Interrupt on overrun error.
 349:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_ADDR_MATCH       Interrupt on address match.
 350:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_MRKSPC           Interrupt on address detect.
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 12


 351:.\Generated_Source\PSoC5/UART_1.c ****     *
 352:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 353:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 354:.\Generated_Source\PSoC5/UART_1.c ****     *
 355:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 356:.\Generated_Source\PSoC5/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 357:.\Generated_Source\PSoC5/UART_1.c ****     *
 358:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 359:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 360:.\Generated_Source\PSoC5/UART_1.c ****     {
 361:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 362:.\Generated_Source\PSoC5/UART_1.c ****     }
 363:.\Generated_Source\PSoC5/UART_1.c **** 
 364:.\Generated_Source\PSoC5/UART_1.c **** 
 365:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 366:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadRxData
 367:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 368:.\Generated_Source\PSoC5/UART_1.c ****     *
 369:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 370:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the next byte of received data. This function returns data without
 371:.\Generated_Source\PSoC5/UART_1.c ****     *  checking the status. You must check the status separately.
 372:.\Generated_Source\PSoC5/UART_1.c ****     *
 373:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 374:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 375:.\Generated_Source\PSoC5/UART_1.c ****     *
 376:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 377:.\Generated_Source\PSoC5/UART_1.c ****     *  Received data from RX register
 378:.\Generated_Source\PSoC5/UART_1.c ****     *
 379:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 380:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 381:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 382:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify new data.
 383:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 384:.\Generated_Source\PSoC5/UART_1.c ****     *     incremented after each byte has been read from buffer.
 385:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 386:.\Generated_Source\PSoC5/UART_1.c ****     *     in RX ISR.
 387:.\Generated_Source\PSoC5/UART_1.c ****     *
 388:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 389:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 390:.\Generated_Source\PSoC5/UART_1.c ****     *
 391:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 392:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 393:.\Generated_Source\PSoC5/UART_1.c ****     {
 394:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxData;
 395:.\Generated_Source\PSoC5/UART_1.c **** 
 396:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 397:.\Generated_Source\PSoC5/UART_1.c **** 
 398:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locRxBufferRead;
 399:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locRxBufferWrite;
 400:.\Generated_Source\PSoC5/UART_1.c **** 
 401:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt */
 402:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 403:.\Generated_Source\PSoC5/UART_1.c **** 
 404:.\Generated_Source\PSoC5/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 405:.\Generated_Source\PSoC5/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 406:.\Generated_Source\PSoC5/UART_1.c **** 
 407:.\Generated_Source\PSoC5/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 13


 408:.\Generated_Source\PSoC5/UART_1.c ****         {
 409:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 410:.\Generated_Source\PSoC5/UART_1.c ****             locRxBufferRead++;
 411:.\Generated_Source\PSoC5/UART_1.c **** 
 412:.\Generated_Source\PSoC5/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 413:.\Generated_Source\PSoC5/UART_1.c ****             {
 414:.\Generated_Source\PSoC5/UART_1.c ****                 locRxBufferRead = 0u;
 415:.\Generated_Source\PSoC5/UART_1.c ****             }
 416:.\Generated_Source\PSoC5/UART_1.c ****             /* Update the real pointer */
 417:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 418:.\Generated_Source\PSoC5/UART_1.c **** 
 419:.\Generated_Source\PSoC5/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 420:.\Generated_Source\PSoC5/UART_1.c ****             {
 421:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 422:.\Generated_Source\PSoC5/UART_1.c ****                 #if ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u))
 423:.\Generated_Source\PSoC5/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 424:.\Generated_Source\PSoC5/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 425:.\Generated_Source\PSoC5/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 426:.\Generated_Source\PSoC5/UART_1.c ****                         {   /* In Half duplex mode return RX mask only in RX
 427:.\Generated_Source\PSoC5/UART_1.c ****                             *  configuration set, otherwise
 428:.\Generated_Source\PSoC5/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 429:.\Generated_Source\PSoC5/UART_1.c ****                             */
 430:.\Generated_Source\PSoC5/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 431:.\Generated_Source\PSoC5/UART_1.c ****                         }
 432:.\Generated_Source\PSoC5/UART_1.c ****                     #else
 433:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 434:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 435:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u)) */
 436:.\Generated_Source\PSoC5/UART_1.c ****             }
 437:.\Generated_Source\PSoC5/UART_1.c ****         }
 438:.\Generated_Source\PSoC5/UART_1.c ****         else
 439:.\Generated_Source\PSoC5/UART_1.c ****         {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 441:.\Generated_Source\PSoC5/UART_1.c ****         }
 442:.\Generated_Source\PSoC5/UART_1.c **** 
 443:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 444:.\Generated_Source\PSoC5/UART_1.c **** 
 445:.\Generated_Source\PSoC5/UART_1.c ****     #else
 446:.\Generated_Source\PSoC5/UART_1.c **** 
 447:.\Generated_Source\PSoC5/UART_1.c ****         /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448:.\Generated_Source\PSoC5/UART_1.c ****         rxData = UART_1_RXDATA_REG;
 449:.\Generated_Source\PSoC5/UART_1.c **** 
 450:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 451:.\Generated_Source\PSoC5/UART_1.c **** 
 452:.\Generated_Source\PSoC5/UART_1.c ****         return(rxData);
 453:.\Generated_Source\PSoC5/UART_1.c ****     }
 454:.\Generated_Source\PSoC5/UART_1.c **** 
 455:.\Generated_Source\PSoC5/UART_1.c **** 
 456:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 457:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 458:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 459:.\Generated_Source\PSoC5/UART_1.c ****     *
 460:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 461:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the current state of the receiver status register and the software
 462:.\Generated_Source\PSoC5/UART_1.c ****     *  buffer overflow status.
 463:.\Generated_Source\PSoC5/UART_1.c ****     *
 464:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 14


 465:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 466:.\Generated_Source\PSoC5/UART_1.c ****     *
 467:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 468:.\Generated_Source\PSoC5/UART_1.c ****     *  Current state of the status register.
 469:.\Generated_Source\PSoC5/UART_1.c ****     *
 470:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effect:
 471:.\Generated_Source\PSoC5/UART_1.c ****     *  All status register bits are clear-on-read except
 472:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY.
 473:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474:.\Generated_Source\PSoC5/UART_1.c ****     *  register read.
 475:.\Generated_Source\PSoC5/UART_1.c ****     *
 476:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 477:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 478:.\Generated_Source\PSoC5/UART_1.c ****     *   It set to one in RX interrupt when there isn't free space in
 479:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 480:.\Generated_Source\PSoC5/UART_1.c ****     *   and cleared to zero by this API as an
 481:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482:.\Generated_Source\PSoC5/UART_1.c ****     *   bits.
 483:.\Generated_Source\PSoC5/UART_1.c ****     *
 484:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 485:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 486:.\Generated_Source\PSoC5/UART_1.c ****     {
 487:.\Generated_Source\PSoC5/UART_1.c ****         uint8 status;
 488:.\Generated_Source\PSoC5/UART_1.c **** 
 489:.\Generated_Source\PSoC5/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 490:.\Generated_Source\PSoC5/UART_1.c **** 
 491:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 492:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_rxBufferOverflow != 0u)
 493:.\Generated_Source\PSoC5/UART_1.c ****         {
 494:.\Generated_Source\PSoC5/UART_1.c ****             status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 495:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
 496:.\Generated_Source\PSoC5/UART_1.c ****         }
 497:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 498:.\Generated_Source\PSoC5/UART_1.c **** 
 499:.\Generated_Source\PSoC5/UART_1.c ****         return(status);
 500:.\Generated_Source\PSoC5/UART_1.c ****     }
 501:.\Generated_Source\PSoC5/UART_1.c **** 
 502:.\Generated_Source\PSoC5/UART_1.c **** 
 503:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 504:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetChar
 505:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 506:.\Generated_Source\PSoC5/UART_1.c ****     *
 507:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 508:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the last received byte of data. UART_1_GetChar() is
 509:.\Generated_Source\PSoC5/UART_1.c ****     *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510:.\Generated_Source\PSoC5/UART_1.c ****     *  for valid characters and 0 indicates an error occurred or no data is present.
 511:.\Generated_Source\PSoC5/UART_1.c ****     *
 512:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 513:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 514:.\Generated_Source\PSoC5/UART_1.c ****     *
 515:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 516:.\Generated_Source\PSoC5/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517:.\Generated_Source\PSoC5/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 518:.\Generated_Source\PSoC5/UART_1.c ****     *
 519:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 520:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 521:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 15


 522:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify new data.
 523:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 524:.\Generated_Source\PSoC5/UART_1.c ****     *     incremented after each byte has been read from buffer.
 525:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 526:.\Generated_Source\PSoC5/UART_1.c ****     *     in RX ISR.
 527:.\Generated_Source\PSoC5/UART_1.c ****     *
 528:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 529:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 530:.\Generated_Source\PSoC5/UART_1.c ****     *
 531:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 532:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetChar(void) 
 533:.\Generated_Source\PSoC5/UART_1.c ****     {
 534:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxData = 0u;
 535:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxStatus;
 536:.\Generated_Source\PSoC5/UART_1.c **** 
 537:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 538:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locRxBufferRead;
 539:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locRxBufferWrite;
 540:.\Generated_Source\PSoC5/UART_1.c **** 
 541:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt */
 542:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 543:.\Generated_Source\PSoC5/UART_1.c **** 
 544:.\Generated_Source\PSoC5/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 545:.\Generated_Source\PSoC5/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 546:.\Generated_Source\PSoC5/UART_1.c **** 
 547:.\Generated_Source\PSoC5/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548:.\Generated_Source\PSoC5/UART_1.c ****         {
 549:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 550:.\Generated_Source\PSoC5/UART_1.c ****             locRxBufferRead++;
 551:.\Generated_Source\PSoC5/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 552:.\Generated_Source\PSoC5/UART_1.c ****             {
 553:.\Generated_Source\PSoC5/UART_1.c ****                 locRxBufferRead = 0u;
 554:.\Generated_Source\PSoC5/UART_1.c ****             }
 555:.\Generated_Source\PSoC5/UART_1.c ****             /* Update the real pointer */
 556:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 557:.\Generated_Source\PSoC5/UART_1.c **** 
 558:.\Generated_Source\PSoC5/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 559:.\Generated_Source\PSoC5/UART_1.c ****             {
 560:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 561:.\Generated_Source\PSoC5/UART_1.c ****                 #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 562:.\Generated_Source\PSoC5/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 563:.\Generated_Source\PSoC5/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 564:.\Generated_Source\PSoC5/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 565:.\Generated_Source\PSoC5/UART_1.c ****                         {   /* In Half duplex mode return RX mask only if
 566:.\Generated_Source\PSoC5/UART_1.c ****                             *  RX configuration set, otherwise
 567:.\Generated_Source\PSoC5/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 568:.\Generated_Source\PSoC5/UART_1.c ****                             */
 569:.\Generated_Source\PSoC5/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 570:.\Generated_Source\PSoC5/UART_1.c ****                         }
 571:.\Generated_Source\PSoC5/UART_1.c ****                     #else
 572:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 573:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 574:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575:.\Generated_Source\PSoC5/UART_1.c ****             }
 576:.\Generated_Source\PSoC5/UART_1.c **** 
 577:.\Generated_Source\PSoC5/UART_1.c ****         }
 578:.\Generated_Source\PSoC5/UART_1.c ****         else
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 16


 579:.\Generated_Source\PSoC5/UART_1.c ****         {   rxStatus = UART_1_RXSTATUS_REG;
 580:.\Generated_Source\PSoC5/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 581:.\Generated_Source\PSoC5/UART_1.c ****             {   /* Read received data from FIFO */
 582:.\Generated_Source\PSoC5/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 583:.\Generated_Source\PSoC5/UART_1.c ****                 /*Check status on error*/
 584:.\Generated_Source\PSoC5/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 585:.\Generated_Source\PSoC5/UART_1.c ****                                 UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 586:.\Generated_Source\PSoC5/UART_1.c ****                 {
 587:.\Generated_Source\PSoC5/UART_1.c ****                     rxData = 0u;
 588:.\Generated_Source\PSoC5/UART_1.c ****                 }
 589:.\Generated_Source\PSoC5/UART_1.c ****             }
 590:.\Generated_Source\PSoC5/UART_1.c ****         }
 591:.\Generated_Source\PSoC5/UART_1.c **** 
 592:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 593:.\Generated_Source\PSoC5/UART_1.c **** 
 594:.\Generated_Source\PSoC5/UART_1.c ****     #else
 595:.\Generated_Source\PSoC5/UART_1.c **** 
 596:.\Generated_Source\PSoC5/UART_1.c ****         rxStatus =UART_1_RXSTATUS_REG;
 597:.\Generated_Source\PSoC5/UART_1.c ****         if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 598:.\Generated_Source\PSoC5/UART_1.c ****         {
 599:.\Generated_Source\PSoC5/UART_1.c ****             /* Read received data from FIFO */
 600:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 601:.\Generated_Source\PSoC5/UART_1.c **** 
 602:.\Generated_Source\PSoC5/UART_1.c ****             /*Check status on error*/
 603:.\Generated_Source\PSoC5/UART_1.c ****             if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 604:.\Generated_Source\PSoC5/UART_1.c ****                             UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 605:.\Generated_Source\PSoC5/UART_1.c ****             {
 606:.\Generated_Source\PSoC5/UART_1.c ****                 rxData = 0u;
 607:.\Generated_Source\PSoC5/UART_1.c ****             }
 608:.\Generated_Source\PSoC5/UART_1.c ****         }
 609:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 610:.\Generated_Source\PSoC5/UART_1.c **** 
 611:.\Generated_Source\PSoC5/UART_1.c ****         return(rxData);
 612:.\Generated_Source\PSoC5/UART_1.c ****     }
 613:.\Generated_Source\PSoC5/UART_1.c **** 
 614:.\Generated_Source\PSoC5/UART_1.c **** 
 615:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 616:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetByte
 617:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 618:.\Generated_Source\PSoC5/UART_1.c ****     *
 619:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 620:.\Generated_Source\PSoC5/UART_1.c ****     *  Reads UART RX buffer immediately, returns received character and error
 621:.\Generated_Source\PSoC5/UART_1.c ****     *  condition.
 622:.\Generated_Source\PSoC5/UART_1.c ****     *
 623:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 624:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 625:.\Generated_Source\PSoC5/UART_1.c ****     *
 626:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 627:.\Generated_Source\PSoC5/UART_1.c ****     *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628:.\Generated_Source\PSoC5/UART_1.c ****     *  an error has occurred.
 629:.\Generated_Source\PSoC5/UART_1.c ****     *
 630:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 631:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 632:.\Generated_Source\PSoC5/UART_1.c ****     *
 633:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 634:.\Generated_Source\PSoC5/UART_1.c ****     uint16 UART_1_GetByte(void) 
 635:.\Generated_Source\PSoC5/UART_1.c ****     {
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 17


 636:.\Generated_Source\PSoC5/UART_1.c ****         
 637:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 638:.\Generated_Source\PSoC5/UART_1.c ****         uint16 locErrorStatus;
 639:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt */
 640:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 641:.\Generated_Source\PSoC5/UART_1.c ****         locErrorStatus = (uint16)UART_1_errorStatus;
 642:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_errorStatus = 0u;
 643:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 644:.\Generated_Source\PSoC5/UART_1.c ****         return ( (uint16)(locErrorStatus << 8u) | UART_1_ReadRxData() );
 645:.\Generated_Source\PSoC5/UART_1.c ****     #else
 646:.\Generated_Source\PSoC5/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 647:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 648:.\Generated_Source\PSoC5/UART_1.c ****         
 649:.\Generated_Source\PSoC5/UART_1.c ****     }
 650:.\Generated_Source\PSoC5/UART_1.c **** 
 651:.\Generated_Source\PSoC5/UART_1.c **** 
 652:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 653:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 654:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 655:.\Generated_Source\PSoC5/UART_1.c ****     *
 656:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 657:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the number of received bytes available in the RX buffer.
 658:.\Generated_Source\PSoC5/UART_1.c ****     *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659:.\Generated_Source\PSoC5/UART_1.c ****     *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660:.\Generated_Source\PSoC5/UART_1.c ****     *  * RX software buffer is enabled: returns the number of bytes available in 
 661:.\Generated_Source\PSoC5/UART_1.c ****     *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662:.\Generated_Source\PSoC5/UART_1.c ****     *    account.
 663:.\Generated_Source\PSoC5/UART_1.c ****     *
 664:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 665:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 666:.\Generated_Source\PSoC5/UART_1.c ****     *
 667:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 668:.\Generated_Source\PSoC5/UART_1.c ****     *  uint8: Number of bytes in the RX buffer. 
 669:.\Generated_Source\PSoC5/UART_1.c ****     *    Return value type depends on RX Buffer Size parameter.
 670:.\Generated_Source\PSoC5/UART_1.c ****     *
 671:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 672:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 673:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 674:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 675:.\Generated_Source\PSoC5/UART_1.c ****     *
 676:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 677:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 678:.\Generated_Source\PSoC5/UART_1.c ****     *
 679:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 680:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 681:.\Generated_Source\PSoC5/UART_1.c ****     *
 682:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 683:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 684:.\Generated_Source\PSoC5/UART_1.c ****                                                             
 685:.\Generated_Source\PSoC5/UART_1.c ****     {
 686:.\Generated_Source\PSoC5/UART_1.c ****         uint8 size;
 687:.\Generated_Source\PSoC5/UART_1.c **** 
 688:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 689:.\Generated_Source\PSoC5/UART_1.c **** 
 690:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt */
 691:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 692:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 18


 693:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 694:.\Generated_Source\PSoC5/UART_1.c ****         {
 695:.\Generated_Source\PSoC5/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 696:.\Generated_Source\PSoC5/UART_1.c ****             {
 697:.\Generated_Source\PSoC5/UART_1.c ****                 size = UART_1_RX_BUFFER_SIZE;
 698:.\Generated_Source\PSoC5/UART_1.c ****             }
 699:.\Generated_Source\PSoC5/UART_1.c ****             else
 700:.\Generated_Source\PSoC5/UART_1.c ****             {
 701:.\Generated_Source\PSoC5/UART_1.c ****                 size = 0u;
 702:.\Generated_Source\PSoC5/UART_1.c ****             }
 703:.\Generated_Source\PSoC5/UART_1.c ****         }
 704:.\Generated_Source\PSoC5/UART_1.c ****         else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 705:.\Generated_Source\PSoC5/UART_1.c ****         {
 706:.\Generated_Source\PSoC5/UART_1.c ****             size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 707:.\Generated_Source\PSoC5/UART_1.c ****         }
 708:.\Generated_Source\PSoC5/UART_1.c ****         else
 709:.\Generated_Source\PSoC5/UART_1.c ****         {
 710:.\Generated_Source\PSoC5/UART_1.c ****             size = (UART_1_RX_BUFFER_SIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 711:.\Generated_Source\PSoC5/UART_1.c ****         }
 712:.\Generated_Source\PSoC5/UART_1.c **** 
 713:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 714:.\Generated_Source\PSoC5/UART_1.c **** 
 715:.\Generated_Source\PSoC5/UART_1.c ****     #else
 716:.\Generated_Source\PSoC5/UART_1.c **** 
 717:.\Generated_Source\PSoC5/UART_1.c ****         /* We can only know if there is data in the fifo. */
 718:.\Generated_Source\PSoC5/UART_1.c ****         size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 719:.\Generated_Source\PSoC5/UART_1.c **** 
 720:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 721:.\Generated_Source\PSoC5/UART_1.c **** 
 722:.\Generated_Source\PSoC5/UART_1.c ****         return(size);
 723:.\Generated_Source\PSoC5/UART_1.c ****     }
 724:.\Generated_Source\PSoC5/UART_1.c **** 
 725:.\Generated_Source\PSoC5/UART_1.c **** 
 726:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 727:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 728:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 729:.\Generated_Source\PSoC5/UART_1.c ****     *
 730:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 731:.\Generated_Source\PSoC5/UART_1.c ****     *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732:.\Generated_Source\PSoC5/UART_1.c ****     *
 733:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 734:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 735:.\Generated_Source\PSoC5/UART_1.c ****     *
 736:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 737:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 738:.\Generated_Source\PSoC5/UART_1.c ****     *
 739:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 740:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 741:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 742:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 743:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 744:.\Generated_Source\PSoC5/UART_1.c ****     *
 745:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 746:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 747:.\Generated_Source\PSoC5/UART_1.c ****     *
 748:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 749:.\Generated_Source\PSoC5/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 19


 750:.\Generated_Source\PSoC5/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 751:.\Generated_Source\PSoC5/UART_1.c ****     *  have remained in the RAM.
 752:.\Generated_Source\PSoC5/UART_1.c ****     *
 753:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
 754:.\Generated_Source\PSoC5/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 755:.\Generated_Source\PSoC5/UART_1.c ****     *
 756:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 757:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
 758:.\Generated_Source\PSoC5/UART_1.c ****     {
 759:.\Generated_Source\PSoC5/UART_1.c ****         uint8 enableInterrupts;
 760:.\Generated_Source\PSoC5/UART_1.c **** 
 761:.\Generated_Source\PSoC5/UART_1.c ****         /* Clear the HW FIFO */
 762:.\Generated_Source\PSoC5/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 763:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |= (uint8)  UART_1_RX_FIFO_CLR;
 764:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8) ~UART_1_RX_FIFO_CLR;
 765:.\Generated_Source\PSoC5/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 766:.\Generated_Source\PSoC5/UART_1.c **** 
 767:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 768:.\Generated_Source\PSoC5/UART_1.c **** 
 769:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt. */
 770:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 771:.\Generated_Source\PSoC5/UART_1.c **** 
 772:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_rxBufferRead = 0u;
 773:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_rxBufferWrite = 0u;
 774:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_rxBufferLoopDetect = 0u;
 775:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_rxBufferOverflow = 0u;
 776:.\Generated_Source\PSoC5/UART_1.c **** 
 777:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 778:.\Generated_Source\PSoC5/UART_1.c **** 
 779:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 780:.\Generated_Source\PSoC5/UART_1.c **** 
 781:.\Generated_Source\PSoC5/UART_1.c ****     }
 782:.\Generated_Source\PSoC5/UART_1.c **** 
 783:.\Generated_Source\PSoC5/UART_1.c **** 
 784:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 785:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 786:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 787:.\Generated_Source\PSoC5/UART_1.c ****     *
 788:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 789:.\Generated_Source\PSoC5/UART_1.c ****     *  Sets the software controlled Addressing mode used by the RX portion of the
 790:.\Generated_Source\PSoC5/UART_1.c ****     *  UART.
 791:.\Generated_Source\PSoC5/UART_1.c ****     *
 792:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 793:.\Generated_Source\PSoC5/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 794:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795:.\Generated_Source\PSoC5/UART_1.c ****     *                                               detection
 796:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797:.\Generated_Source\PSoC5/UART_1.c ****     *                                               address detection
 798:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799:.\Generated_Source\PSoC5/UART_1.c ****     *                                               detection
 800:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801:.\Generated_Source\PSoC5/UART_1.c ****     *                                               address detection
 802:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 803:.\Generated_Source\PSoC5/UART_1.c ****     *
 804:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 805:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 806:.\Generated_Source\PSoC5/UART_1.c ****     *
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 20


 807:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 808:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 809:.\Generated_Source\PSoC5/UART_1.c ****     *   the farther usage in RX ISR.
 810:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 811:.\Generated_Source\PSoC5/UART_1.c ****     *
 812:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 813:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 814:.\Generated_Source\PSoC5/UART_1.c ****                                                         
 815:.\Generated_Source\PSoC5/UART_1.c ****     {
 816:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 817:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 818:.\Generated_Source\PSoC5/UART_1.c ****                 if(0u != addressMode)
 819:.\Generated_Source\PSoC5/UART_1.c ****                 {
 820:.\Generated_Source\PSoC5/UART_1.c ****                     /* Suppress compiler warning */
 821:.\Generated_Source\PSoC5/UART_1.c ****                 }
 822:.\Generated_Source\PSoC5/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 823:.\Generated_Source\PSoC5/UART_1.c ****                 uint8 tmpCtrl;
 824:.\Generated_Source\PSoC5/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 825:.\Generated_Source\PSoC5/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 826:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 827:.\Generated_Source\PSoC5/UART_1.c **** 
 828:.\Generated_Source\PSoC5/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 829:.\Generated_Source\PSoC5/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 830:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
 831:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 832:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 833:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 834:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 835:.\Generated_Source\PSoC5/UART_1.c ****             if(0u != addressMode)
 836:.\Generated_Source\PSoC5/UART_1.c ****             {
 837:.\Generated_Source\PSoC5/UART_1.c ****                 /* Suppress compiler warning */
 838:.\Generated_Source\PSoC5/UART_1.c ****             }
 839:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 840:.\Generated_Source\PSoC5/UART_1.c ****     }
 841:.\Generated_Source\PSoC5/UART_1.c **** 
 842:.\Generated_Source\PSoC5/UART_1.c **** 
 843:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 844:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
 845:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 846:.\Generated_Source\PSoC5/UART_1.c ****     *
 847:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 848:.\Generated_Source\PSoC5/UART_1.c ****     *  Sets the first of two hardware-detectable receiver addresses.
 849:.\Generated_Source\PSoC5/UART_1.c ****     *
 850:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 851:.\Generated_Source\PSoC5/UART_1.c ****     *  address: Address #1 for hardware address detection.
 852:.\Generated_Source\PSoC5/UART_1.c ****     *
 853:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 854:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 855:.\Generated_Source\PSoC5/UART_1.c ****     *
 856:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 857:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 858:.\Generated_Source\PSoC5/UART_1.c ****     {
 859:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 860:.\Generated_Source\PSoC5/UART_1.c ****     }
 861:.\Generated_Source\PSoC5/UART_1.c **** 
 862:.\Generated_Source\PSoC5/UART_1.c **** 
 863:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 21


 864:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 865:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 866:.\Generated_Source\PSoC5/UART_1.c ****     *
 867:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 868:.\Generated_Source\PSoC5/UART_1.c ****     *  Sets the second of two hardware-detectable receiver addresses.
 869:.\Generated_Source\PSoC5/UART_1.c ****     *
 870:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 871:.\Generated_Source\PSoC5/UART_1.c ****     *  address: Address #2 for hardware address detection.
 872:.\Generated_Source\PSoC5/UART_1.c ****     *
 873:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 874:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 875:.\Generated_Source\PSoC5/UART_1.c ****     *
 876:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 877:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 878:.\Generated_Source\PSoC5/UART_1.c ****     {
 879:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 880:.\Generated_Source\PSoC5/UART_1.c ****     }
 881:.\Generated_Source\PSoC5/UART_1.c **** 
 882:.\Generated_Source\PSoC5/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 883:.\Generated_Source\PSoC5/UART_1.c **** 
 884:.\Generated_Source\PSoC5/UART_1.c **** 
 885:.\Generated_Source\PSoC5/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 886:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 887:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
 888:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 889:.\Generated_Source\PSoC5/UART_1.c ****     *
 890:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 891:.\Generated_Source\PSoC5/UART_1.c ****     *  Configures the TX interrupt sources to be enabled, but does not enable the
 892:.\Generated_Source\PSoC5/UART_1.c ****     *  interrupt.
 893:.\Generated_Source\PSoC5/UART_1.c ****     *
 894:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 895:.\Generated_Source\PSoC5/UART_1.c ****     *  intSrc: Bit field containing the TX interrupt sources to enable
 896:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_TX_STS_COMPLETE        Interrupt on TX byte complete
 897:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900:.\Generated_Source\PSoC5/UART_1.c ****     *
 901:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 902:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 903:.\Generated_Source\PSoC5/UART_1.c ****     *
 904:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 905:.\Generated_Source\PSoC5/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 906:.\Generated_Source\PSoC5/UART_1.c ****     *
 907:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 908:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
 909:.\Generated_Source\PSoC5/UART_1.c ****     {
 278              		.loc 1 909 0
 279              		.cfi_startproc
 280              		@ args = 0, pretend = 0, frame = 8
 281              		@ frame_needed = 1, uses_anonymous_args = 0
 282              		@ link register save eliminated.
 283 0000 80B4     		push	{r7}
 284              		.cfi_def_cfa_offset 4
 285              		.cfi_offset 7, -4
 286 0002 83B0     		sub	sp, sp, #12
 287              		.cfi_def_cfa_offset 16
 288 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 22


 289              		.cfi_def_cfa_register 7
 290 0006 0346     		mov	r3, r0
 291 0008 FB71     		strb	r3, [r7, #7]
 910:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 292              		.loc 1 910 0
 293 000a 044B     		ldr	r3, .L18
 294 000c FA79     		ldrb	r2, [r7, #7]
 295 000e 1A70     		strb	r2, [r3]
 911:.\Generated_Source\PSoC5/UART_1.c ****     }
 296              		.loc 1 911 0
 297 0010 0C37     		adds	r7, r7, #12
 298 0012 BD46     		mov	sp, r7
 299              		@ sp needed
 300 0014 5DF8047B 		ldr	r7, [sp], #4
 301 0018 7047     		bx	lr
 302              	.L19:
 303 001a 00BF     		.align	2
 304              	.L18:
 305 001c 8A640040 		.word	1073767562
 306              		.cfi_endproc
 307              	.LFE6:
 308              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 309              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 310              		.align	2
 311              		.global	UART_1_WriteTxData
 312              		.thumb
 313              		.thumb_func
 314              		.type	UART_1_WriteTxData, %function
 315              	UART_1_WriteTxData:
 316              	.LFB7:
 912:.\Generated_Source\PSoC5/UART_1.c **** 
 913:.\Generated_Source\PSoC5/UART_1.c **** 
 914:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 915:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_WriteTxData
 916:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 917:.\Generated_Source\PSoC5/UART_1.c ****     *
 918:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 919:.\Generated_Source\PSoC5/UART_1.c ****     *  Places a byte of data into the transmit buffer to be sent when the bus is
 920:.\Generated_Source\PSoC5/UART_1.c ****     *  available without checking the TX status register. You must check status
 921:.\Generated_Source\PSoC5/UART_1.c ****     *  separately.
 922:.\Generated_Source\PSoC5/UART_1.c ****     *
 923:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 924:.\Generated_Source\PSoC5/UART_1.c ****     *  txDataByte: data byte
 925:.\Generated_Source\PSoC5/UART_1.c ****     *
 926:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 927:.\Generated_Source\PSoC5/UART_1.c ****     * None.
 928:.\Generated_Source\PSoC5/UART_1.c ****     *
 929:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 930:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 931:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 932:.\Generated_Source\PSoC5/UART_1.c ****     *    incremented after each byte saved to buffer.
 933:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 934:.\Generated_Source\PSoC5/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 935:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 936:.\Generated_Source\PSoC5/UART_1.c ****     *    initialized.
 937:.\Generated_Source\PSoC5/UART_1.c ****     *
 938:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 23


 939:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 940:.\Generated_Source\PSoC5/UART_1.c ****     *
 941:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 942:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
 943:.\Generated_Source\PSoC5/UART_1.c ****     {
 317              		.loc 1 943 0
 318              		.cfi_startproc
 319              		@ args = 0, pretend = 0, frame = 8
 320              		@ frame_needed = 1, uses_anonymous_args = 0
 321              		@ link register save eliminated.
 322 0000 80B4     		push	{r7}
 323              		.cfi_def_cfa_offset 4
 324              		.cfi_offset 7, -4
 325 0002 83B0     		sub	sp, sp, #12
 326              		.cfi_def_cfa_offset 16
 327 0004 00AF     		add	r7, sp, #0
 328              		.cfi_def_cfa_register 7
 329 0006 0346     		mov	r3, r0
 330 0008 FB71     		strb	r3, [r7, #7]
 944:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
 945:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 331              		.loc 1 945 0
 332 000a 064B     		ldr	r3, .L22
 333 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 334 000e 002B     		cmp	r3, #0
 335 0010 02D0     		beq	.L20
 946:.\Generated_Source\PSoC5/UART_1.c ****         {
 947:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 948:.\Generated_Source\PSoC5/UART_1.c **** 
 949:.\Generated_Source\PSoC5/UART_1.c ****             /* Protect variables that could change on interrupt. */
 950:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
 951:.\Generated_Source\PSoC5/UART_1.c **** 
 952:.\Generated_Source\PSoC5/UART_1.c ****             if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
 953:.\Generated_Source\PSoC5/UART_1.c ****                 ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
 954:.\Generated_Source\PSoC5/UART_1.c ****             {
 955:.\Generated_Source\PSoC5/UART_1.c ****                 /* Add directly to the FIFO. */
 956:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 957:.\Generated_Source\PSoC5/UART_1.c ****             }
 958:.\Generated_Source\PSoC5/UART_1.c ****             else
 959:.\Generated_Source\PSoC5/UART_1.c ****             {
 960:.\Generated_Source\PSoC5/UART_1.c ****                 if(UART_1_txBufferWrite >= UART_1_TX_BUFFER_SIZE)
 961:.\Generated_Source\PSoC5/UART_1.c ****                 {
 962:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_txBufferWrite = 0u;
 963:.\Generated_Source\PSoC5/UART_1.c ****                 }
 964:.\Generated_Source\PSoC5/UART_1.c **** 
 965:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
 966:.\Generated_Source\PSoC5/UART_1.c **** 
 967:.\Generated_Source\PSoC5/UART_1.c ****                 /* Add to the software buffer. */
 968:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_txBufferWrite++;
 969:.\Generated_Source\PSoC5/UART_1.c ****             }
 970:.\Generated_Source\PSoC5/UART_1.c **** 
 971:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableTxInt();
 972:.\Generated_Source\PSoC5/UART_1.c **** 
 973:.\Generated_Source\PSoC5/UART_1.c ****         #else
 974:.\Generated_Source\PSoC5/UART_1.c **** 
 975:.\Generated_Source\PSoC5/UART_1.c ****             /* Add directly to the FIFO. */
 976:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 24


 336              		.loc 1 976 0
 337 0012 054B     		ldr	r3, .L22+4
 338 0014 FA79     		ldrb	r2, [r7, #7]
 339 0016 1A70     		strb	r2, [r3]
 340              	.L20:
 977:.\Generated_Source\PSoC5/UART_1.c **** 
 978:.\Generated_Source\PSoC5/UART_1.c ****         #endif /*(UART_1_TX_INTERRUPT_ENABLED) */
 979:.\Generated_Source\PSoC5/UART_1.c ****         }
 980:.\Generated_Source\PSoC5/UART_1.c ****     }
 341              		.loc 1 980 0
 342 0018 0C37     		adds	r7, r7, #12
 343 001a BD46     		mov	sp, r7
 344              		@ sp needed
 345 001c 5DF8047B 		ldr	r7, [sp], #4
 346 0020 7047     		bx	lr
 347              	.L23:
 348 0022 00BF     		.align	2
 349              	.L22:
 350 0024 00000000 		.word	UART_1_initVar
 351 0028 4A640040 		.word	1073767498
 352              		.cfi_endproc
 353              	.LFE7:
 354              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
 355              		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 356              		.align	2
 357              		.global	UART_1_ReadTxStatus
 358              		.thumb
 359              		.thumb_func
 360              		.type	UART_1_ReadTxStatus, %function
 361              	UART_1_ReadTxStatus:
 362              	.LFB8:
 981:.\Generated_Source\PSoC5/UART_1.c **** 
 982:.\Generated_Source\PSoC5/UART_1.c **** 
 983:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 984:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
 985:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 986:.\Generated_Source\PSoC5/UART_1.c ****     *
 987:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 988:.\Generated_Source\PSoC5/UART_1.c ****     *  Reads the status register for the TX portion of the UART.
 989:.\Generated_Source\PSoC5/UART_1.c ****     *
 990:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 991:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 992:.\Generated_Source\PSoC5/UART_1.c ****     *
 993:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 994:.\Generated_Source\PSoC5/UART_1.c ****     *  Contents of the status register
 995:.\Generated_Source\PSoC5/UART_1.c ****     *
 996:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 997:.\Generated_Source\PSoC5/UART_1.c ****     *  This function reads the TX status register, which is cleared on read.
 998:.\Generated_Source\PSoC5/UART_1.c ****     *  It is up to the user to handle all bits in this return value accordingly,
 999:.\Generated_Source\PSoC5/UART_1.c ****     *  even if the bit was not enabled as an interrupt source the event happened
1000:.\Generated_Source\PSoC5/UART_1.c ****     *  and must be handled accordingly.
1001:.\Generated_Source\PSoC5/UART_1.c ****     *
1002:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1003:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
1004:.\Generated_Source\PSoC5/UART_1.c ****     {
 363              		.loc 1 1004 0
 364              		.cfi_startproc
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 25


 365              		@ args = 0, pretend = 0, frame = 0
 366              		@ frame_needed = 1, uses_anonymous_args = 0
 367              		@ link register save eliminated.
 368 0000 80B4     		push	{r7}
 369              		.cfi_def_cfa_offset 4
 370              		.cfi_offset 7, -4
 371 0002 00AF     		add	r7, sp, #0
 372              		.cfi_def_cfa_register 7
1005:.\Generated_Source\PSoC5/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 373              		.loc 1 1005 0
 374 0004 034B     		ldr	r3, .L26
 375 0006 1B78     		ldrb	r3, [r3]
 376 0008 DBB2     		uxtb	r3, r3
1006:.\Generated_Source\PSoC5/UART_1.c ****     }
 377              		.loc 1 1006 0
 378 000a 1846     		mov	r0, r3
 379 000c BD46     		mov	sp, r7
 380              		@ sp needed
 381 000e 5DF8047B 		ldr	r7, [sp], #4
 382 0012 7047     		bx	lr
 383              	.L27:
 384              		.align	2
 385              	.L26:
 386 0014 6A640040 		.word	1073767530
 387              		.cfi_endproc
 388              	.LFE8:
 389              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 390              		.section	.text.UART_1_PutChar,"ax",%progbits
 391              		.align	2
 392              		.global	UART_1_PutChar
 393              		.thumb
 394              		.thumb_func
 395              		.type	UART_1_PutChar, %function
 396              	UART_1_PutChar:
 397              	.LFB9:
1007:.\Generated_Source\PSoC5/UART_1.c **** 
1008:.\Generated_Source\PSoC5/UART_1.c **** 
1009:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1010:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutChar
1011:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1012:.\Generated_Source\PSoC5/UART_1.c ****     *
1013:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1014:.\Generated_Source\PSoC5/UART_1.c ****     *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015:.\Generated_Source\PSoC5/UART_1.c ****     *  available. This is a blocking API that waits until the TX buffer has room to
1016:.\Generated_Source\PSoC5/UART_1.c ****     *  hold the data.
1017:.\Generated_Source\PSoC5/UART_1.c ****     *
1018:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1019:.\Generated_Source\PSoC5/UART_1.c ****     *  txDataByte: Byte containing the data to transmit
1020:.\Generated_Source\PSoC5/UART_1.c ****     *
1021:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1022:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1023:.\Generated_Source\PSoC5/UART_1.c ****     *
1024:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1025:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1026:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1027:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1028:.\Generated_Source\PSoC5/UART_1.c ****     *     saved to buffer.
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 26


1029:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1030:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify free space in txBuffer.
1031:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1032:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1033:.\Generated_Source\PSoC5/UART_1.c ****     *
1034:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1035:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1036:.\Generated_Source\PSoC5/UART_1.c ****     *
1037:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1038:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1039:.\Generated_Source\PSoC5/UART_1.c ****     *
1040:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1041:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1042:.\Generated_Source\PSoC5/UART_1.c ****     {
 398              		.loc 1 1042 0
 399              		.cfi_startproc
 400              		@ args = 0, pretend = 0, frame = 8
 401              		@ frame_needed = 1, uses_anonymous_args = 0
 402              		@ link register save eliminated.
 403 0000 80B4     		push	{r7}
 404              		.cfi_def_cfa_offset 4
 405              		.cfi_offset 7, -4
 406 0002 83B0     		sub	sp, sp, #12
 407              		.cfi_def_cfa_offset 16
 408 0004 00AF     		add	r7, sp, #0
 409              		.cfi_def_cfa_register 7
 410 0006 0346     		mov	r3, r0
 411 0008 FB71     		strb	r3, [r7, #7]
1043:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1044:.\Generated_Source\PSoC5/UART_1.c ****         /* The temporary output pointer is used since it takes two instructions
1045:.\Generated_Source\PSoC5/UART_1.c ****         *  to increment with a wrap, and we can't risk doing that with the real
1046:.\Generated_Source\PSoC5/UART_1.c ****         *  pointer and getting an interrupt in between instructions.
1047:.\Generated_Source\PSoC5/UART_1.c ****         */
1048:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locTxBufferWrite;
1049:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locTxBufferRead;
1050:.\Generated_Source\PSoC5/UART_1.c **** 
1051:.\Generated_Source\PSoC5/UART_1.c ****         do
1052:.\Generated_Source\PSoC5/UART_1.c ****         { /* Block if software buffer is full, so we don't overwrite. */
1053:.\Generated_Source\PSoC5/UART_1.c **** 
1054:.\Generated_Source\PSoC5/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1055:.\Generated_Source\PSoC5/UART_1.c ****             /* Disable TX interrupt to protect variables from modification */
1056:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
1057:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1058:.\Generated_Source\PSoC5/UART_1.c **** 
1059:.\Generated_Source\PSoC5/UART_1.c ****             locTxBufferWrite = UART_1_txBufferWrite;
1060:.\Generated_Source\PSoC5/UART_1.c ****             locTxBufferRead  = UART_1_txBufferRead;
1061:.\Generated_Source\PSoC5/UART_1.c **** 
1062:.\Generated_Source\PSoC5/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1063:.\Generated_Source\PSoC5/UART_1.c ****             /* Enable interrupt to continue transmission */
1064:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableTxInt();
1065:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1066:.\Generated_Source\PSoC5/UART_1.c ****         }
1067:.\Generated_Source\PSoC5/UART_1.c ****         while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) 
1068:.\Generated_Source\PSoC5/UART_1.c ****                                 ((locTxBufferWrite - locTxBufferRead) ==
1069:.\Generated_Source\PSoC5/UART_1.c ****                                 (uint8)(UART_1_TX_BUFFER_SIZE - 1u)) );
1070:.\Generated_Source\PSoC5/UART_1.c **** 
1071:.\Generated_Source\PSoC5/UART_1.c ****         if( (locTxBufferRead == locTxBufferWrite) &&
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 27


1072:.\Generated_Source\PSoC5/UART_1.c ****             ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1073:.\Generated_Source\PSoC5/UART_1.c ****         {
1074:.\Generated_Source\PSoC5/UART_1.c ****             /* Add directly to the FIFO */
1075:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
1076:.\Generated_Source\PSoC5/UART_1.c ****         }
1077:.\Generated_Source\PSoC5/UART_1.c ****         else
1078:.\Generated_Source\PSoC5/UART_1.c ****         {
1079:.\Generated_Source\PSoC5/UART_1.c ****             if(locTxBufferWrite >= UART_1_TX_BUFFER_SIZE)
1080:.\Generated_Source\PSoC5/UART_1.c ****             {
1081:.\Generated_Source\PSoC5/UART_1.c ****                 locTxBufferWrite = 0u;
1082:.\Generated_Source\PSoC5/UART_1.c ****             }
1083:.\Generated_Source\PSoC5/UART_1.c ****             /* Add to the software buffer. */
1084:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_txBuffer[locTxBufferWrite] = txDataByte;
1085:.\Generated_Source\PSoC5/UART_1.c ****             locTxBufferWrite++;
1086:.\Generated_Source\PSoC5/UART_1.c **** 
1087:.\Generated_Source\PSoC5/UART_1.c ****             /* Finally, update the real output pointer */
1088:.\Generated_Source\PSoC5/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1089:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
1090:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1091:.\Generated_Source\PSoC5/UART_1.c **** 
1092:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_txBufferWrite = locTxBufferWrite;
1093:.\Generated_Source\PSoC5/UART_1.c **** 
1094:.\Generated_Source\PSoC5/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1095:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableTxInt();
1096:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1097:.\Generated_Source\PSoC5/UART_1.c **** 
1098:.\Generated_Source\PSoC5/UART_1.c ****             if(0u != (UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_EMPTY))
1099:.\Generated_Source\PSoC5/UART_1.c ****             {
1100:.\Generated_Source\PSoC5/UART_1.c ****                 /* Trigger TX interrupt to send software buffer */
1101:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_SetPendingTxInt();
1102:.\Generated_Source\PSoC5/UART_1.c ****             }
1103:.\Generated_Source\PSoC5/UART_1.c ****         }
1104:.\Generated_Source\PSoC5/UART_1.c **** 
1105:.\Generated_Source\PSoC5/UART_1.c ****     #else
1106:.\Generated_Source\PSoC5/UART_1.c **** 
1107:.\Generated_Source\PSoC5/UART_1.c ****         while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 412              		.loc 1 1107 0
 413 000a 00BF     		nop
 414              	.L29:
 415              		.loc 1 1107 0 is_stmt 0 discriminator 1
 416 000c 074B     		ldr	r3, .L30
 417 000e 1B78     		ldrb	r3, [r3]
 418 0010 DBB2     		uxtb	r3, r3
 419 0012 03F00403 		and	r3, r3, #4
 420 0016 002B     		cmp	r3, #0
 421 0018 F8D1     		bne	.L29
1108:.\Generated_Source\PSoC5/UART_1.c ****         {
1109:.\Generated_Source\PSoC5/UART_1.c ****             /* Wait for room in the FIFO */
1110:.\Generated_Source\PSoC5/UART_1.c ****         }
1111:.\Generated_Source\PSoC5/UART_1.c **** 
1112:.\Generated_Source\PSoC5/UART_1.c ****         /* Add directly to the FIFO */
1113:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXDATA_REG = txDataByte;
 422              		.loc 1 1113 0 is_stmt 1
 423 001a 054B     		ldr	r3, .L30+4
 424 001c FA79     		ldrb	r2, [r7, #7]
 425 001e 1A70     		strb	r2, [r3]
1114:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 28


1115:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End (UART_1_TX_INTERRUPT_ENABLED) */
1116:.\Generated_Source\PSoC5/UART_1.c ****     }
 426              		.loc 1 1116 0
 427 0020 0C37     		adds	r7, r7, #12
 428 0022 BD46     		mov	sp, r7
 429              		@ sp needed
 430 0024 5DF8047B 		ldr	r7, [sp], #4
 431 0028 7047     		bx	lr
 432              	.L31:
 433 002a 00BF     		.align	2
 434              	.L30:
 435 002c 6A640040 		.word	1073767530
 436 0030 4A640040 		.word	1073767498
 437              		.cfi_endproc
 438              	.LFE9:
 439              		.size	UART_1_PutChar, .-UART_1_PutChar
 440              		.section	.text.UART_1_PutString,"ax",%progbits
 441              		.align	2
 442              		.global	UART_1_PutString
 443              		.thumb
 444              		.thumb_func
 445              		.type	UART_1_PutString, %function
 446              	UART_1_PutString:
 447              	.LFB10:
1117:.\Generated_Source\PSoC5/UART_1.c **** 
1118:.\Generated_Source\PSoC5/UART_1.c **** 
1119:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1120:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutString
1121:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1122:.\Generated_Source\PSoC5/UART_1.c ****     *
1123:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1124:.\Generated_Source\PSoC5/UART_1.c ****     *  Sends a NULL terminated string to the TX buffer for transmission.
1125:.\Generated_Source\PSoC5/UART_1.c ****     *
1126:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1127:.\Generated_Source\PSoC5/UART_1.c ****     *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128:.\Generated_Source\PSoC5/UART_1.c ****     *
1129:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1130:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1131:.\Generated_Source\PSoC5/UART_1.c ****     *
1132:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1133:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1134:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1135:.\Generated_Source\PSoC5/UART_1.c ****     *
1136:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1137:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1138:.\Generated_Source\PSoC5/UART_1.c ****     *
1139:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1140:.\Generated_Source\PSoC5/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1141:.\Generated_Source\PSoC5/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1142:.\Generated_Source\PSoC5/UART_1.c ****     *  TX buffer.
1143:.\Generated_Source\PSoC5/UART_1.c ****     *
1144:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1145:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1146:.\Generated_Source\PSoC5/UART_1.c ****     {
 448              		.loc 1 1146 0
 449              		.cfi_startproc
 450              		@ args = 0, pretend = 0, frame = 16
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 29


 451              		@ frame_needed = 1, uses_anonymous_args = 0
 452 0000 80B5     		push	{r7, lr}
 453              		.cfi_def_cfa_offset 8
 454              		.cfi_offset 7, -8
 455              		.cfi_offset 14, -4
 456 0002 84B0     		sub	sp, sp, #16
 457              		.cfi_def_cfa_offset 24
 458 0004 00AF     		add	r7, sp, #0
 459              		.cfi_def_cfa_register 7
 460 0006 7860     		str	r0, [r7, #4]
1147:.\Generated_Source\PSoC5/UART_1.c ****         uint16 bufIndex = 0u;
 461              		.loc 1 1147 0
 462 0008 0023     		movs	r3, #0
 463 000a FB81     		strh	r3, [r7, #14]	@ movhi
1148:.\Generated_Source\PSoC5/UART_1.c **** 
1149:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function */
1150:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 464              		.loc 1 1150 0
 465 000c 0B4B     		ldr	r3, .L36
 466 000e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 467 0010 002B     		cmp	r3, #0
 468 0012 10D0     		beq	.L32
1151:.\Generated_Source\PSoC5/UART_1.c ****         {
1152:.\Generated_Source\PSoC5/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent */
1153:.\Generated_Source\PSoC5/UART_1.c ****             while(string[bufIndex] != (char8) 0)
 469              		.loc 1 1153 0
 470 0014 09E0     		b	.L34
 471              	.L35:
1154:.\Generated_Source\PSoC5/UART_1.c ****             {
1155:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_PutChar((uint8)string[bufIndex]);
 472              		.loc 1 1155 0
 473 0016 FB89     		ldrh	r3, [r7, #14]
 474 0018 7A68     		ldr	r2, [r7, #4]
 475 001a 1344     		add	r3, r3, r2
 476 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 477 001e 1846     		mov	r0, r3
 478 0020 FFF7FEFF 		bl	UART_1_PutChar
1156:.\Generated_Source\PSoC5/UART_1.c ****                 bufIndex++;
 479              		.loc 1 1156 0
 480 0024 FB89     		ldrh	r3, [r7, #14]
 481 0026 0133     		adds	r3, r3, #1
 482 0028 FB81     		strh	r3, [r7, #14]	@ movhi
 483              	.L34:
1153:.\Generated_Source\PSoC5/UART_1.c ****             while(string[bufIndex] != (char8) 0)
 484              		.loc 1 1153 0 discriminator 1
 485 002a FB89     		ldrh	r3, [r7, #14]
 486 002c 7A68     		ldr	r2, [r7, #4]
 487 002e 1344     		add	r3, r3, r2
 488 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 489 0032 002B     		cmp	r3, #0
 490 0034 EFD1     		bne	.L35
 491              	.L32:
1157:.\Generated_Source\PSoC5/UART_1.c ****             }
1158:.\Generated_Source\PSoC5/UART_1.c ****         }
1159:.\Generated_Source\PSoC5/UART_1.c ****     }
 492              		.loc 1 1159 0
 493 0036 1037     		adds	r7, r7, #16
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 30


 494 0038 BD46     		mov	sp, r7
 495              		@ sp needed
 496 003a 80BD     		pop	{r7, pc}
 497              	.L37:
 498              		.align	2
 499              	.L36:
 500 003c 00000000 		.word	UART_1_initVar
 501              		.cfi_endproc
 502              	.LFE10:
 503              		.size	UART_1_PutString, .-UART_1_PutString
 504              		.section	.text.UART_1_PutArray,"ax",%progbits
 505              		.align	2
 506              		.global	UART_1_PutArray
 507              		.thumb
 508              		.thumb_func
 509              		.type	UART_1_PutArray, %function
 510              	UART_1_PutArray:
 511              	.LFB11:
1160:.\Generated_Source\PSoC5/UART_1.c **** 
1161:.\Generated_Source\PSoC5/UART_1.c **** 
1162:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1163:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutArray
1164:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1165:.\Generated_Source\PSoC5/UART_1.c ****     *
1166:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1167:.\Generated_Source\PSoC5/UART_1.c ****     *  Places N bytes of data from a memory array into the TX buffer for
1168:.\Generated_Source\PSoC5/UART_1.c ****     *  transmission.
1169:.\Generated_Source\PSoC5/UART_1.c ****     *
1170:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1171:.\Generated_Source\PSoC5/UART_1.c ****     *  string[]: Address of the memory array residing in RAM or ROM.
1172:.\Generated_Source\PSoC5/UART_1.c ****     *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173:.\Generated_Source\PSoC5/UART_1.c ****     *             Size parameter.
1174:.\Generated_Source\PSoC5/UART_1.c ****     *
1175:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1176:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1177:.\Generated_Source\PSoC5/UART_1.c ****     *
1178:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1179:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1180:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1181:.\Generated_Source\PSoC5/UART_1.c ****     *
1182:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1183:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1184:.\Generated_Source\PSoC5/UART_1.c ****     *
1185:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1186:.\Generated_Source\PSoC5/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1187:.\Generated_Source\PSoC5/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1188:.\Generated_Source\PSoC5/UART_1.c ****     *  TX buffer.
1189:.\Generated_Source\PSoC5/UART_1.c ****     *
1190:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1191:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1192:.\Generated_Source\PSoC5/UART_1.c ****                                                                     
1193:.\Generated_Source\PSoC5/UART_1.c ****     {
 512              		.loc 1 1193 0
 513              		.cfi_startproc
 514              		@ args = 0, pretend = 0, frame = 16
 515              		@ frame_needed = 1, uses_anonymous_args = 0
 516 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 31


 517              		.cfi_def_cfa_offset 8
 518              		.cfi_offset 7, -8
 519              		.cfi_offset 14, -4
 520 0002 84B0     		sub	sp, sp, #16
 521              		.cfi_def_cfa_offset 24
 522 0004 00AF     		add	r7, sp, #0
 523              		.cfi_def_cfa_register 7
 524 0006 7860     		str	r0, [r7, #4]
 525 0008 0B46     		mov	r3, r1
 526 000a FB70     		strb	r3, [r7, #3]
1194:.\Generated_Source\PSoC5/UART_1.c ****         uint8 bufIndex = 0u;
 527              		.loc 1 1194 0
 528 000c 0023     		movs	r3, #0
 529 000e FB73     		strb	r3, [r7, #15]
1195:.\Generated_Source\PSoC5/UART_1.c **** 
1196:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function */
1197:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 530              		.loc 1 1197 0
 531 0010 0A4B     		ldr	r3, .L42
 532 0012 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 533 0014 002B     		cmp	r3, #0
 534 0016 0ED0     		beq	.L38
1198:.\Generated_Source\PSoC5/UART_1.c ****         {
1199:.\Generated_Source\PSoC5/UART_1.c ****             while(bufIndex < byteCount)
 535              		.loc 1 1199 0
 536 0018 09E0     		b	.L40
 537              	.L41:
1200:.\Generated_Source\PSoC5/UART_1.c ****             {
1201:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_PutChar(string[bufIndex]);
 538              		.loc 1 1201 0
 539 001a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 540 001c 7A68     		ldr	r2, [r7, #4]
 541 001e 1344     		add	r3, r3, r2
 542 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 543 0022 1846     		mov	r0, r3
 544 0024 FFF7FEFF 		bl	UART_1_PutChar
1202:.\Generated_Source\PSoC5/UART_1.c ****                 bufIndex++;
 545              		.loc 1 1202 0
 546 0028 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 547 002a 0133     		adds	r3, r3, #1
 548 002c FB73     		strb	r3, [r7, #15]
 549              	.L40:
1199:.\Generated_Source\PSoC5/UART_1.c ****             while(bufIndex < byteCount)
 550              		.loc 1 1199 0 discriminator 1
 551 002e FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 552 0030 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 553 0032 9A42     		cmp	r2, r3
 554 0034 F1D3     		bcc	.L41
 555              	.L38:
1203:.\Generated_Source\PSoC5/UART_1.c ****             }
1204:.\Generated_Source\PSoC5/UART_1.c ****         }
1205:.\Generated_Source\PSoC5/UART_1.c ****     }
 556              		.loc 1 1205 0
 557 0036 1037     		adds	r7, r7, #16
 558 0038 BD46     		mov	sp, r7
 559              		@ sp needed
 560 003a 80BD     		pop	{r7, pc}
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 32


 561              	.L43:
 562              		.align	2
 563              	.L42:
 564 003c 00000000 		.word	UART_1_initVar
 565              		.cfi_endproc
 566              	.LFE11:
 567              		.size	UART_1_PutArray, .-UART_1_PutArray
 568              		.section	.text.UART_1_PutCRLF,"ax",%progbits
 569              		.align	2
 570              		.global	UART_1_PutCRLF
 571              		.thumb
 572              		.thumb_func
 573              		.type	UART_1_PutCRLF, %function
 574              	UART_1_PutCRLF:
 575              	.LFB12:
1206:.\Generated_Source\PSoC5/UART_1.c **** 
1207:.\Generated_Source\PSoC5/UART_1.c **** 
1208:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1209:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutCRLF
1210:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1211:.\Generated_Source\PSoC5/UART_1.c ****     *
1212:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1213:.\Generated_Source\PSoC5/UART_1.c ****     *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214:.\Generated_Source\PSoC5/UART_1.c ****     *  (0x0A) to the transmit buffer.
1215:.\Generated_Source\PSoC5/UART_1.c ****     *
1216:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1217:.\Generated_Source\PSoC5/UART_1.c ****     *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218:.\Generated_Source\PSoC5/UART_1.c ****     *
1219:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1220:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1221:.\Generated_Source\PSoC5/UART_1.c ****     *
1222:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1223:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1224:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1225:.\Generated_Source\PSoC5/UART_1.c ****     *
1226:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1227:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1228:.\Generated_Source\PSoC5/UART_1.c ****     *
1229:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1230:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1231:.\Generated_Source\PSoC5/UART_1.c ****     {
 576              		.loc 1 1231 0
 577              		.cfi_startproc
 578              		@ args = 0, pretend = 0, frame = 8
 579              		@ frame_needed = 1, uses_anonymous_args = 0
 580 0000 80B5     		push	{r7, lr}
 581              		.cfi_def_cfa_offset 8
 582              		.cfi_offset 7, -8
 583              		.cfi_offset 14, -4
 584 0002 82B0     		sub	sp, sp, #8
 585              		.cfi_def_cfa_offset 16
 586 0004 00AF     		add	r7, sp, #0
 587              		.cfi_def_cfa_register 7
 588 0006 0346     		mov	r3, r0
 589 0008 FB71     		strb	r3, [r7, #7]
1232:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function */
1233:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 33


 590              		.loc 1 1233 0
 591 000a 084B     		ldr	r3, .L46
 592 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 593 000e 002B     		cmp	r3, #0
 594 0010 09D0     		beq	.L44
1234:.\Generated_Source\PSoC5/UART_1.c ****         {
1235:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(txDataByte);
 595              		.loc 1 1235 0
 596 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 597 0014 1846     		mov	r0, r3
 598 0016 FFF7FEFF 		bl	UART_1_PutChar
1236:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(0x0Du);
 599              		.loc 1 1236 0
 600 001a 0D20     		movs	r0, #13
 601 001c FFF7FEFF 		bl	UART_1_PutChar
1237:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(0x0Au);
 602              		.loc 1 1237 0
 603 0020 0A20     		movs	r0, #10
 604 0022 FFF7FEFF 		bl	UART_1_PutChar
 605              	.L44:
1238:.\Generated_Source\PSoC5/UART_1.c ****         }
1239:.\Generated_Source\PSoC5/UART_1.c ****     }
 606              		.loc 1 1239 0
 607 0026 0837     		adds	r7, r7, #8
 608 0028 BD46     		mov	sp, r7
 609              		@ sp needed
 610 002a 80BD     		pop	{r7, pc}
 611              	.L47:
 612              		.align	2
 613              	.L46:
 614 002c 00000000 		.word	UART_1_initVar
 615              		.cfi_endproc
 616              	.LFE12:
 617              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 618              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 619              		.align	2
 620              		.global	UART_1_GetTxBufferSize
 621              		.thumb
 622              		.thumb_func
 623              		.type	UART_1_GetTxBufferSize, %function
 624              	UART_1_GetTxBufferSize:
 625              	.LFB13:
1240:.\Generated_Source\PSoC5/UART_1.c **** 
1241:.\Generated_Source\PSoC5/UART_1.c **** 
1242:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1243:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1244:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1245:.\Generated_Source\PSoC5/UART_1.c ****     *
1246:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1247:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the number of bytes in the TX buffer which are waiting to be 
1248:.\Generated_Source\PSoC5/UART_1.c ****     *  transmitted.
1249:.\Generated_Source\PSoC5/UART_1.c ****     *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250:.\Generated_Source\PSoC5/UART_1.c ****     *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251:.\Generated_Source\PSoC5/UART_1.c ****     *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252:.\Generated_Source\PSoC5/UART_1.c ****     *    software buffer which are waiting to be transmitted. Bytes available in the
1253:.\Generated_Source\PSoC5/UART_1.c ****     *    TX FIFO do not take to account.
1254:.\Generated_Source\PSoC5/UART_1.c ****     *
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 34


1255:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1256:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1257:.\Generated_Source\PSoC5/UART_1.c ****     *
1258:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1259:.\Generated_Source\PSoC5/UART_1.c ****     *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260:.\Generated_Source\PSoC5/UART_1.c ****     *  Buffer Size parameter.
1261:.\Generated_Source\PSoC5/UART_1.c ****     *
1262:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1263:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1264:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1265:.\Generated_Source\PSoC5/UART_1.c ****     *
1266:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1267:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1268:.\Generated_Source\PSoC5/UART_1.c ****     *
1269:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1270:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
1271:.\Generated_Source\PSoC5/UART_1.c ****     *
1272:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1274:.\Generated_Source\PSoC5/UART_1.c ****                                                             
1275:.\Generated_Source\PSoC5/UART_1.c ****     {
 626              		.loc 1 1275 0
 627              		.cfi_startproc
 628              		@ args = 0, pretend = 0, frame = 8
 629              		@ frame_needed = 1, uses_anonymous_args = 0
 630              		@ link register save eliminated.
 631 0000 80B4     		push	{r7}
 632              		.cfi_def_cfa_offset 4
 633              		.cfi_offset 7, -4
 634 0002 83B0     		sub	sp, sp, #12
 635              		.cfi_def_cfa_offset 16
 636 0004 00AF     		add	r7, sp, #0
 637              		.cfi_def_cfa_register 7
1276:.\Generated_Source\PSoC5/UART_1.c ****         uint8 size;
1277:.\Generated_Source\PSoC5/UART_1.c **** 
1278:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1279:.\Generated_Source\PSoC5/UART_1.c **** 
1280:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt. */
1281:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableTxInt();
1282:.\Generated_Source\PSoC5/UART_1.c **** 
1283:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_txBufferRead == UART_1_txBufferWrite)
1284:.\Generated_Source\PSoC5/UART_1.c ****         {
1285:.\Generated_Source\PSoC5/UART_1.c ****             size = 0u;
1286:.\Generated_Source\PSoC5/UART_1.c ****         }
1287:.\Generated_Source\PSoC5/UART_1.c ****         else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1288:.\Generated_Source\PSoC5/UART_1.c ****         {
1289:.\Generated_Source\PSoC5/UART_1.c ****             size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1290:.\Generated_Source\PSoC5/UART_1.c ****         }
1291:.\Generated_Source\PSoC5/UART_1.c ****         else
1292:.\Generated_Source\PSoC5/UART_1.c ****         {
1293:.\Generated_Source\PSoC5/UART_1.c ****             size = (UART_1_TX_BUFFER_SIZE - UART_1_txBufferRead) +
1294:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_txBufferWrite;
1295:.\Generated_Source\PSoC5/UART_1.c ****         }
1296:.\Generated_Source\PSoC5/UART_1.c **** 
1297:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableTxInt();
1298:.\Generated_Source\PSoC5/UART_1.c **** 
1299:.\Generated_Source\PSoC5/UART_1.c ****     #else
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 35


1300:.\Generated_Source\PSoC5/UART_1.c **** 
1301:.\Generated_Source\PSoC5/UART_1.c ****         size = UART_1_TXSTATUS_REG;
 638              		.loc 1 1301 0
 639 0006 0E4B     		ldr	r3, .L53
 640 0008 1B78     		ldrb	r3, [r3]
 641 000a FB71     		strb	r3, [r7, #7]
1302:.\Generated_Source\PSoC5/UART_1.c **** 
1303:.\Generated_Source\PSoC5/UART_1.c ****         /* Is the fifo is full. */
1304:.\Generated_Source\PSoC5/UART_1.c ****         if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 642              		.loc 1 1304 0
 643 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 644 000e 03F00403 		and	r3, r3, #4
 645 0012 002B     		cmp	r3, #0
 646 0014 02D0     		beq	.L49
1305:.\Generated_Source\PSoC5/UART_1.c ****         {
1306:.\Generated_Source\PSoC5/UART_1.c ****             size = UART_1_FIFO_LENGTH;
 647              		.loc 1 1306 0
 648 0016 0423     		movs	r3, #4
 649 0018 FB71     		strb	r3, [r7, #7]
 650 001a 09E0     		b	.L50
 651              	.L49:
1307:.\Generated_Source\PSoC5/UART_1.c ****         }
1308:.\Generated_Source\PSoC5/UART_1.c ****         else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 652              		.loc 1 1308 0
 653 001c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 654 001e 03F00203 		and	r3, r3, #2
 655 0022 002B     		cmp	r3, #0
 656 0024 02D0     		beq	.L51
1309:.\Generated_Source\PSoC5/UART_1.c ****         {
1310:.\Generated_Source\PSoC5/UART_1.c ****             size = 0u;
 657              		.loc 1 1310 0
 658 0026 0023     		movs	r3, #0
 659 0028 FB71     		strb	r3, [r7, #7]
 660 002a 01E0     		b	.L50
 661              	.L51:
1311:.\Generated_Source\PSoC5/UART_1.c ****         }
1312:.\Generated_Source\PSoC5/UART_1.c ****         else
1313:.\Generated_Source\PSoC5/UART_1.c ****         {
1314:.\Generated_Source\PSoC5/UART_1.c ****             /* We only know there is data in the fifo. */
1315:.\Generated_Source\PSoC5/UART_1.c ****             size = 1u;
 662              		.loc 1 1315 0
 663 002c 0123     		movs	r3, #1
 664 002e FB71     		strb	r3, [r7, #7]
 665              	.L50:
1316:.\Generated_Source\PSoC5/UART_1.c ****         }
1317:.\Generated_Source\PSoC5/UART_1.c **** 
1318:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1319:.\Generated_Source\PSoC5/UART_1.c **** 
1320:.\Generated_Source\PSoC5/UART_1.c ****     return(size);
 666              		.loc 1 1320 0
 667 0030 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
1321:.\Generated_Source\PSoC5/UART_1.c ****     }
 668              		.loc 1 1321 0
 669 0032 1846     		mov	r0, r3
 670 0034 0C37     		adds	r7, r7, #12
 671 0036 BD46     		mov	sp, r7
 672              		@ sp needed
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 36


 673 0038 5DF8047B 		ldr	r7, [sp], #4
 674 003c 7047     		bx	lr
 675              	.L54:
 676 003e 00BF     		.align	2
 677              	.L53:
 678 0040 6A640040 		.word	1073767530
 679              		.cfi_endproc
 680              	.LFE13:
 681              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
 682              		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 683              		.align	2
 684              		.global	UART_1_ClearTxBuffer
 685              		.thumb
 686              		.thumb_func
 687              		.type	UART_1_ClearTxBuffer, %function
 688              	UART_1_ClearTxBuffer:
 689              	.LFB14:
1322:.\Generated_Source\PSoC5/UART_1.c **** 
1323:.\Generated_Source\PSoC5/UART_1.c **** 
1324:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1325:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1326:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1327:.\Generated_Source\PSoC5/UART_1.c ****     *
1328:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1329:.\Generated_Source\PSoC5/UART_1.c ****     *  Clears all data from the TX buffer and hardware TX FIFO.
1330:.\Generated_Source\PSoC5/UART_1.c ****     *
1331:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1332:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1333:.\Generated_Source\PSoC5/UART_1.c ****     *
1334:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1335:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1336:.\Generated_Source\PSoC5/UART_1.c ****     *
1337:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1338:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1339:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1340:.\Generated_Source\PSoC5/UART_1.c ****     *
1341:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1342:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1343:.\Generated_Source\PSoC5/UART_1.c ****     *
1344:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1345:.\Generated_Source\PSoC5/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1346:.\Generated_Source\PSoC5/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1347:.\Generated_Source\PSoC5/UART_1.c ****     *  remained in the RAM.
1348:.\Generated_Source\PSoC5/UART_1.c ****     *
1349:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
1350:.\Generated_Source\PSoC5/UART_1.c ****     *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351:.\Generated_Source\PSoC5/UART_1.c ****     *  transmitting finishes transmitting.
1352:.\Generated_Source\PSoC5/UART_1.c ****     *
1353:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1354:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1355:.\Generated_Source\PSoC5/UART_1.c ****     {
 690              		.loc 1 1355 0
 691              		.cfi_startproc
 692              		@ args = 0, pretend = 0, frame = 8
 693              		@ frame_needed = 1, uses_anonymous_args = 0
 694 0000 80B5     		push	{r7, lr}
 695              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 37


 696              		.cfi_offset 7, -8
 697              		.cfi_offset 14, -4
 698 0002 82B0     		sub	sp, sp, #8
 699              		.cfi_def_cfa_offset 16
 700 0004 00AF     		add	r7, sp, #0
 701              		.cfi_def_cfa_register 7
1356:.\Generated_Source\PSoC5/UART_1.c ****         uint8 enableInterrupts;
1357:.\Generated_Source\PSoC5/UART_1.c **** 
1358:.\Generated_Source\PSoC5/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 702              		.loc 1 1358 0
 703 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 704 000a 0346     		mov	r3, r0
 705 000c FB71     		strb	r3, [r7, #7]
1359:.\Generated_Source\PSoC5/UART_1.c ****         /* Clear the HW FIFO */
1360:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |= (uint8)  UART_1_TX_FIFO_CLR;
 706              		.loc 1 1360 0
 707 000e 0B4B     		ldr	r3, .L56
 708 0010 0A4A     		ldr	r2, .L56
 709 0012 1278     		ldrb	r2, [r2]
 710 0014 D2B2     		uxtb	r2, r2
 711 0016 42F00102 		orr	r2, r2, #1
 712 001a D2B2     		uxtb	r2, r2
 713 001c 1A70     		strb	r2, [r3]
1361:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8) ~UART_1_TX_FIFO_CLR;
 714              		.loc 1 1361 0
 715 001e 074B     		ldr	r3, .L56
 716 0020 064A     		ldr	r2, .L56
 717 0022 1278     		ldrb	r2, [r2]
 718 0024 D2B2     		uxtb	r2, r2
 719 0026 22F00102 		bic	r2, r2, #1
 720 002a D2B2     		uxtb	r2, r2
 721 002c 1A70     		strb	r2, [r3]
1362:.\Generated_Source\PSoC5/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 722              		.loc 1 1362 0
 723 002e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 724 0030 1846     		mov	r0, r3
 725 0032 FFF7FEFF 		bl	CyExitCriticalSection
1363:.\Generated_Source\PSoC5/UART_1.c **** 
1364:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1365:.\Generated_Source\PSoC5/UART_1.c **** 
1366:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt. */
1367:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableTxInt();
1368:.\Generated_Source\PSoC5/UART_1.c **** 
1369:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_txBufferRead = 0u;
1370:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_txBufferWrite = 0u;
1371:.\Generated_Source\PSoC5/UART_1.c **** 
1372:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable Tx interrupt. */
1373:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableTxInt();
1374:.\Generated_Source\PSoC5/UART_1.c **** 
1375:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1376:.\Generated_Source\PSoC5/UART_1.c ****     }
 726              		.loc 1 1376 0
 727 0036 0837     		adds	r7, r7, #8
 728 0038 BD46     		mov	sp, r7
 729              		@ sp needed
 730 003a 80BD     		pop	{r7, pc}
 731              	.L57:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 38


 732              		.align	2
 733              	.L56:
 734 003c 9A640040 		.word	1073767578
 735              		.cfi_endproc
 736              	.LFE14:
 737              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
 738              		.section	.text.UART_1_SendBreak,"ax",%progbits
 739              		.align	2
 740              		.global	UART_1_SendBreak
 741              		.thumb
 742              		.thumb_func
 743              		.type	UART_1_SendBreak, %function
 744              	UART_1_SendBreak:
 745              	.LFB15:
1377:.\Generated_Source\PSoC5/UART_1.c **** 
1378:.\Generated_Source\PSoC5/UART_1.c **** 
1379:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1380:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SendBreak
1381:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1382:.\Generated_Source\PSoC5/UART_1.c ****     *
1383:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1384:.\Generated_Source\PSoC5/UART_1.c ****     *  Transmits a break signal on the bus.
1385:.\Generated_Source\PSoC5/UART_1.c ****     *
1386:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1387:.\Generated_Source\PSoC5/UART_1.c ****     *  uint8 retMode:  Send Break return mode. See the following table for options.
1388:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_SEND_BREAK - Initialize registers for break, send the Break
1389:.\Generated_Source\PSoC5/UART_1.c ****     *       signal and return immediately.
1390:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391:.\Generated_Source\PSoC5/UART_1.c ****     *       complete, reinitialize registers to normal transmission mode then return
1392:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_REINIT - Reinitialize registers to normal transmission mode
1393:.\Generated_Source\PSoC5/UART_1.c ****     *       then return.
1394:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_SEND_WAIT_REINIT - Performs both options: 
1395:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_SEND_BREAK and UART_1_WAIT_FOR_COMPLETE_REINIT.
1396:.\Generated_Source\PSoC5/UART_1.c ****     *      This option is recommended for most cases.
1397:.\Generated_Source\PSoC5/UART_1.c ****     *
1398:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1399:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1400:.\Generated_Source\PSoC5/UART_1.c ****     *
1401:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1402:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1403:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1404:.\Generated_Source\PSoC5/UART_1.c ****     *  txPeriod - static variable, used for keeping TX period configuration.
1405:.\Generated_Source\PSoC5/UART_1.c ****     *
1406:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1407:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1408:.\Generated_Source\PSoC5/UART_1.c ****     *
1409:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1410:.\Generated_Source\PSoC5/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1411:.\Generated_Source\PSoC5/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1412:.\Generated_Source\PSoC5/UART_1.c ****     *  operation.
1413:.\Generated_Source\PSoC5/UART_1.c ****     *  There are 3 variants for this API usage:
1414:.\Generated_Source\PSoC5/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1415:.\Generated_Source\PSoC5/UART_1.c ****     *     configuration returning. Function will block CPU until transmission
1416:.\Generated_Source\PSoC5/UART_1.c ****     *     complete.
1417:.\Generated_Source\PSoC5/UART_1.c ****     *  2) User may want to use blocking time if UART configured to the low speed
1418:.\Generated_Source\PSoC5/UART_1.c ****     *     operation
1419:.\Generated_Source\PSoC5/UART_1.c ****     *     Example for this case:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 39


1420:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1421:.\Generated_Source\PSoC5/UART_1.c ****     *         Add your code here to use CPU time
1422:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1423:.\Generated_Source\PSoC5/UART_1.c ****     *  3) Same to 2) but user may want to initialize and use the interrupt to
1424:.\Generated_Source\PSoC5/UART_1.c ****     *     complete break operation.
1425:.\Generated_Source\PSoC5/UART_1.c ****     *     Example for this case:
1426:.\Generated_Source\PSoC5/UART_1.c ****     *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1428:.\Generated_Source\PSoC5/UART_1.c ****     *         Add your code here to use CPU time
1429:.\Generated_Source\PSoC5/UART_1.c ****     *     When interrupt appear with UART_1_TX_STS_COMPLETE status:
1430:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1431:.\Generated_Source\PSoC5/UART_1.c ****     *
1432:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
1433:.\Generated_Source\PSoC5/UART_1.c ****     *  The UART_1_SendBreak() function initializes registers to send a
1434:.\Generated_Source\PSoC5/UART_1.c ****     *  break signal.
1435:.\Generated_Source\PSoC5/UART_1.c ****     *  Break signal length depends on the break signal bits configuration.
1436:.\Generated_Source\PSoC5/UART_1.c ****     *  The register configuration should be reinitialized before normal 8-bit
1437:.\Generated_Source\PSoC5/UART_1.c ****     *  communication can continue.
1438:.\Generated_Source\PSoC5/UART_1.c ****     *
1439:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1440:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1441:.\Generated_Source\PSoC5/UART_1.c ****     {
 746              		.loc 1 1441 0
 747              		.cfi_startproc
 748              		@ args = 0, pretend = 0, frame = 16
 749              		@ frame_needed = 1, uses_anonymous_args = 0
 750              		@ link register save eliminated.
 751 0000 80B4     		push	{r7}
 752              		.cfi_def_cfa_offset 4
 753              		.cfi_offset 7, -4
 754 0002 85B0     		sub	sp, sp, #20
 755              		.cfi_def_cfa_offset 24
 756 0004 00AF     		add	r7, sp, #0
 757              		.cfi_def_cfa_register 7
 758 0006 0346     		mov	r3, r0
 759 0008 FB71     		strb	r3, [r7, #7]
1442:.\Generated_Source\PSoC5/UART_1.c **** 
1443:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
1444:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 760              		.loc 1 1444 0
 761 000a 1F4B     		ldr	r3, .L66
 762 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 763 000e 002B     		cmp	r3, #0
 764 0010 35D0     		beq	.L58
 765              	.LBB2:
1445:.\Generated_Source\PSoC5/UART_1.c ****         {
1446:.\Generated_Source\PSoC5/UART_1.c ****             /* Set the Counter to 13-bits and transmit a 00 byte */
1447:.\Generated_Source\PSoC5/UART_1.c ****             /* When that is done then reset the counter value back */
1448:.\Generated_Source\PSoC5/UART_1.c ****             uint8 tmpStat;
1449:.\Generated_Source\PSoC5/UART_1.c **** 
1450:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1451:.\Generated_Source\PSoC5/UART_1.c **** 
1452:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
1453:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT ) )
1454:.\Generated_Source\PSoC5/UART_1.c ****             {
1455:.\Generated_Source\PSoC5/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
1456:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 40


1457:.\Generated_Source\PSoC5/UART_1.c ****                                                       UART_1_CTRL_HD_SEND_BREAK);
1458:.\Generated_Source\PSoC5/UART_1.c ****                 /* Send zeros */
1459:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
1460:.\Generated_Source\PSoC5/UART_1.c **** 
1461:.\Generated_Source\PSoC5/UART_1.c ****                 do /* Wait until transmit starts */
1462:.\Generated_Source\PSoC5/UART_1.c ****                 {
1463:.\Generated_Source\PSoC5/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
1464:.\Generated_Source\PSoC5/UART_1.c ****                 }
1465:.\Generated_Source\PSoC5/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1466:.\Generated_Source\PSoC5/UART_1.c ****             }
1467:.\Generated_Source\PSoC5/UART_1.c **** 
1468:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1469:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1470:.\Generated_Source\PSoC5/UART_1.c ****             {
1471:.\Generated_Source\PSoC5/UART_1.c ****                 do /* Wait until transmit complete */
1472:.\Generated_Source\PSoC5/UART_1.c ****                 {
1473:.\Generated_Source\PSoC5/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
1474:.\Generated_Source\PSoC5/UART_1.c ****                 }
1475:.\Generated_Source\PSoC5/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1476:.\Generated_Source\PSoC5/UART_1.c ****             }
1477:.\Generated_Source\PSoC5/UART_1.c **** 
1478:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1479:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_REINIT) ||
1480:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1481:.\Generated_Source\PSoC5/UART_1.c ****             {
1482:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1483:.\Generated_Source\PSoC5/UART_1.c ****                                               (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1484:.\Generated_Source\PSoC5/UART_1.c ****             }
1485:.\Generated_Source\PSoC5/UART_1.c **** 
1486:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_HD_ENABLED Full Duplex mode */
1487:.\Generated_Source\PSoC5/UART_1.c **** 
1488:.\Generated_Source\PSoC5/UART_1.c ****             static uint8 txPeriod;
1489:.\Generated_Source\PSoC5/UART_1.c **** 
1490:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
 766              		.loc 1 1490 0
 767 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 768 0014 002B     		cmp	r3, #0
 769 0016 02D0     		beq	.L60
 770              		.loc 1 1490 0 is_stmt 0 discriminator 1
 771 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 772 001a 032B     		cmp	r3, #3
 773 001c 12D1     		bne	.L61
 774              	.L60:
1491:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1492:.\Generated_Source\PSoC5/UART_1.c ****             {
1493:.\Generated_Source\PSoC5/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode
1494:.\Generated_Source\PSoC5/UART_1.c ****                 #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1495:.\Generated_Source\PSoC5/UART_1.c ****                                     (UART_1_PARITY_TYPE_SW != 0u) )
1496:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1497:.\Generated_Source\PSoC5/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1498:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1499:.\Generated_Source\PSoC5/UART_1.c **** 
1500:.\Generated_Source\PSoC5/UART_1.c ****                 #if(UART_1_TXCLKGEN_DP)
1501:.\Generated_Source\PSoC5/UART_1.c ****                     txPeriod = UART_1_TXBITCLKTX_COMPLETE_REG;
 775              		.loc 1 1501 0 is_stmt 1
 776 001e 1B4B     		ldr	r3, .L66+4
 777 0020 1B78     		ldrb	r3, [r3]
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 41


 778 0022 DAB2     		uxtb	r2, r3
 779 0024 1A4B     		ldr	r3, .L66+8
 780 0026 1A70     		strb	r2, [r3]
1502:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
 781              		.loc 1 1502 0
 782 0028 184B     		ldr	r3, .L66+4
 783 002a 6722     		movs	r2, #103
 784 002c 1A70     		strb	r2, [r3]
1503:.\Generated_Source\PSoC5/UART_1.c ****                 #else
1504:.\Generated_Source\PSoC5/UART_1.c ****                     txPeriod = UART_1_TXBITCTR_PERIOD_REG;
1505:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1506:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_TXCLKGEN_DP */
1507:.\Generated_Source\PSoC5/UART_1.c **** 
1508:.\Generated_Source\PSoC5/UART_1.c ****                 /* Send zeros */
1509:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
 785              		.loc 1 1509 0
 786 002e 194B     		ldr	r3, .L66+12
 787 0030 0022     		movs	r2, #0
 788 0032 1A70     		strb	r2, [r3]
 789              	.L62:
1510:.\Generated_Source\PSoC5/UART_1.c **** 
1511:.\Generated_Source\PSoC5/UART_1.c ****                 do /* Wait until transmit starts */
1512:.\Generated_Source\PSoC5/UART_1.c ****                 {
1513:.\Generated_Source\PSoC5/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 790              		.loc 1 1513 0 discriminator 1
 791 0034 184B     		ldr	r3, .L66+16
 792 0036 1B78     		ldrb	r3, [r3]
 793 0038 FB73     		strb	r3, [r7, #15]
1514:.\Generated_Source\PSoC5/UART_1.c ****                 }
1515:.\Generated_Source\PSoC5/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 794              		.loc 1 1515 0 discriminator 1
 795 003a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 796 003c 03F00203 		and	r3, r3, #2
 797 0040 002B     		cmp	r3, #0
 798 0042 F7D1     		bne	.L62
 799              	.L61:
1516:.\Generated_Source\PSoC5/UART_1.c ****             }
1517:.\Generated_Source\PSoC5/UART_1.c **** 
1518:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 800              		.loc 1 1518 0
 801 0044 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 802 0046 012B     		cmp	r3, #1
 803 0048 02D0     		beq	.L63
 804              		.loc 1 1518 0 is_stmt 0 discriminator 1
 805 004a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 806 004c 032B     		cmp	r3, #3
 807 004e 09D1     		bne	.L64
 808              	.L63:
1519:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1520:.\Generated_Source\PSoC5/UART_1.c ****             {
1521:.\Generated_Source\PSoC5/UART_1.c ****                 do /* Wait until transmit complete */
1522:.\Generated_Source\PSoC5/UART_1.c ****                 {
1523:.\Generated_Source\PSoC5/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 809              		.loc 1 1523 0 is_stmt 1 discriminator 1
 810 0050 114B     		ldr	r3, .L66+16
 811 0052 1B78     		ldrb	r3, [r3]
 812 0054 FB73     		strb	r3, [r7, #15]
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 42


1524:.\Generated_Source\PSoC5/UART_1.c ****                 }
1525:.\Generated_Source\PSoC5/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 813              		.loc 1 1525 0 discriminator 1
 814 0056 FB7B     		ldrb	r3, [r7, #15]
 815 0058 DB43     		mvns	r3, r3
 816 005a DBB2     		uxtb	r3, r3
 817 005c 03F00103 		and	r3, r3, #1
 818 0060 002B     		cmp	r3, #0
 819 0062 F5D1     		bne	.L63
 820              	.L64:
1526:.\Generated_Source\PSoC5/UART_1.c ****             }
1527:.\Generated_Source\PSoC5/UART_1.c **** 
1528:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 821              		.loc 1 1528 0
 822 0064 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 823 0066 012B     		cmp	r3, #1
 824 0068 05D0     		beq	.L65
 825              		.loc 1 1528 0 is_stmt 0 discriminator 1
 826 006a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 827 006c 022B     		cmp	r3, #2
 828 006e 02D0     		beq	.L65
1529:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_REINIT) ||
 829              		.loc 1 1529 0 is_stmt 1
 830 0070 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 831 0072 032B     		cmp	r3, #3
 832 0074 03D1     		bne	.L58
 833              	.L65:
1530:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1531:.\Generated_Source\PSoC5/UART_1.c ****             {
1532:.\Generated_Source\PSoC5/UART_1.c **** 
1533:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_TXCLKGEN_DP)
1534:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXBITCLKTX_COMPLETE_REG = txPeriod;
 834              		.loc 1 1534 0
 835 0076 054B     		ldr	r3, .L66+4
 836 0078 054A     		ldr	r2, .L66+8
 837 007a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 838 007c 1A70     		strb	r2, [r3]
 839              	.L58:
 840              	.LBE2:
1535:.\Generated_Source\PSoC5/UART_1.c ****             #else
1536:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXBITCTR_PERIOD_REG = txPeriod;
1537:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_TXCLKGEN_DP */
1538:.\Generated_Source\PSoC5/UART_1.c **** 
1539:.\Generated_Source\PSoC5/UART_1.c ****             #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1540:.\Generated_Source\PSoC5/UART_1.c ****                  (UART_1_PARITY_TYPE_SW != 0u) )
1541:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1542:.\Generated_Source\PSoC5/UART_1.c ****                                                       (uint8) ~UART_1_CTRL_HD_SEND_BREAK);
1543:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_PARITY_TYPE != NONE */
1544:.\Generated_Source\PSoC5/UART_1.c ****             }
1545:.\Generated_Source\PSoC5/UART_1.c ****         #endif    /* End UART_1_HD_ENABLED */
1546:.\Generated_Source\PSoC5/UART_1.c ****         }
1547:.\Generated_Source\PSoC5/UART_1.c ****     }
 841              		.loc 1 1547 0
 842 007e 1437     		adds	r7, r7, #20
 843 0080 BD46     		mov	sp, r7
 844              		@ sp needed
 845 0082 5DF8047B 		ldr	r7, [sp], #4
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 43


 846 0086 7047     		bx	lr
 847              	.L67:
 848              		.align	2
 849              	.L66:
 850 0088 00000000 		.word	UART_1_initVar
 851 008c 3B640040 		.word	1073767483
 852 0090 01000000 		.word	txPeriod.4932
 853 0094 4A640040 		.word	1073767498
 854 0098 6A640040 		.word	1073767530
 855              		.cfi_endproc
 856              	.LFE15:
 857              		.size	UART_1_SendBreak, .-UART_1_SendBreak
 858              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 859              		.align	2
 860              		.global	UART_1_SetTxAddressMode
 861              		.thumb
 862              		.thumb_func
 863              		.type	UART_1_SetTxAddressMode, %function
 864              	UART_1_SetTxAddressMode:
 865              	.LFB16:
1548:.\Generated_Source\PSoC5/UART_1.c **** 
1549:.\Generated_Source\PSoC5/UART_1.c **** 
1550:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1551:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1552:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1553:.\Generated_Source\PSoC5/UART_1.c ****     *
1554:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1555:.\Generated_Source\PSoC5/UART_1.c ****     *  Configures the transmitter to signal the next bytes is address or data.
1556:.\Generated_Source\PSoC5/UART_1.c ****     *
1557:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1558:.\Generated_Source\PSoC5/UART_1.c ****     *  addressMode: 
1559:.\Generated_Source\PSoC5/UART_1.c ****     *       UART_1_SET_SPACE - Configure the transmitter to send the next
1560:.\Generated_Source\PSoC5/UART_1.c ****     *                                    byte as a data.
1561:.\Generated_Source\PSoC5/UART_1.c ****     *       UART_1_SET_MARK  - Configure the transmitter to send the next
1562:.\Generated_Source\PSoC5/UART_1.c ****     *                                    byte as an address.
1563:.\Generated_Source\PSoC5/UART_1.c ****     *
1564:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1565:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1566:.\Generated_Source\PSoC5/UART_1.c ****     *
1567:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
1568:.\Generated_Source\PSoC5/UART_1.c ****     *  This function sets and clears UART_1_CTRL_MARK bit in the Control
1569:.\Generated_Source\PSoC5/UART_1.c ****     *  register.
1570:.\Generated_Source\PSoC5/UART_1.c ****     *
1571:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1572:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1573:.\Generated_Source\PSoC5/UART_1.c ****     {
 866              		.loc 1 1573 0
 867              		.cfi_startproc
 868              		@ args = 0, pretend = 0, frame = 8
 869              		@ frame_needed = 1, uses_anonymous_args = 0
 870              		@ link register save eliminated.
 871 0000 80B4     		push	{r7}
 872              		.cfi_def_cfa_offset 4
 873              		.cfi_offset 7, -4
 874 0002 83B0     		sub	sp, sp, #12
 875              		.cfi_def_cfa_offset 16
 876 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 44


 877              		.cfi_def_cfa_register 7
 878 0006 0346     		mov	r3, r0
 879 0008 FB71     		strb	r3, [r7, #7]
1574:.\Generated_Source\PSoC5/UART_1.c ****         /* Mark/Space sending enable */
1575:.\Generated_Source\PSoC5/UART_1.c ****         if(addressMode != 0u)
1576:.\Generated_Source\PSoC5/UART_1.c ****         {
1577:.\Generated_Source\PSoC5/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1578:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1579:.\Generated_Source\PSoC5/UART_1.c ****                                                   UART_1_CTRL_MARK);
1580:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1581:.\Generated_Source\PSoC5/UART_1.c ****         }
1582:.\Generated_Source\PSoC5/UART_1.c ****         else
1583:.\Generated_Source\PSoC5/UART_1.c ****         {
1584:.\Generated_Source\PSoC5/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1585:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1586:.\Generated_Source\PSoC5/UART_1.c ****                                                   (uint8) ~UART_1_CTRL_MARK);
1587:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1588:.\Generated_Source\PSoC5/UART_1.c ****         }
1589:.\Generated_Source\PSoC5/UART_1.c ****     }
 880              		.loc 1 1589 0
 881 000a 0C37     		adds	r7, r7, #12
 882 000c BD46     		mov	sp, r7
 883              		@ sp needed
 884 000e 5DF8047B 		ldr	r7, [sp], #4
 885 0012 7047     		bx	lr
 886              		.cfi_endproc
 887              	.LFE16:
 888              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 889              		.bss
 890              	txPeriod.4932:
 891 0001 00       		.space	1
 892              		.text
 893              	.Letext0:
 894              		.file 2 ".\\Generated_Source\\PSoC5\\cytypes.h"
 895              		.section	.debug_info,"",%progbits
 896              	.Ldebug_info0:
 897 0000 71030000 		.4byte	0x371
 898 0004 0400     		.2byte	0x4
 899 0006 00000000 		.4byte	.Ldebug_abbrev0
 900 000a 04       		.byte	0x4
 901 000b 01       		.uleb128 0x1
 902 000c 27000000 		.4byte	.LASF45
 903 0010 01       		.byte	0x1
 904 0011 AB020000 		.4byte	.LASF46
 905 0015 3F020000 		.4byte	.LASF47
 906 0019 00000000 		.4byte	.Ldebug_ranges0+0
 907 001d 00000000 		.4byte	0
 908 0021 00000000 		.4byte	.Ldebug_line0
 909 0025 02       		.uleb128 0x2
 910 0026 01       		.byte	0x1
 911 0027 06       		.byte	0x6
 912 0028 3D030000 		.4byte	.LASF0
 913 002c 02       		.uleb128 0x2
 914 002d 01       		.byte	0x1
 915 002e 08       		.byte	0x8
 916 002f 8F010000 		.4byte	.LASF1
 917 0033 02       		.uleb128 0x2
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 45


 918 0034 02       		.byte	0x2
 919 0035 05       		.byte	0x5
 920 0036 AB010000 		.4byte	.LASF2
 921 003a 02       		.uleb128 0x2
 922 003b 02       		.byte	0x2
 923 003c 07       		.byte	0x7
 924 003d D0000000 		.4byte	.LASF3
 925 0041 02       		.uleb128 0x2
 926 0042 04       		.byte	0x4
 927 0043 05       		.byte	0x5
 928 0044 0C030000 		.4byte	.LASF4
 929 0048 02       		.uleb128 0x2
 930 0049 04       		.byte	0x4
 931 004a 07       		.byte	0x7
 932 004b 54010000 		.4byte	.LASF5
 933 004f 02       		.uleb128 0x2
 934 0050 08       		.byte	0x8
 935 0051 05       		.byte	0x5
 936 0052 00000000 		.4byte	.LASF6
 937 0056 02       		.uleb128 0x2
 938 0057 08       		.byte	0x8
 939 0058 07       		.byte	0x7
 940 0059 EF010000 		.4byte	.LASF7
 941 005d 03       		.uleb128 0x3
 942 005e 04       		.byte	0x4
 943 005f 05       		.byte	0x5
 944 0060 696E7400 		.ascii	"int\000"
 945 0064 02       		.uleb128 0x2
 946 0065 04       		.byte	0x4
 947 0066 07       		.byte	0x7
 948 0067 CB010000 		.4byte	.LASF8
 949 006b 04       		.uleb128 0x4
 950 006c 66010000 		.4byte	.LASF9
 951 0070 02       		.byte	0x2
 952 0071 A1       		.byte	0xa1
 953 0072 2C000000 		.4byte	0x2c
 954 0076 04       		.uleb128 0x4
 955 0077 B5010000 		.4byte	.LASF10
 956 007b 02       		.byte	0x2
 957 007c A2       		.byte	0xa2
 958 007d 3A000000 		.4byte	0x3a
 959 0081 02       		.uleb128 0x2
 960 0082 04       		.byte	0x4
 961 0083 04       		.byte	0x4
 962 0084 16010000 		.4byte	.LASF11
 963 0088 02       		.uleb128 0x2
 964 0089 08       		.byte	0x8
 965 008a 04       		.byte	0x4
 966 008b 9D010000 		.4byte	.LASF12
 967 008f 04       		.uleb128 0x4
 968 0090 8C020000 		.4byte	.LASF13
 969 0094 02       		.byte	0x2
 970 0095 B2       		.byte	0xb2
 971 0096 9A000000 		.4byte	0x9a
 972 009a 02       		.uleb128 0x2
 973 009b 01       		.byte	0x1
 974 009c 08       		.byte	0x8
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 46


 975 009d A6020000 		.4byte	.LASF14
 976 00a1 05       		.uleb128 0x5
 977 00a2 28010000 		.4byte	.LASF15
 978 00a6 02       		.byte	0x2
 979 00a7 4B01     		.2byte	0x14b
 980 00a9 AD000000 		.4byte	0xad
 981 00ad 06       		.uleb128 0x6
 982 00ae 6B000000 		.4byte	0x6b
 983 00b2 02       		.uleb128 0x2
 984 00b3 04       		.byte	0x4
 985 00b4 07       		.byte	0x7
 986 00b5 92020000 		.4byte	.LASF16
 987 00b9 07       		.uleb128 0x7
 988 00ba 1A000000 		.4byte	.LASF17
 989 00be 01       		.byte	0x1
 990 00bf 4C       		.byte	0x4c
 991 00c0 00000000 		.4byte	.LFB0
 992 00c4 20000000 		.4byte	.LFE0-.LFB0
 993 00c8 01       		.uleb128 0x1
 994 00c9 9C       		.byte	0x9c
 995 00ca 08       		.uleb128 0x8
 996 00cb 0E000000 		.4byte	.LASF18
 997 00cf 01       		.byte	0x1
 998 00d0 6A       		.byte	0x6a
 999 00d1 00000000 		.4byte	.LFB1
 1000 00d5 2C000000 		.4byte	.LFE1-.LFB1
 1001 00d9 01       		.uleb128 0x1
 1002 00da 9C       		.byte	0x9c
 1003 00db 09       		.uleb128 0x9
 1004 00dc 2F030000 		.4byte	.LASF19
 1005 00e0 01       		.byte	0x1
 1006 00e1 B7       		.byte	0xb7
 1007 00e2 00000000 		.4byte	.LFB2
 1008 00e6 34000000 		.4byte	.LFE2-.LFB2
 1009 00ea 01       		.uleb128 0x1
 1010 00eb 9C       		.byte	0x9c
 1011 00ec FF000000 		.4byte	0xff
 1012 00f0 0A       		.uleb128 0xa
 1013 00f1 7E010000 		.4byte	.LASF21
 1014 00f5 01       		.byte	0x1
 1015 00f6 B9       		.byte	0xb9
 1016 00f7 6B000000 		.4byte	0x6b
 1017 00fb 02       		.uleb128 0x2
 1018 00fc 91       		.byte	0x91
 1019 00fd 77       		.sleb128 -9
 1020 00fe 00       		.byte	0
 1021 00ff 09       		.uleb128 0x9
 1022 0100 48010000 		.4byte	.LASF20
 1023 0104 01       		.byte	0x1
 1024 0105 F0       		.byte	0xf0
 1025 0106 00000000 		.4byte	.LFB3
 1026 010a 34000000 		.4byte	.LFE3-.LFB3
 1027 010e 01       		.uleb128 0x1
 1028 010f 9C       		.byte	0x9c
 1029 0110 23010000 		.4byte	0x123
 1030 0114 0A       		.uleb128 0xa
 1031 0115 7E010000 		.4byte	.LASF21
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 47


 1032 0119 01       		.byte	0x1
 1033 011a F2       		.byte	0xf2
 1034 011b 6B000000 		.4byte	0x6b
 1035 011f 02       		.uleb128 0x2
 1036 0120 91       		.byte	0x91
 1037 0121 77       		.sleb128 -9
 1038 0122 00       		.byte	0
 1039 0123 0B       		.uleb128 0xb
 1040 0124 2D010000 		.4byte	.LASF28
 1041 0128 01       		.byte	0x1
 1042 0129 2701     		.2byte	0x127
 1043 012b 6B000000 		.4byte	0x6b
 1044 012f 00000000 		.4byte	.LFB4
 1045 0133 10000000 		.4byte	.LFE4-.LFB4
 1046 0137 01       		.uleb128 0x1
 1047 0138 9C       		.byte	0x9c
 1048 0139 0C       		.uleb128 0xc
 1049 013a A3000000 		.4byte	.LASF22
 1050 013e 01       		.byte	0x1
 1051 013f 3F01     		.2byte	0x13f
 1052 0141 00000000 		.4byte	.LFB5
 1053 0145 14000000 		.4byte	.LFE5-.LFB5
 1054 0149 01       		.uleb128 0x1
 1055 014a 9C       		.byte	0x9c
 1056 014b 5F010000 		.4byte	0x15f
 1057 014f 0D       		.uleb128 0xd
 1058 0150 6C010000 		.4byte	.LASF24
 1059 0154 01       		.byte	0x1
 1060 0155 3F01     		.2byte	0x13f
 1061 0157 6B000000 		.4byte	0x6b
 1062 015b 02       		.uleb128 0x2
 1063 015c 91       		.byte	0x91
 1064 015d 77       		.sleb128 -9
 1065 015e 00       		.byte	0
 1066 015f 0C       		.uleb128 0xc
 1067 0160 15030000 		.4byte	.LASF23
 1068 0164 01       		.byte	0x1
 1069 0165 8C03     		.2byte	0x38c
 1070 0167 00000000 		.4byte	.LFB6
 1071 016b 20000000 		.4byte	.LFE6-.LFB6
 1072 016f 01       		.uleb128 0x1
 1073 0170 9C       		.byte	0x9c
 1074 0171 85010000 		.4byte	0x185
 1075 0175 0D       		.uleb128 0xd
 1076 0176 A4010000 		.4byte	.LASF25
 1077 017a 01       		.byte	0x1
 1078 017b 8C03     		.2byte	0x38c
 1079 017d 6B000000 		.4byte	0x6b
 1080 0181 02       		.uleb128 0x2
 1081 0182 91       		.byte	0x91
 1082 0183 77       		.sleb128 -9
 1083 0184 00       		.byte	0
 1084 0185 0C       		.uleb128 0xc
 1085 0186 D5020000 		.4byte	.LASF26
 1086 018a 01       		.byte	0x1
 1087 018b AE03     		.2byte	0x3ae
 1088 018d 00000000 		.4byte	.LFB7
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 48


 1089 0191 2C000000 		.4byte	.LFE7-.LFB7
 1090 0195 01       		.uleb128 0x1
 1091 0196 9C       		.byte	0x9c
 1092 0197 AB010000 		.4byte	0x1ab
 1093 019b 0D       		.uleb128 0xd
 1094 019c 9B020000 		.4byte	.LASF27
 1095 01a0 01       		.byte	0x1
 1096 01a1 AE03     		.2byte	0x3ae
 1097 01a3 6B000000 		.4byte	0x6b
 1098 01a7 02       		.uleb128 0x2
 1099 01a8 91       		.byte	0x91
 1100 01a9 77       		.sleb128 -9
 1101 01aa 00       		.byte	0
 1102 01ab 0B       		.uleb128 0xb
 1103 01ac FB000000 		.4byte	.LASF29
 1104 01b0 01       		.byte	0x1
 1105 01b1 EB03     		.2byte	0x3eb
 1106 01b3 6B000000 		.4byte	0x6b
 1107 01b7 00000000 		.4byte	.LFB8
 1108 01bb 18000000 		.4byte	.LFE8-.LFB8
 1109 01bf 01       		.uleb128 0x1
 1110 01c0 9C       		.byte	0x9c
 1111 01c1 0C       		.uleb128 0xc
 1112 01c2 BC010000 		.4byte	.LASF30
 1113 01c6 01       		.byte	0x1
 1114 01c7 1104     		.2byte	0x411
 1115 01c9 00000000 		.4byte	.LFB9
 1116 01cd 34000000 		.4byte	.LFE9-.LFB9
 1117 01d1 01       		.uleb128 0x1
 1118 01d2 9C       		.byte	0x9c
 1119 01d3 E7010000 		.4byte	0x1e7
 1120 01d7 0D       		.uleb128 0xd
 1121 01d8 9B020000 		.4byte	.LASF27
 1122 01dc 01       		.byte	0x1
 1123 01dd 1104     		.2byte	0x411
 1124 01df 6B000000 		.4byte	0x6b
 1125 01e3 02       		.uleb128 0x2
 1126 01e4 91       		.byte	0x91
 1127 01e5 77       		.sleb128 -9
 1128 01e6 00       		.byte	0
 1129 01e7 0E       		.uleb128 0xe
 1130 01e8 49030000 		.4byte	.LASF31
 1131 01ec 01       		.byte	0x1
 1132 01ed 7904     		.2byte	0x479
 1133 01ef 00000000 		.4byte	.LFB10
 1134 01f3 40000000 		.4byte	.LFE10-.LFB10
 1135 01f7 01       		.uleb128 0x1
 1136 01f8 9C       		.byte	0x9c
 1137 01f9 1C020000 		.4byte	0x21c
 1138 01fd 0D       		.uleb128 0xd
 1139 01fe 0F010000 		.4byte	.LASF32
 1140 0202 01       		.byte	0x1
 1141 0203 7904     		.2byte	0x479
 1142 0205 1C020000 		.4byte	0x21c
 1143 0209 02       		.uleb128 0x2
 1144 020a 91       		.byte	0x91
 1145 020b 6C       		.sleb128 -20
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 49


 1146 020c 0F       		.uleb128 0xf
 1147 020d 15020000 		.4byte	.LASF33
 1148 0211 01       		.byte	0x1
 1149 0212 7B04     		.2byte	0x47b
 1150 0214 76000000 		.4byte	0x76
 1151 0218 02       		.uleb128 0x2
 1152 0219 91       		.byte	0x91
 1153 021a 76       		.sleb128 -10
 1154 021b 00       		.byte	0
 1155 021c 10       		.uleb128 0x10
 1156 021d 04       		.byte	0x4
 1157 021e 22020000 		.4byte	0x222
 1158 0222 11       		.uleb128 0x11
 1159 0223 8F000000 		.4byte	0x8f
 1160 0227 0E       		.uleb128 0xe
 1161 0228 2F020000 		.4byte	.LASF34
 1162 022c 01       		.byte	0x1
 1163 022d A704     		.2byte	0x4a7
 1164 022f 00000000 		.4byte	.LFB11
 1165 0233 40000000 		.4byte	.LFE11-.LFB11
 1166 0237 01       		.uleb128 0x1
 1167 0238 9C       		.byte	0x9c
 1168 0239 6B020000 		.4byte	0x26b
 1169 023d 0D       		.uleb128 0xd
 1170 023e 0F010000 		.4byte	.LASF32
 1171 0242 01       		.byte	0x1
 1172 0243 A704     		.2byte	0x4a7
 1173 0245 6B020000 		.4byte	0x26b
 1174 0249 02       		.uleb128 0x2
 1175 024a 91       		.byte	0x91
 1176 024b 6C       		.sleb128 -20
 1177 024c 0D       		.uleb128 0xd
 1178 024d 74010000 		.4byte	.LASF35
 1179 0251 01       		.byte	0x1
 1180 0252 A704     		.2byte	0x4a7
 1181 0254 6B000000 		.4byte	0x6b
 1182 0258 02       		.uleb128 0x2
 1183 0259 91       		.byte	0x91
 1184 025a 6B       		.sleb128 -21
 1185 025b 0F       		.uleb128 0xf
 1186 025c 15020000 		.4byte	.LASF33
 1187 0260 01       		.byte	0x1
 1188 0261 AA04     		.2byte	0x4aa
 1189 0263 6B000000 		.4byte	0x6b
 1190 0267 02       		.uleb128 0x2
 1191 0268 91       		.byte	0x91
 1192 0269 77       		.sleb128 -9
 1193 026a 00       		.byte	0
 1194 026b 10       		.uleb128 0x10
 1195 026c 04       		.byte	0x4
 1196 026d 71020000 		.4byte	0x271
 1197 0271 11       		.uleb128 0x11
 1198 0272 6B000000 		.4byte	0x6b
 1199 0276 0E       		.uleb128 0xe
 1200 0277 06020000 		.4byte	.LASF36
 1201 027b 01       		.byte	0x1
 1202 027c CE04     		.2byte	0x4ce
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 50


 1203 027e 00000000 		.4byte	.LFB12
 1204 0282 30000000 		.4byte	.LFE12-.LFB12
 1205 0286 01       		.uleb128 0x1
 1206 0287 9C       		.byte	0x9c
 1207 0288 9C020000 		.4byte	0x29c
 1208 028c 0D       		.uleb128 0xd
 1209 028d 9B020000 		.4byte	.LASF27
 1210 0291 01       		.byte	0x1
 1211 0292 CE04     		.2byte	0x4ce
 1212 0294 6B000000 		.4byte	0x6b
 1213 0298 02       		.uleb128 0x2
 1214 0299 91       		.byte	0x91
 1215 029a 77       		.sleb128 -9
 1216 029b 00       		.byte	0
 1217 029c 12       		.uleb128 0x12
 1218 029d D8010000 		.4byte	.LASF48
 1219 02a1 01       		.byte	0x1
 1220 02a2 F904     		.2byte	0x4f9
 1221 02a4 6B000000 		.4byte	0x6b
 1222 02a8 00000000 		.4byte	.LFB13
 1223 02ac 44000000 		.4byte	.LFE13-.LFB13
 1224 02b0 01       		.uleb128 0x1
 1225 02b1 9C       		.byte	0x9c
 1226 02b2 C6020000 		.4byte	0x2c6
 1227 02b6 0F       		.uleb128 0xf
 1228 02b7 5A030000 		.4byte	.LASF37
 1229 02bb 01       		.byte	0x1
 1230 02bc FC04     		.2byte	0x4fc
 1231 02be 6B000000 		.4byte	0x6b
 1232 02c2 02       		.uleb128 0x2
 1233 02c3 91       		.byte	0x91
 1234 02c4 77       		.sleb128 -9
 1235 02c5 00       		.byte	0
 1236 02c6 0E       		.uleb128 0xe
 1237 02c7 E8020000 		.4byte	.LASF38
 1238 02cb 01       		.byte	0x1
 1239 02cc 4A05     		.2byte	0x54a
 1240 02ce 00000000 		.4byte	.LFB14
 1241 02d2 40000000 		.4byte	.LFE14-.LFB14
 1242 02d6 01       		.uleb128 0x1
 1243 02d7 9C       		.byte	0x9c
 1244 02d8 EC020000 		.4byte	0x2ec
 1245 02dc 0F       		.uleb128 0xf
 1246 02dd 7E010000 		.4byte	.LASF21
 1247 02e1 01       		.byte	0x1
 1248 02e2 4C05     		.2byte	0x54c
 1249 02e4 6B000000 		.4byte	0x6b
 1250 02e8 02       		.uleb128 0x2
 1251 02e9 91       		.byte	0x91
 1252 02ea 77       		.sleb128 -9
 1253 02eb 00       		.byte	0
 1254 02ec 0C       		.uleb128 0xc
 1255 02ed 1E020000 		.4byte	.LASF39
 1256 02f1 01       		.byte	0x1
 1257 02f2 A005     		.2byte	0x5a0
 1258 02f4 00000000 		.4byte	.LFB15
 1259 02f8 9C000000 		.4byte	.LFE15-.LFB15
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 51


 1260 02fc 01       		.uleb128 0x1
 1261 02fd 9C       		.byte	0x9c
 1262 02fe 3D030000 		.4byte	0x33d
 1263 0302 0D       		.uleb128 0xd
 1264 0303 CD020000 		.4byte	.LASF40
 1265 0307 01       		.byte	0x1
 1266 0308 A005     		.2byte	0x5a0
 1267 030a 6B000000 		.4byte	0x6b
 1268 030e 02       		.uleb128 0x2
 1269 030f 91       		.byte	0x91
 1270 0310 6F       		.sleb128 -17
 1271 0311 13       		.uleb128 0x13
 1272 0312 12000000 		.4byte	.LBB2
 1273 0316 6C000000 		.4byte	.LBE2-.LBB2
 1274 031a 0F       		.uleb128 0xf
 1275 031b C8000000 		.4byte	.LASF41
 1276 031f 01       		.byte	0x1
 1277 0320 A805     		.2byte	0x5a8
 1278 0322 6B000000 		.4byte	0x6b
 1279 0326 02       		.uleb128 0x2
 1280 0327 91       		.byte	0x91
 1281 0328 77       		.sleb128 -9
 1282 0329 0F       		.uleb128 0xf
 1283 032a BF000000 		.4byte	.LASF42
 1284 032e 01       		.byte	0x1
 1285 032f D005     		.2byte	0x5d0
 1286 0331 6B000000 		.4byte	0x6b
 1287 0335 05       		.uleb128 0x5
 1288 0336 03       		.byte	0x3
 1289 0337 01000000 		.4byte	txPeriod.4932
 1290 033b 00       		.byte	0
 1291 033c 00       		.byte	0
 1292 033d 0C       		.uleb128 0xc
 1293 033e E3000000 		.4byte	.LASF43
 1294 0342 01       		.byte	0x1
 1295 0343 2406     		.2byte	0x624
 1296 0345 00000000 		.4byte	.LFB16
 1297 0349 14000000 		.4byte	.LFE16-.LFB16
 1298 034d 01       		.uleb128 0x1
 1299 034e 9C       		.byte	0x9c
 1300 034f 63030000 		.4byte	0x363
 1301 0353 0D       		.uleb128 0xd
 1302 0354 1C010000 		.4byte	.LASF44
 1303 0358 01       		.byte	0x1
 1304 0359 2406     		.2byte	0x624
 1305 035b 6B000000 		.4byte	0x6b
 1306 035f 02       		.uleb128 0x2
 1307 0360 91       		.byte	0x91
 1308 0361 77       		.sleb128 -9
 1309 0362 00       		.byte	0
 1310 0363 14       		.uleb128 0x14
 1311 0364 FD020000 		.4byte	.LASF49
 1312 0368 01       		.byte	0x1
 1313 0369 1B       		.byte	0x1b
 1314 036a 6B000000 		.4byte	0x6b
 1315 036e 05       		.uleb128 0x5
 1316 036f 03       		.byte	0x3
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 52


 1317 0370 00000000 		.4byte	UART_1_initVar
 1318 0374 00       		.byte	0
 1319              		.section	.debug_abbrev,"",%progbits
 1320              	.Ldebug_abbrev0:
 1321 0000 01       		.uleb128 0x1
 1322 0001 11       		.uleb128 0x11
 1323 0002 01       		.byte	0x1
 1324 0003 25       		.uleb128 0x25
 1325 0004 0E       		.uleb128 0xe
 1326 0005 13       		.uleb128 0x13
 1327 0006 0B       		.uleb128 0xb
 1328 0007 03       		.uleb128 0x3
 1329 0008 0E       		.uleb128 0xe
 1330 0009 1B       		.uleb128 0x1b
 1331 000a 0E       		.uleb128 0xe
 1332 000b 55       		.uleb128 0x55
 1333 000c 17       		.uleb128 0x17
 1334 000d 11       		.uleb128 0x11
 1335 000e 01       		.uleb128 0x1
 1336 000f 10       		.uleb128 0x10
 1337 0010 17       		.uleb128 0x17
 1338 0011 00       		.byte	0
 1339 0012 00       		.byte	0
 1340 0013 02       		.uleb128 0x2
 1341 0014 24       		.uleb128 0x24
 1342 0015 00       		.byte	0
 1343 0016 0B       		.uleb128 0xb
 1344 0017 0B       		.uleb128 0xb
 1345 0018 3E       		.uleb128 0x3e
 1346 0019 0B       		.uleb128 0xb
 1347 001a 03       		.uleb128 0x3
 1348 001b 0E       		.uleb128 0xe
 1349 001c 00       		.byte	0
 1350 001d 00       		.byte	0
 1351 001e 03       		.uleb128 0x3
 1352 001f 24       		.uleb128 0x24
 1353 0020 00       		.byte	0
 1354 0021 0B       		.uleb128 0xb
 1355 0022 0B       		.uleb128 0xb
 1356 0023 3E       		.uleb128 0x3e
 1357 0024 0B       		.uleb128 0xb
 1358 0025 03       		.uleb128 0x3
 1359 0026 08       		.uleb128 0x8
 1360 0027 00       		.byte	0
 1361 0028 00       		.byte	0
 1362 0029 04       		.uleb128 0x4
 1363 002a 16       		.uleb128 0x16
 1364 002b 00       		.byte	0
 1365 002c 03       		.uleb128 0x3
 1366 002d 0E       		.uleb128 0xe
 1367 002e 3A       		.uleb128 0x3a
 1368 002f 0B       		.uleb128 0xb
 1369 0030 3B       		.uleb128 0x3b
 1370 0031 0B       		.uleb128 0xb
 1371 0032 49       		.uleb128 0x49
 1372 0033 13       		.uleb128 0x13
 1373 0034 00       		.byte	0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 53


 1374 0035 00       		.byte	0
 1375 0036 05       		.uleb128 0x5
 1376 0037 16       		.uleb128 0x16
 1377 0038 00       		.byte	0
 1378 0039 03       		.uleb128 0x3
 1379 003a 0E       		.uleb128 0xe
 1380 003b 3A       		.uleb128 0x3a
 1381 003c 0B       		.uleb128 0xb
 1382 003d 3B       		.uleb128 0x3b
 1383 003e 05       		.uleb128 0x5
 1384 003f 49       		.uleb128 0x49
 1385 0040 13       		.uleb128 0x13
 1386 0041 00       		.byte	0
 1387 0042 00       		.byte	0
 1388 0043 06       		.uleb128 0x6
 1389 0044 35       		.uleb128 0x35
 1390 0045 00       		.byte	0
 1391 0046 49       		.uleb128 0x49
 1392 0047 13       		.uleb128 0x13
 1393 0048 00       		.byte	0
 1394 0049 00       		.byte	0
 1395 004a 07       		.uleb128 0x7
 1396 004b 2E       		.uleb128 0x2e
 1397 004c 00       		.byte	0
 1398 004d 3F       		.uleb128 0x3f
 1399 004e 19       		.uleb128 0x19
 1400 004f 03       		.uleb128 0x3
 1401 0050 0E       		.uleb128 0xe
 1402 0051 3A       		.uleb128 0x3a
 1403 0052 0B       		.uleb128 0xb
 1404 0053 3B       		.uleb128 0x3b
 1405 0054 0B       		.uleb128 0xb
 1406 0055 27       		.uleb128 0x27
 1407 0056 19       		.uleb128 0x19
 1408 0057 11       		.uleb128 0x11
 1409 0058 01       		.uleb128 0x1
 1410 0059 12       		.uleb128 0x12
 1411 005a 06       		.uleb128 0x6
 1412 005b 40       		.uleb128 0x40
 1413 005c 18       		.uleb128 0x18
 1414 005d 9642     		.uleb128 0x2116
 1415 005f 19       		.uleb128 0x19
 1416 0060 00       		.byte	0
 1417 0061 00       		.byte	0
 1418 0062 08       		.uleb128 0x8
 1419 0063 2E       		.uleb128 0x2e
 1420 0064 00       		.byte	0
 1421 0065 3F       		.uleb128 0x3f
 1422 0066 19       		.uleb128 0x19
 1423 0067 03       		.uleb128 0x3
 1424 0068 0E       		.uleb128 0xe
 1425 0069 3A       		.uleb128 0x3a
 1426 006a 0B       		.uleb128 0xb
 1427 006b 3B       		.uleb128 0x3b
 1428 006c 0B       		.uleb128 0xb
 1429 006d 27       		.uleb128 0x27
 1430 006e 19       		.uleb128 0x19
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 54


 1431 006f 11       		.uleb128 0x11
 1432 0070 01       		.uleb128 0x1
 1433 0071 12       		.uleb128 0x12
 1434 0072 06       		.uleb128 0x6
 1435 0073 40       		.uleb128 0x40
 1436 0074 18       		.uleb128 0x18
 1437 0075 9742     		.uleb128 0x2117
 1438 0077 19       		.uleb128 0x19
 1439 0078 00       		.byte	0
 1440 0079 00       		.byte	0
 1441 007a 09       		.uleb128 0x9
 1442 007b 2E       		.uleb128 0x2e
 1443 007c 01       		.byte	0x1
 1444 007d 3F       		.uleb128 0x3f
 1445 007e 19       		.uleb128 0x19
 1446 007f 03       		.uleb128 0x3
 1447 0080 0E       		.uleb128 0xe
 1448 0081 3A       		.uleb128 0x3a
 1449 0082 0B       		.uleb128 0xb
 1450 0083 3B       		.uleb128 0x3b
 1451 0084 0B       		.uleb128 0xb
 1452 0085 27       		.uleb128 0x27
 1453 0086 19       		.uleb128 0x19
 1454 0087 11       		.uleb128 0x11
 1455 0088 01       		.uleb128 0x1
 1456 0089 12       		.uleb128 0x12
 1457 008a 06       		.uleb128 0x6
 1458 008b 40       		.uleb128 0x40
 1459 008c 18       		.uleb128 0x18
 1460 008d 9642     		.uleb128 0x2116
 1461 008f 19       		.uleb128 0x19
 1462 0090 01       		.uleb128 0x1
 1463 0091 13       		.uleb128 0x13
 1464 0092 00       		.byte	0
 1465 0093 00       		.byte	0
 1466 0094 0A       		.uleb128 0xa
 1467 0095 34       		.uleb128 0x34
 1468 0096 00       		.byte	0
 1469 0097 03       		.uleb128 0x3
 1470 0098 0E       		.uleb128 0xe
 1471 0099 3A       		.uleb128 0x3a
 1472 009a 0B       		.uleb128 0xb
 1473 009b 3B       		.uleb128 0x3b
 1474 009c 0B       		.uleb128 0xb
 1475 009d 49       		.uleb128 0x49
 1476 009e 13       		.uleb128 0x13
 1477 009f 02       		.uleb128 0x2
 1478 00a0 18       		.uleb128 0x18
 1479 00a1 00       		.byte	0
 1480 00a2 00       		.byte	0
 1481 00a3 0B       		.uleb128 0xb
 1482 00a4 2E       		.uleb128 0x2e
 1483 00a5 00       		.byte	0
 1484 00a6 3F       		.uleb128 0x3f
 1485 00a7 19       		.uleb128 0x19
 1486 00a8 03       		.uleb128 0x3
 1487 00a9 0E       		.uleb128 0xe
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 55


 1488 00aa 3A       		.uleb128 0x3a
 1489 00ab 0B       		.uleb128 0xb
 1490 00ac 3B       		.uleb128 0x3b
 1491 00ad 05       		.uleb128 0x5
 1492 00ae 27       		.uleb128 0x27
 1493 00af 19       		.uleb128 0x19
 1494 00b0 49       		.uleb128 0x49
 1495 00b1 13       		.uleb128 0x13
 1496 00b2 11       		.uleb128 0x11
 1497 00b3 01       		.uleb128 0x1
 1498 00b4 12       		.uleb128 0x12
 1499 00b5 06       		.uleb128 0x6
 1500 00b6 40       		.uleb128 0x40
 1501 00b7 18       		.uleb128 0x18
 1502 00b8 9742     		.uleb128 0x2117
 1503 00ba 19       		.uleb128 0x19
 1504 00bb 00       		.byte	0
 1505 00bc 00       		.byte	0
 1506 00bd 0C       		.uleb128 0xc
 1507 00be 2E       		.uleb128 0x2e
 1508 00bf 01       		.byte	0x1
 1509 00c0 3F       		.uleb128 0x3f
 1510 00c1 19       		.uleb128 0x19
 1511 00c2 03       		.uleb128 0x3
 1512 00c3 0E       		.uleb128 0xe
 1513 00c4 3A       		.uleb128 0x3a
 1514 00c5 0B       		.uleb128 0xb
 1515 00c6 3B       		.uleb128 0x3b
 1516 00c7 05       		.uleb128 0x5
 1517 00c8 27       		.uleb128 0x27
 1518 00c9 19       		.uleb128 0x19
 1519 00ca 11       		.uleb128 0x11
 1520 00cb 01       		.uleb128 0x1
 1521 00cc 12       		.uleb128 0x12
 1522 00cd 06       		.uleb128 0x6
 1523 00ce 40       		.uleb128 0x40
 1524 00cf 18       		.uleb128 0x18
 1525 00d0 9742     		.uleb128 0x2117
 1526 00d2 19       		.uleb128 0x19
 1527 00d3 01       		.uleb128 0x1
 1528 00d4 13       		.uleb128 0x13
 1529 00d5 00       		.byte	0
 1530 00d6 00       		.byte	0
 1531 00d7 0D       		.uleb128 0xd
 1532 00d8 05       		.uleb128 0x5
 1533 00d9 00       		.byte	0
 1534 00da 03       		.uleb128 0x3
 1535 00db 0E       		.uleb128 0xe
 1536 00dc 3A       		.uleb128 0x3a
 1537 00dd 0B       		.uleb128 0xb
 1538 00de 3B       		.uleb128 0x3b
 1539 00df 05       		.uleb128 0x5
 1540 00e0 49       		.uleb128 0x49
 1541 00e1 13       		.uleb128 0x13
 1542 00e2 02       		.uleb128 0x2
 1543 00e3 18       		.uleb128 0x18
 1544 00e4 00       		.byte	0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 56


 1545 00e5 00       		.byte	0
 1546 00e6 0E       		.uleb128 0xe
 1547 00e7 2E       		.uleb128 0x2e
 1548 00e8 01       		.byte	0x1
 1549 00e9 3F       		.uleb128 0x3f
 1550 00ea 19       		.uleb128 0x19
 1551 00eb 03       		.uleb128 0x3
 1552 00ec 0E       		.uleb128 0xe
 1553 00ed 3A       		.uleb128 0x3a
 1554 00ee 0B       		.uleb128 0xb
 1555 00ef 3B       		.uleb128 0x3b
 1556 00f0 05       		.uleb128 0x5
 1557 00f1 27       		.uleb128 0x27
 1558 00f2 19       		.uleb128 0x19
 1559 00f3 11       		.uleb128 0x11
 1560 00f4 01       		.uleb128 0x1
 1561 00f5 12       		.uleb128 0x12
 1562 00f6 06       		.uleb128 0x6
 1563 00f7 40       		.uleb128 0x40
 1564 00f8 18       		.uleb128 0x18
 1565 00f9 9642     		.uleb128 0x2116
 1566 00fb 19       		.uleb128 0x19
 1567 00fc 01       		.uleb128 0x1
 1568 00fd 13       		.uleb128 0x13
 1569 00fe 00       		.byte	0
 1570 00ff 00       		.byte	0
 1571 0100 0F       		.uleb128 0xf
 1572 0101 34       		.uleb128 0x34
 1573 0102 00       		.byte	0
 1574 0103 03       		.uleb128 0x3
 1575 0104 0E       		.uleb128 0xe
 1576 0105 3A       		.uleb128 0x3a
 1577 0106 0B       		.uleb128 0xb
 1578 0107 3B       		.uleb128 0x3b
 1579 0108 05       		.uleb128 0x5
 1580 0109 49       		.uleb128 0x49
 1581 010a 13       		.uleb128 0x13
 1582 010b 02       		.uleb128 0x2
 1583 010c 18       		.uleb128 0x18
 1584 010d 00       		.byte	0
 1585 010e 00       		.byte	0
 1586 010f 10       		.uleb128 0x10
 1587 0110 0F       		.uleb128 0xf
 1588 0111 00       		.byte	0
 1589 0112 0B       		.uleb128 0xb
 1590 0113 0B       		.uleb128 0xb
 1591 0114 49       		.uleb128 0x49
 1592 0115 13       		.uleb128 0x13
 1593 0116 00       		.byte	0
 1594 0117 00       		.byte	0
 1595 0118 11       		.uleb128 0x11
 1596 0119 26       		.uleb128 0x26
 1597 011a 00       		.byte	0
 1598 011b 49       		.uleb128 0x49
 1599 011c 13       		.uleb128 0x13
 1600 011d 00       		.byte	0
 1601 011e 00       		.byte	0
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 57


 1602 011f 12       		.uleb128 0x12
 1603 0120 2E       		.uleb128 0x2e
 1604 0121 01       		.byte	0x1
 1605 0122 3F       		.uleb128 0x3f
 1606 0123 19       		.uleb128 0x19
 1607 0124 03       		.uleb128 0x3
 1608 0125 0E       		.uleb128 0xe
 1609 0126 3A       		.uleb128 0x3a
 1610 0127 0B       		.uleb128 0xb
 1611 0128 3B       		.uleb128 0x3b
 1612 0129 05       		.uleb128 0x5
 1613 012a 27       		.uleb128 0x27
 1614 012b 19       		.uleb128 0x19
 1615 012c 49       		.uleb128 0x49
 1616 012d 13       		.uleb128 0x13
 1617 012e 11       		.uleb128 0x11
 1618 012f 01       		.uleb128 0x1
 1619 0130 12       		.uleb128 0x12
 1620 0131 06       		.uleb128 0x6
 1621 0132 40       		.uleb128 0x40
 1622 0133 18       		.uleb128 0x18
 1623 0134 9742     		.uleb128 0x2117
 1624 0136 19       		.uleb128 0x19
 1625 0137 01       		.uleb128 0x1
 1626 0138 13       		.uleb128 0x13
 1627 0139 00       		.byte	0
 1628 013a 00       		.byte	0
 1629 013b 13       		.uleb128 0x13
 1630 013c 0B       		.uleb128 0xb
 1631 013d 01       		.byte	0x1
 1632 013e 11       		.uleb128 0x11
 1633 013f 01       		.uleb128 0x1
 1634 0140 12       		.uleb128 0x12
 1635 0141 06       		.uleb128 0x6
 1636 0142 00       		.byte	0
 1637 0143 00       		.byte	0
 1638 0144 14       		.uleb128 0x14
 1639 0145 34       		.uleb128 0x34
 1640 0146 00       		.byte	0
 1641 0147 03       		.uleb128 0x3
 1642 0148 0E       		.uleb128 0xe
 1643 0149 3A       		.uleb128 0x3a
 1644 014a 0B       		.uleb128 0xb
 1645 014b 3B       		.uleb128 0x3b
 1646 014c 0B       		.uleb128 0xb
 1647 014d 49       		.uleb128 0x49
 1648 014e 13       		.uleb128 0x13
 1649 014f 3F       		.uleb128 0x3f
 1650 0150 19       		.uleb128 0x19
 1651 0151 02       		.uleb128 0x2
 1652 0152 18       		.uleb128 0x18
 1653 0153 00       		.byte	0
 1654 0154 00       		.byte	0
 1655 0155 00       		.byte	0
 1656              		.section	.debug_aranges,"",%progbits
 1657 0000 9C000000 		.4byte	0x9c
 1658 0004 0200     		.2byte	0x2
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 58


 1659 0006 00000000 		.4byte	.Ldebug_info0
 1660 000a 04       		.byte	0x4
 1661 000b 00       		.byte	0
 1662 000c 0000     		.2byte	0
 1663 000e 0000     		.2byte	0
 1664 0010 00000000 		.4byte	.LFB0
 1665 0014 20000000 		.4byte	.LFE0-.LFB0
 1666 0018 00000000 		.4byte	.LFB1
 1667 001c 2C000000 		.4byte	.LFE1-.LFB1
 1668 0020 00000000 		.4byte	.LFB2
 1669 0024 34000000 		.4byte	.LFE2-.LFB2
 1670 0028 00000000 		.4byte	.LFB3
 1671 002c 34000000 		.4byte	.LFE3-.LFB3
 1672 0030 00000000 		.4byte	.LFB4
 1673 0034 10000000 		.4byte	.LFE4-.LFB4
 1674 0038 00000000 		.4byte	.LFB5
 1675 003c 14000000 		.4byte	.LFE5-.LFB5
 1676 0040 00000000 		.4byte	.LFB6
 1677 0044 20000000 		.4byte	.LFE6-.LFB6
 1678 0048 00000000 		.4byte	.LFB7
 1679 004c 2C000000 		.4byte	.LFE7-.LFB7
 1680 0050 00000000 		.4byte	.LFB8
 1681 0054 18000000 		.4byte	.LFE8-.LFB8
 1682 0058 00000000 		.4byte	.LFB9
 1683 005c 34000000 		.4byte	.LFE9-.LFB9
 1684 0060 00000000 		.4byte	.LFB10
 1685 0064 40000000 		.4byte	.LFE10-.LFB10
 1686 0068 00000000 		.4byte	.LFB11
 1687 006c 40000000 		.4byte	.LFE11-.LFB11
 1688 0070 00000000 		.4byte	.LFB12
 1689 0074 30000000 		.4byte	.LFE12-.LFB12
 1690 0078 00000000 		.4byte	.LFB13
 1691 007c 44000000 		.4byte	.LFE13-.LFB13
 1692 0080 00000000 		.4byte	.LFB14
 1693 0084 40000000 		.4byte	.LFE14-.LFB14
 1694 0088 00000000 		.4byte	.LFB15
 1695 008c 9C000000 		.4byte	.LFE15-.LFB15
 1696 0090 00000000 		.4byte	.LFB16
 1697 0094 14000000 		.4byte	.LFE16-.LFB16
 1698 0098 00000000 		.4byte	0
 1699 009c 00000000 		.4byte	0
 1700              		.section	.debug_ranges,"",%progbits
 1701              	.Ldebug_ranges0:
 1702 0000 00000000 		.4byte	.LFB0
 1703 0004 20000000 		.4byte	.LFE0
 1704 0008 00000000 		.4byte	.LFB1
 1705 000c 2C000000 		.4byte	.LFE1
 1706 0010 00000000 		.4byte	.LFB2
 1707 0014 34000000 		.4byte	.LFE2
 1708 0018 00000000 		.4byte	.LFB3
 1709 001c 34000000 		.4byte	.LFE3
 1710 0020 00000000 		.4byte	.LFB4
 1711 0024 10000000 		.4byte	.LFE4
 1712 0028 00000000 		.4byte	.LFB5
 1713 002c 14000000 		.4byte	.LFE5
 1714 0030 00000000 		.4byte	.LFB6
 1715 0034 20000000 		.4byte	.LFE6
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 59


 1716 0038 00000000 		.4byte	.LFB7
 1717 003c 2C000000 		.4byte	.LFE7
 1718 0040 00000000 		.4byte	.LFB8
 1719 0044 18000000 		.4byte	.LFE8
 1720 0048 00000000 		.4byte	.LFB9
 1721 004c 34000000 		.4byte	.LFE9
 1722 0050 00000000 		.4byte	.LFB10
 1723 0054 40000000 		.4byte	.LFE10
 1724 0058 00000000 		.4byte	.LFB11
 1725 005c 40000000 		.4byte	.LFE11
 1726 0060 00000000 		.4byte	.LFB12
 1727 0064 30000000 		.4byte	.LFE12
 1728 0068 00000000 		.4byte	.LFB13
 1729 006c 44000000 		.4byte	.LFE13
 1730 0070 00000000 		.4byte	.LFB14
 1731 0074 40000000 		.4byte	.LFE14
 1732 0078 00000000 		.4byte	.LFB15
 1733 007c 9C000000 		.4byte	.LFE15
 1734 0080 00000000 		.4byte	.LFB16
 1735 0084 14000000 		.4byte	.LFE16
 1736 0088 00000000 		.4byte	0
 1737 008c 00000000 		.4byte	0
 1738              		.section	.debug_line,"",%progbits
 1739              	.Ldebug_line0:
 1740 0000 FD010000 		.section	.debug_str,"MS",%progbits,1
 1740      02004500 
 1740      00000201 
 1740      FB0E0D00 
 1740      01010101 
 1741              	.LASF6:
 1742 0000 6C6F6E67 		.ascii	"long long int\000"
 1742      206C6F6E 
 1742      6720696E 
 1742      7400
 1743              	.LASF18:
 1744 000e 55415254 		.ascii	"UART_1_Init\000"
 1744      5F315F49 
 1744      6E697400 
 1745              	.LASF17:
 1746 001a 55415254 		.ascii	"UART_1_Start\000"
 1746      5F315F53 
 1746      74617274 
 1746      00
 1747              	.LASF45:
 1748 0027 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 1748      4320342E 
 1748      382E3420 
 1748      32303134 
 1748      30353236 
 1749 005a 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m3 -mthumb -g -O"
 1749      20726576 
 1749      6973696F 
 1749      6E203231 
 1749      31333538 
 1750 008d 30202D66 		.ascii	"0 -ffunction-sections\000"
 1750      66756E63 
 1750      74696F6E 
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 60


 1750      2D736563 
 1750      74696F6E 
 1751              	.LASF22:
 1752 00a3 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 1752      5F315F57 
 1752      72697465 
 1752      436F6E74 
 1752      726F6C52 
 1753              	.LASF42:
 1754 00bf 74785065 		.ascii	"txPeriod\000"
 1754      72696F64 
 1754      00
 1755              	.LASF41:
 1756 00c8 746D7053 		.ascii	"tmpStat\000"
 1756      74617400 
 1757              	.LASF3:
 1758 00d0 73686F72 		.ascii	"short unsigned int\000"
 1758      7420756E 
 1758      7369676E 
 1758      65642069 
 1758      6E7400
 1759              	.LASF43:
 1760 00e3 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 1760      5F315F53 
 1760      65745478 
 1760      41646472 
 1760      6573734D 
 1761              	.LASF29:
 1762 00fb 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 1762      5F315F52 
 1762      65616454 
 1762      78537461 
 1762      74757300 
 1763              	.LASF32:
 1764 010f 73747269 		.ascii	"string\000"
 1764      6E6700
 1765              	.LASF11:
 1766 0116 666C6F61 		.ascii	"float\000"
 1766      7400
 1767              	.LASF44:
 1768 011c 61646472 		.ascii	"addressMode\000"
 1768      6573734D 
 1768      6F646500 
 1769              	.LASF15:
 1770 0128 72656738 		.ascii	"reg8\000"
 1770      00
 1771              	.LASF28:
 1772 012d 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 1772      5F315F52 
 1772      65616443 
 1772      6F6E7472 
 1772      6F6C5265 
 1773              	.LASF20:
 1774 0148 55415254 		.ascii	"UART_1_Stop\000"
 1774      5F315F53 
 1774      746F7000 
 1775              	.LASF5:
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 61


 1776 0154 6C6F6E67 		.ascii	"long unsigned int\000"
 1776      20756E73 
 1776      69676E65 
 1776      6420696E 
 1776      7400
 1777              	.LASF9:
 1778 0166 75696E74 		.ascii	"uint8\000"
 1778      3800
 1779              	.LASF24:
 1780 016c 636F6E74 		.ascii	"control\000"
 1780      726F6C00 
 1781              	.LASF35:
 1782 0174 62797465 		.ascii	"byteCount\000"
 1782      436F756E 
 1782      7400
 1783              	.LASF21:
 1784 017e 656E6162 		.ascii	"enableInterrupts\000"
 1784      6C65496E 
 1784      74657272 
 1784      75707473 
 1784      00
 1785              	.LASF1:
 1786 018f 756E7369 		.ascii	"unsigned char\000"
 1786      676E6564 
 1786      20636861 
 1786      7200
 1787              	.LASF12:
 1788 019d 646F7562 		.ascii	"double\000"
 1788      6C6500
 1789              	.LASF25:
 1790 01a4 696E7453 		.ascii	"intSrc\000"
 1790      726300
 1791              	.LASF2:
 1792 01ab 73686F72 		.ascii	"short int\000"
 1792      7420696E 
 1792      7400
 1793              	.LASF10:
 1794 01b5 75696E74 		.ascii	"uint16\000"
 1794      313600
 1795              	.LASF30:
 1796 01bc 55415254 		.ascii	"UART_1_PutChar\000"
 1796      5F315F50 
 1796      75744368 
 1796      617200
 1797              	.LASF8:
 1798 01cb 756E7369 		.ascii	"unsigned int\000"
 1798      676E6564 
 1798      20696E74 
 1798      00
 1799              	.LASF48:
 1800 01d8 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 1800      5F315F47 
 1800      65745478 
 1800      42756666 
 1800      65725369 
 1801              	.LASF7:
 1802 01ef 6C6F6E67 		.ascii	"long long unsigned int\000"
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 62


 1802      206C6F6E 
 1802      6720756E 
 1802      7369676E 
 1802      65642069 
 1803              	.LASF36:
 1804 0206 55415254 		.ascii	"UART_1_PutCRLF\000"
 1804      5F315F50 
 1804      75744352 
 1804      4C4600
 1805              	.LASF33:
 1806 0215 62756649 		.ascii	"bufIndex\000"
 1806      6E646578 
 1806      00
 1807              	.LASF39:
 1808 021e 55415254 		.ascii	"UART_1_SendBreak\000"
 1808      5F315F53 
 1808      656E6442 
 1808      7265616B 
 1808      00
 1809              	.LASF34:
 1810 022f 55415254 		.ascii	"UART_1_PutArray\000"
 1810      5F315F50 
 1810      75744172 
 1810      72617900 
 1811              	.LASF47:
 1812 023f 433A5C55 		.ascii	"C:\\Users\\Matthew Arbesfeld\\Documents\\PSoC Creat"
 1812      73657273 
 1812      5C4D6174 
 1812      74686577 
 1812      20417262 
 1813 026e 6F725C42 		.ascii	"or\\BoxesUART\\Boxes5Test.cydsn\000"
 1813      6F786573 
 1813      55415254 
 1813      5C426F78 
 1813      65733554 
 1814              	.LASF13:
 1815 028c 63686172 		.ascii	"char8\000"
 1815      3800
 1816              	.LASF16:
 1817 0292 73697A65 		.ascii	"sizetype\000"
 1817      74797065 
 1817      00
 1818              	.LASF27:
 1819 029b 74784461 		.ascii	"txDataByte\000"
 1819      74614279 
 1819      746500
 1820              	.LASF14:
 1821 02a6 63686172 		.ascii	"char\000"
 1821      00
 1822              	.LASF46:
 1823 02ab 2E5C4765 		.ascii	".\\Generated_Source\\PSoC5\\UART_1.c\000"
 1823      6E657261 
 1823      7465645F 
 1823      536F7572 
 1823      63655C50 
 1824              	.LASF40:
 1825 02cd 7265744D 		.ascii	"retMode\000"
ARM GAS  C:\Users\MATTHE~1\AppData\Local\Temp\cc22MnAF.s 			page 63


 1825      6F646500 
 1826              	.LASF26:
 1827 02d5 55415254 		.ascii	"UART_1_WriteTxData\000"
 1827      5F315F57 
 1827      72697465 
 1827      54784461 
 1827      746100
 1828              	.LASF38:
 1829 02e8 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 1829      5F315F43 
 1829      6C656172 
 1829      54784275 
 1829      66666572 
 1830              	.LASF49:
 1831 02fd 55415254 		.ascii	"UART_1_initVar\000"
 1831      5F315F69 
 1831      6E697456 
 1831      617200
 1832              	.LASF4:
 1833 030c 6C6F6E67 		.ascii	"long int\000"
 1833      20696E74 
 1833      00
 1834              	.LASF23:
 1835 0315 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 1835      5F315F53 
 1835      65745478 
 1835      496E7465 
 1835      72727570 
 1836              	.LASF19:
 1837 032f 55415254 		.ascii	"UART_1_Enable\000"
 1837      5F315F45 
 1837      6E61626C 
 1837      6500
 1838              	.LASF0:
 1839 033d 7369676E 		.ascii	"signed char\000"
 1839      65642063 
 1839      68617200 
 1840              	.LASF31:
 1841 0349 55415254 		.ascii	"UART_1_PutString\000"
 1841      5F315F50 
 1841      75745374 
 1841      72696E67 
 1841      00
 1842              	.LASF37:
 1843 035a 73697A65 		.ascii	"size\000"
 1843      00
 1844              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
